# Taurscribe Architecture Guide for Beginners

> **Perfect for**: Complete beginners to programming, Rust newcomers, or anyone curious about how speech recognition works!  
> **Goal**: Understand how Taurscribe works through simple explanations, fun analogies, and visual diagrams.

---

## Table of Contents

1. [What is Taurscribe?](#what-is-taurscribe)
2. [The Big Picture](#the-big-picture)
3. [ğŸ–¥ï¸ Platform Support & Hardware Acceleration](#ï¸-platform-support--hardware-acceleration) **â† NEW!**
4. [ğŸ™ï¸ Audio Processing: Whisper vs Parakeet](#-audio-processing-whisper-vs-parakeet)
5. [Complete Audio Processing Flow](#-complete-audio-processing-flow)
6. [Rust Basics You Need to Know](#rust-basics-you-need-to-know)
7. [Complete Flow: Start to Finish](#complete-flow-start-to-finish)
8. [Component Deep Dive](#component-deep-dive)
9. [Understanding Rust Ownership](#understanding-rust-ownership)
10. [Dependencies Explained](#dependencies-explained)
11. [Common Beginner Questions](#common-beginner-questions)
12. [Cumulative Context Feature](#cumulative-context-feature)
13. [Annotated Rust Code Examples](#annotated-rust-code-examples)
14. [Model Selection Feature](#model-selection-feature)
15. [Voice Activity Detection (VAD)](#-voice-activity-detection-vad)
16. [ğŸ“ Module Architecture](#-module-architecture)
17. [File & Function Reference](#-file--function-reference)

---

## What is Taurscribe?

Taurscribe is a **desktop application** that listens to your voice and magically turns it into text using artificial intelligence!

Think of it like having a super-fast personal assistant that writes down everything you say.

**Technology Stack** (in plain English):
- **Frontend**: React + TypeScript (the pretty buttons and screens you see)
- **Backend**: Rust + Tauri (the super-fast engine that does all the hard work)
- **AI Engines**: Two powerful brains to choose from:
  - ğŸ§  **Whisper AI** - Very accurate, great for all situations
  - âš¡ **Parakeet Nemotron** - Lightning fast, optimized for real-time streaming

**Key Features**:
- âœ… Real-time transcription while you speak (see words appear as you talk!)
- âœ… High-quality final transcript when you stop
- âœ… GPU acceleration for blazing speed (uses your graphics card!)
- âœ… Two AI engines to choose from (Whisper or Parakeet)
- âœ… Multiple models for each engine (pick small & fast or large & accurate)
- âœ… Voice Activity Detection (automatically skips silence)

---

## ğŸ‰ Refactored Architecture (January 2026)

Taurscribe recently underwent a major code reorganization for better maintainability:

### **Before Refactoring**
```
âŒ lib.rs: 1,151 lines (monolithic, hard to navigate)
âŒ Everything in one file
âŒ Hard to find specific features
```

### **After Refactoring**
```
âœ… lib.rs: 115 lines (90% reduction!)
âœ… 19 focused modules organized by feature
âœ… Easy to navigate: recording â†’ commands/recording.rs
âœ… Ready for team development
```

**No Breaking Changes!** The app works exactly the same - we just made the code much easier to maintain. See [Module Architecture](#-module-architecture) for details.

---

## The Big Picture

### ğŸ½ï¸ Restaurant Analogy

Imagine Taurscribe as a **restaurant kitchen**. Here's how the pieces work together:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸ½ï¸ TAURSCRIBE RESTAURANT                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ğŸ‘¤ CUSTOMER (You)                                              â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”‚ "Start recording!" (Click button)                       â”‚
â”‚      â–¼                                                          â”‚
â”‚  ğŸ“‹ WAITER (Frontend - App.tsx)                                â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”‚ Takes your order via Tauri bridge                       â”‚
â”‚      â–¼                                                          â”‚
â”‚  ğŸ‘¨â€ğŸ³ HEAD CHEF (Backend - lib.rs)                              â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”‚ Organizes the kitchen                                   â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”œâ”€â”€â–º ğŸ¤ SUPPLIER (Microphone)                             â”‚
â”‚      â”‚         Fresh ingredients arrive every 10ms!            â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”œâ”€â”€â–º ğŸ‘¨â€ğŸ³ COOK #1 (File Writer Thread)                     â”‚
â”‚      â”‚         "I'll preserve the ingredients"                 â”‚
â”‚      â”‚         Saves audio to WAV file                         â”‚
â”‚      â”‚                                                          â”‚
â”‚      â”œâ”€â”€â–º ğŸ‘¨â€ğŸ³ COOK #2 (Whisper Thread)                         â”‚
â”‚      â”‚         "I'll taste-test every 6 seconds"               â”‚
â”‚      â”‚         Real-time transcription preview                 â”‚
â”‚      â”‚                                                          â”‚
â”‚      â””â”€â”€â–º ğŸ§‘â€ğŸ”¬ MASTER CHEF (WhisperManager)                     â”‚
â”‚            "I analyze with AI precision"                       â”‚
â”‚            Final professional-quality transcription            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”„ Simple Data Flow

```
ğŸ¤ Your Voice
    â”‚
    â”œâ”€â”€â–º Microphone captures sound waves
    â”‚
    â”œâ”€â”€â–º Converts to numbers (samples)
    â”‚
    â”œâ”€â”€â–º Split into two streams:
    â”‚
    â”œâ”€â”€â–º Stream 1 â†’ ğŸ’¾ Save to disk (WAV file)
    â”‚
    â””â”€â”€â–º Stream 2 â†’ ğŸ¤– AI transcription â†’ ğŸ“ Text
```

---

## ğŸ–¥ï¸ Platform Support & Hardware Acceleration

Taurscribe is designed to run on **multiple operating systems** and **leverage hardware acceleration** for maximum performance. This section explains how the application adapts to different platforms and hardware configurations.

---

### ğŸŒ Supported Platforms

Taurscribe supports the following platforms with optimized builds for each:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAURSCRIBE PLATFORM MATRIX                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  âœ… Windows (x86_64)    - CUDA + Vulkan + DirectML                  â”‚
â”‚  âœ… Windows (ARM64)     - DirectML + CPU (Snapdragon X)             â”‚
â”‚  âœ… macOS (Apple Silicon) - CoreML + Metal                          â”‚
â”‚  âœ… macOS (Intel)       - CPU + XNNPACK                             â”‚
â”‚  âœ… Linux (x86_64)      - CUDA + Vulkan + TensorRT                  â”‚
â”‚  âœ… Linux (ARM64)       - CPU + XNNPACK (Raspberry Pi, etc.)        â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### âš¡ Hardware Acceleration Technologies

Taurscribe intelligently selects the best acceleration technology based on your hardware:

#### ğŸ¯ **CUDA** (NVIDIA GPUs)
**Platforms**: Windows x64, Linux x64  
**Use Case**: NVIDIA graphics cards (GeForce RTX, Quadro, Tesla)  
**Performance**: â­â­â­â­â­ **Best Performance** (up to 60x realtime)

```rust
// Enabled in Cargo.toml for Windows/Linux x86_64:
whisper-rs = { features = ["cuda", "vulkan"] }
parakeet-rs = { features = ["cuda"] }
ort = { features = ["cuda", "tensorrt"] }
```

**How It Works**:
- Whisper: CUDA kernel acceleration for encoder/decoder
- Parakeet: CUDA execution provider for ONNX Runtime
- Automatic fallback to CPU if NVIDIA driver not found

**Detection Logic** (`whisper.rs` lines 317-322):
```rust
fn is_cuda_available(&self) -> bool {
    std::process::Command::new("nvidia-smi")
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}
```

---

#### ğŸŒ‹ **Vulkan** (Universal GPU)
**Platforms**: Windows x64, Linux x64  
**Use Case**: AMD GPUs, Intel Arc, older NVIDIA GPUs  
**Performance**: â­â­â­â­ **Excellent** (up to 30x realtime)

```rust
// Enabled in Cargo.toml for Windows/Linux x86_64:
whisper-rs = { features = ["vulkan"] }
```

**How It Works**:
- Cross-platform GPU API (works on AMD, Intel, NVIDIA)
- Whisper: Vulkan compute shaders for parallel processing
- Automatic selection if CUDA not available

**Use Cases**:
- AMD Radeon RX 6000/7000 series
- Intel Arc A-series
- NVIDIA GPUs without CUDA drivers

---

#### ğŸªŸ **DirectML** (Windows Universal GPU)
**Platforms**: Windows x64, Windows ARM64  
**Use Case**: Windows devices with any GPU or NPU (Neural Processing Unit)  
**Performance**: â­â­â­â­ **Very Good** (up to 25x realtime)

```rust
// Enabled in Cargo.toml for Windows:
[target.'cfg(all(target_os = "windows", target_arch = "x86_64"))'.dependencies]
parakeet-rs = { features = ["directml"] }
ort = { features = ["directml"] }

[target.'cfg(all(target_os = "windows", target_arch = "aarch64"))'.dependencies]
parakeet-rs = { features = ["directml"] }
ort = { features = ["directml"] }
```

**How It Works**:
- Microsoft's hardware-accelerated ML framework
- Works with ANY GPU (NVIDIA, AMD, Intel) via DirectX 12
- **Special**: Supports NPUs on Snapdragon X ARM processors
- Parakeet: DirectML execution provider for ONNX Runtime

**Use Cases**:
- Qualcomm Snapdragon X Elite/Plus (Windows ARM laptops)
- AMD Radeon GPUs on Windows
- Intel Iris Xe integrated graphics
- Surface devices with NPUs

---

#### ğŸ **CoreML** (Apple Silicon)
**Platforms**: macOS ARM64 (M1/M2/M3/M4)  
**Use Case**: Apple Silicon Macs  
**Performance**: â­â­â­â­â­ **Excellent** (Neural Engine acceleration)

```rust
// Enabled in Cargo.toml for macOS:
[target.'cfg(target_os = "macos")'.dependencies]
ort = { features = ["coreml", "xnnpack"] }
```

**How It Works**:
- Parakeet: CoreML execution provider uses Apple Neural Engine
- Leverages dedicated ML hardware on Apple Silicon chips
- Fallback to Metal GPU if Neural Engine unavailable

**Special Notes**:
- Requires macOS 13.4+ (set in `build.rs`)
- Only applies to Parakeet (ONNX Runtime models)
- Whisper uses Metal GPU acceleration by default

---

#### ğŸï¸ **TensorRT** (NVIDIA Optimized Inference)
**Platforms**: Windows x64, Linux x64  
**Use Case**: NVIDIA GPUs with TensorRT runtime installed  
**Performance**: â­â­â­â­â­ **Maximum Speed** (up to 80x realtime)

```rust
// Enabled in Cargo.toml for Windows/Linux x86_64:
ort = { features = ["tensorrt"] }
```

**How It Works**:
- NVIDIA's optimized inference engine
- Parakeet: TensorRT execution provider for ONNX models
- Requires separate TensorRT installation
- Automatic fallback to CUDA if TensorRT unavailable

---

#### ğŸ’¨ **XNNPACK** (Optimized CPU)
**Platforms**: All (macOS, Windows, Linux, ARM)  
**Use Case**: CPU fallback or devices without GPU  
**Performance**: â­â­â­ **Good** (up to 10x realtime)

```rust
// Enabled in Cargo.toml for all platforms:
ort = { features = ["xnnpack"] }
```

**How It Works**:
- Optimized CPU inference using SIMD instructions (SSE, AVX, NEON)
- Parakeet: XNNPACK execution provider for ONNX Runtime
- Automatic selection if no GPU acceleration available

**Use Cases**:
- Intel Macs (no CoreML support)
- Raspberry Pi / ARM Linux devices
- Virtual machines without GPU passthrough
- Fallback when GPU drivers missing

---

#### ğŸ¢ **Pure CPU** (Fallback)
**Platforms**: All  
**Use Case**: No hardware acceleration available  
**Performance**: â­â­ **Acceptable** (2-5x realtime)

**How It Works**:
- Whisper: Multi-threaded CPU inference
- Parakeet: CPU execution provider for ONNX Runtime
- Always available as last resort

---

### ğŸ§  Platform-Specific Configuration

#### **Cargo.toml Platform Targets**

Taurscribe uses Rust's conditional compilation to include only the necessary features for each platform:

```toml
# ===== BASE DEPENDENCIES (All Platforms) =====
[dependencies]
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
parakeet-rs = { version = "=0.3.0" }
ort = { version = "2.0.0-rc.11", features = ["download-binaries"] }

# ===== PLATFORM-SPECIFIC OVERRIDES =====

# --- macOS (ARM & Intel) ---
[target.'cfg(target_os = "macos")'.dependencies]
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
ort = { features = ["download-binaries", "coreml", "xnnpack"] }
# CoreML: Apple Neural Engine (M1/M2/M3/M4)
# XNNPACK: CPU optimization (Intel Macs fallback)

# --- Windows (x86_64) ---
[target.'cfg(all(target_os = "windows", target_arch = "x86_64"))'.dependencies]
whisper-rs = { features = ["cuda", "vulkan"] }
parakeet-rs = { features = ["cuda", "directml"] }
ort = { features = ["cuda", "directml", "tensorrt", "xnnpack"] }
# CUDA: NVIDIA GPU (primary)
# DirectML: Universal Windows GPU (AMD/Intel fallback)
# TensorRT: NVIDIA optimized inference
# Vulkan: Whisper GPU acceleration
# XNNPACK: CPU optimization

# --- Linux (x86_64) ---
[target.'cfg(all(target_os = "linux", target_arch = "x86_64"))'.dependencies]
whisper-rs = { features = ["cuda", "vulkan"] }
parakeet-rs = { features = ["cuda"] }
ort = { features = ["cuda", "tensorrt", "xnnpack"] }
# CUDA: NVIDIA GPU (primary)
# Vulkan: Whisper GPU acceleration (AMD/Intel)
# TensorRT: NVIDIA optimized inference
# XNNPACK: CPU optimization

# --- Windows (ARM64) ---
[target.'cfg(all(target_os = "windows", target_arch = "aarch64"))'.dependencies]
parakeet-rs = { features = ["directml"] }
ort = { features = ["directml", "xnnpack"] }
# DirectML: Snapdragon X NPU/GPU acceleration
# XNNPACK: CPU optimization
# Note: No whisper-rs CUDA/Vulkan (ARM Windows limitation)

# --- Linux (ARM64) ---
[target.'cfg(all(target_os = "linux", target_arch = "aarch64"))'.dependencies]
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
parakeet-rs = { version = "=0.3.0" }
ort = { features = ["xnnpack"] }
# XNNPACK: CPU optimization for ARM (Raspberry Pi, etc.)
# No GPU acceleration (driver limitations on ARM Linux)
```

---

### ğŸ”§ Build Configuration (`build.rs`)

The `build.rs` file contains platform-specific build logic:

#### **1. macOS Deployment Target**
```rust
#[cfg(target_os = "macos")]
{
    // ONNX Runtime requires macOS 13.4+ for CoreML support
    println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=13.4");
    std::env::set_var("MACOSX_DEPLOYMENT_TARGET", "13.4");
    std::env::set_var("CMAKE_OSX_DEPLOYMENT_TARGET", "13.4");
}
```
**Why?** CoreML and ONNX Runtime require modern macOS versions.

---

#### **2. Windows ARM64 Clang Requirement**
```rust
#[cfg(all(target_os = "windows", target_arch = "aarch64"))]
{
    // whisper.cpp requires Clang for ARM64 Windows (MSVC not supported)
    println!("cargo:warning=Building for Windows ARM64 - Clang/LLVM required");
    std::env::set_var("CC", "clang-cl");
    std::env::set_var("CXX", "clang-cl");
    std::env::set_var("CMAKE_GENERATOR_TOOLSET", "ClangCL");
}
```
**Why?** The `whisper.cpp` C++ library doesn't support MSVC on ARM64, only Clang.

---

#### **3. CUDA Library Search Path (Windows)**
```rust
#[cfg(windows)]
{
    // 1. Try CUDA_PATH environment variable
    if let Ok(cuda_path) = std::env::var("CUDA_PATH") {
        let lib_path = cuda_path.join("lib").join("x64");
        if lib_path.exists() {
            println!("cargo:rustc-link-search=native={}", lib_path.display());
        }
    }

    // 2. Fallback: Standard installation path
    let fallback = r"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.9\lib\x64";
    if std::path::Path::new(fallback).exists() {
        println!("cargo:rustc-link-search=native={}", fallback);
    }
}
```
**Why?** The Rust linker needs help finding CUDA libraries (`cublas.lib`, `cudart.lib`, etc.).

---

### ğŸš€ Hardware Detection Flow

Here's how Taurscribe selects the best acceleration at runtime:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TAURSCRIBE STARTUP: INITIALIZATION               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: WHISPER ENGINE INITIALIZATION (lib.rs)               â”‚
â”‚  - WhisperManager::new()                                      â”‚
â”‚  - whisper.initialize(None)                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: GPU DETECTION (whisper.rs::initialize)              â”‚
â”‚                                                                â”‚
â”‚  try_gpu():                                                    â”‚
â”‚    â”œâ”€â–º Set use_gpu(true) in WhisperContextParameters          â”‚
â”‚    â”œâ”€â–º Attempt WhisperContext::new_with_params()              â”‚
â”‚    â”‚                                                           â”‚
â”‚    â”œâ”€â–º SUCCESS? â”€â”                                            â”‚
â”‚    â”‚             â”‚                                            â”‚
â”‚    â”‚             â””â”€â–º detect_gpu_backend():                    â”‚
â”‚    â”‚                   â”œâ”€â–º Run "nvidia-smi" command           â”‚
â”‚    â”‚                   â”‚                                      â”‚
â”‚    â”‚                   â”œâ”€â–º Success? â†’ GpuBackend::Cuda âœ“      â”‚
â”‚    â”‚                   â””â”€â–º Failed?  â†’ GpuBackend::Vulkan âœ“    â”‚
â”‚    â”‚                                                           â”‚
â”‚    â””â”€â–º FAILED? â†’ try_cpu() â†’ GpuBackend::Cpu âœ“               â”‚
â”‚                                                                â”‚
â”‚  Result: Whisper loaded with CUDA/Vulkan/CPU                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: PARAKEET ENGINE INITIALIZATION (lib.rs)             â”‚
â”‚  - ParakeetManager::new()                                     â”‚
â”‚  - parakeet.initialize(Some("nemotron:nemotron"))             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: PARAKEET GPU DETECTION (parakeet.rs::init_nemotron) â”‚
â”‚                                                                â”‚
â”‚  Cascade try:                                                  â”‚
â”‚    â”œâ”€â–º try_gpu_nemotron():                                    â”‚
â”‚    â”‚     â””â”€â–º ExecutionConfig + ExecutionProvider::Cuda        â”‚
â”‚    â”‚         â”œâ”€â–º SUCCESS? â†’ GpuBackend::Cuda âœ“               â”‚
â”‚    â”‚         â””â”€â–º FAILED?  â†’ Continue â†“                        â”‚
â”‚    â”‚                                                           â”‚
â”‚    â”œâ”€â–º try_directml_nemotron(): (Windows only)                â”‚
â”‚    â”‚     â””â”€â–º ExecutionConfig + ExecutionProvider::DirectML    â”‚
â”‚    â”‚         â”œâ”€â–º SUCCESS? â†’ GpuBackend::DirectML âœ“            â”‚
â”‚    â”‚         â””â”€â–º FAILED?  â†’ Continue â†“                        â”‚
â”‚    â”‚                                                           â”‚
â”‚    â””â”€â–º try_cpu_nemotron():                                    â”‚
â”‚          â””â”€â–º Nemotron::from_pretrained(path, None)            â”‚
â”‚              â””â”€â–º SUCCESS â†’ GpuBackend::Cpu âœ“                  â”‚
â”‚                                                                â”‚
â”‚  Result: Parakeet loaded with CUDA/DirectML/CPU               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FINAL STATE: TWO ENGINES READY                               â”‚
â”‚                                                                â”‚
â”‚  Whisper:  CUDA/Vulkan/CPU                                    â”‚
â”‚  Parakeet: CUDA/DirectML/CPU (with CoreML/TensorRT if avail.) â”‚
â”‚                                                                â”‚
â”‚  Printed to console:                                           â”‚
â”‚    [SUCCESS] Whisper Backend: CUDA                            â”‚
â”‚    [SUCCESS] Loaded Nemotron (Streaming) - nemotron (CUDA)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“Š Platform Comparison Table

| Platform | Whisper Acceleration | Parakeet Acceleration | Best Use Case |
|----------|---------------------|----------------------|---------------|
| **Windows x64 + NVIDIA** | CUDA + Vulkan | CUDA + TensorRT | â­â­â­â­â­ Gaming PCs, Workstations |
| **Windows x64 + AMD** | Vulkan | DirectML | â­â­â­â­ AMD Radeon systems |
| **Windows ARM64** | CPU | DirectML (NPU) | â­â­â­â­ Snapdragon X laptops |
| **macOS Apple Silicon** | Metal | CoreML (Neural Engine) | â­â­â­â­â­ MacBook Pro M1/M2/M3 |
| **macOS Intel** | CPU | XNNPACK | â­â­â­ Older MacBooks |
| **Linux x64 + NVIDIA** | CUDA + Vulkan | CUDA + TensorRT | â­â­â­â­â­ Linux workstations |
| **Linux x64 + AMD** | Vulkan | XNNPACK | â­â­â­ AMD Linux desktops |
| **Linux ARM64** | CPU | XNNPACK | â­â­â­ Raspberry Pi 4/5 |

---

### ğŸ› ï¸ CI/CD Platform Matrix (`.github/workflows/build.yml`)

The GitHub Actions workflow tests all supported platforms:

```yaml
strategy:
  fail-fast: false
  matrix:
    include:
      # --- macOS (Apple Silicon) ---
      - platform: 'macos-latest'
        target: 'aarch64-apple-darwin'
        cuda: false
        acceleration: 'Metal + CoreML'

      # --- Windows (x86_64) ---
      - platform: 'windows-latest'
        target: 'x86_64-pc-windows-msvc'
        cuda: true
        acceleration: 'CUDA + DirectML'

      # --- Windows (ARM64) ---
      - platform: 'windows-latest'
        target: 'aarch64-pc-windows-msvc'
        cuda: false
        acceleration: 'DirectML (NPU)'

      # --- Linux (x86_64) ---
      - platform: 'ubuntu-24.04'
        target: 'x86_64-unknown-linux-gnu'
        cuda: true
        acceleration: 'CUDA + Vulkan'
```

**Key Environment Variables** (build.yml lines 281-314):
```yaml
env:
  CMAKE_GENERATOR: "Ninja"              # Avoid "Path too long" on Windows
  WHISPER_NO_AVX: "1"                   # Disable AVX for CI stability
  WHISPER_NO_AVX2: "1"
  CMAKE_CUDA_ARCHITECTURES: "61;70;75;80;86"  # Pascal, Volta, Turing, Ampere
  MACOSX_DEPLOYMENT_TARGET: "13.4"      # macOS CoreML requirement
  CUDA_PATH: ${{ steps.cuda-toolkit.outputs.CUDA_PATH }}
  VULKAN_SDK: ${{ env.VULKAN_SDK }}
```

---

### ğŸ§© Platform-Specific Considerations

#### **Windows**
- **Long Path Support**: Enabled via registry + `CARGO_TARGET_DIR=C:\bld`
- **CUDA Toolkit**: Installed via `Jimver/cuda-toolkit` action
- **Vulkan SDK**: Required for Whisper Vulkan backend
- **LLVM**: Required for bindgen (Rust â†” C++ bindings)
- **Ninja**: Replaces MSBuild to avoid path length issues

#### **macOS**
- **Deployment Target**: 13.4+ for CoreML/ONNX Runtime
- **Xcode**: Command line tools required for C++ compilation
- **CMake**: Used to build whisper.cpp from source

#### **Linux**
- **GTK/WebKit**: Required for Tauri window rendering
- **ALSA**: Audio device access
- **Vulkan SDK**: Required for Whisper Vulkan backend
- **CUDA Toolkit**: Manual installation (Ubuntu 24.04 repos)

---

### ğŸ“ Key Takeaways

1. **Automatic Selection**: Taurscribe tries GPU first, falls back to CPU
2. **Platform Optimization**: Each OS gets optimized feature flags
3. **Graceful Degradation**: Always works, even without GPU
4. **Transparent**: Backend is printed to console on startup
5. **Future-Proof**: Easy to add new acceleration (e.g., WebGPU, ROCm)

**Example Console Output**:
```
[INFO] Initializing Whisper transcription engine...
[GPU] Attempting GPU acceleration...
[SUCCESS] âœ“ GPU acceleration enabled (CUDA)
[INFO] Backend: CUDA
[INFO] Model loaded: tiny.en-q5_1
[INFO] GPU warm-up complete

[INFO] Initializing Parakeet ASR manager...
[PARAKEET] Loaded Nemotron with CUDA
[SUCCESS] Loaded Nemotron (Streaming) - nemotron (CUDA)
```

---

## ğŸ™ï¸ Audio Processing: Whisper vs Parakeet

This is where the magic happens! Let's see exactly what happens to your voice when it goes through each AI engine.

### ğŸ• Pizza Delivery Analogy

Imagine your audio is like a pizza being delivered:

- **Whisper AI** = Traditional delivery - waits for a full pizza box (6 seconds), checks if it's worth delivering (VAD), then delivers high-quality results
- **Parakeet Nemotron** = Speed delivery service - delivers small slices instantly (0.56 seconds), no checking, maximum speed!

---

### ğŸ§  WHISPER AI PIPELINE

Whisper is like a **perfectionist chef** - it waits for enough ingredients, carefully checks quality, and delivers amazing results.

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ğŸ¤ YOUR VOICE â†’ WHISPER AI
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STEP 1: ğŸ¤ MICROPHONE CAPTURE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Raw Audio Stream (from your microphone)                                     â”‚
â”‚ â€¢ Format: 48,000 samples per second (48kHz)                                 â”‚
â”‚ â€¢ Channels: 2 (Stereo - Left & Right)                                       â”‚
â”‚ â€¢ Data Type: Floating point numbers (-1.0 to 1.0)                           â”‚
â”‚                                                                              â”‚
â”‚ Example data: [0.01, -0.02, 0.03, -0.01, 0.04, ...]                         â”‚
â”‚ (These numbers represent air pressure at each moment in time)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ New audio arrives every ~10 milliseconds
         â–¼

STEP 2: ğŸ›ï¸ CONVERT TO MONO (Stereo â†’ Single Channel)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Why? AI models expect ONE audio channel, not two                            â”‚
â”‚                                                                              â”‚
â”‚ BEFORE (Stereo):                                                             â”‚
â”‚   Left:  [0.5, 0.3, 0.7]                                                     â”‚
â”‚   Right: [0.4, 0.2, 0.6]                                                     â”‚
â”‚                                                                              â”‚
â”‚ AFTER (Mono):                                                                â”‚
â”‚   Combined: [(0.5+0.4)/2, (0.3+0.2)/2, (0.7+0.6)/2]                         â”‚
â”‚            = [0.45, 0.25, 0.65]                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Now we have single-channel audio
         â–¼

STEP 3: ğŸ”„ RESAMPLE (48kHz â†’ 16kHz)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Why? Whisper was trained on 16kHz audio (CD quality uses 44kHz)             â”‚
â”‚                                                                              â”‚
â”‚ BEFORE: 48,000 samples per second                                           â”‚
â”‚   [s1, s2, s3, s4, s5, s6, s7, s8, ...]  (very detailed)                    â”‚
â”‚                                                                              â”‚
â”‚ AFTER: 16,000 samples per second                                            â”‚
â”‚   [s1, ----, s3, ----, s5, ----]  (every 3rd sample, simplified)            â”‚
â”‚                                                                              â”‚
â”‚ Result: File is 3x smaller, but still perfect for speech!                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Audio is now ready for AI processing
         â–¼

STEP 4: ğŸ“¦ BUFFER INTO CHUNKS (16kHz audio â†’ 6-second chunks)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Whisper needs larger chunks to understand context                           â”‚
â”‚                                                                              â”‚
â”‚ Chunk Size: 6 seconds = 96,000 samples                                      â”‚
â”‚                                                                              â”‚
â”‚ Incoming stream: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ...]          â”‚
â”‚                                                                              â”‚
â”‚ Buffered chunks:                                                             â”‚
â”‚   Chunk 1 (0-6s):  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] â†’ Ready to process                    â”‚
â”‚   Chunk 2 (6-12s): [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] â†’ Still collecting...                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Every 6 seconds, we process a chunk
         â–¼

STEP 5: ğŸ”‡ VAD CHECK (Voice Activity Detection)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Before processing, check: "Is anyone actually talking?"                     â”‚
â”‚                                                                              â”‚
â”‚ VAD Algorithm (Energy-Based):                                                â”‚
â”‚   1. Calculate audio "loudness" (RMS = Root Mean Square)                    â”‚
â”‚   2. If RMS < 0.005 â†’ Silence (0% speech)                                   â”‚
â”‚   3. If RMS > 0.025 â†’ Speech (100% speech)                                  â”‚
â”‚   4. In between â†’ Calculate probability                                     â”‚
â”‚                                                                              â”‚
â”‚ Example:                                                                     â”‚
â”‚   Chunk 1: [0.001, 0.002, 0.001, ...] â†’ VAD = 0% â†’ âŒ SKIP                  â”‚
â”‚   Chunk 2: [0.15, 0.22, 0.18, ...]    â†’ VAD = 95% â†’ âœ… PROCESS              â”‚
â”‚                                                                              â”‚
â”‚ Benefit: Saves GPU time and prevents hallucinations (Whisper making up text)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Only chunks with speech continue
         â–¼

STEP 6: ğŸ§  WHISPER AI TRANSCRIPTION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ The AI model processes the audio and outputs text                           â”‚
â”‚                                                                              â”‚
â”‚ Input: 96,000 audio samples (6 seconds of speech)                           â”‚
â”‚                                                                              â”‚
â”‚ Processing Steps:                                                            â”‚
â”‚   1. Create Whisper State (AI session)                                      â”‚
â”‚   2. Configure parameters:                                                   â”‚
â”‚      â€¢ Language: English                                                     â”‚
â”‚      â€¢ Strategy: Greedy (pick most likely word immediately)                 â”‚
â”‚      â€¢ Threads: 4 CPU cores                                                  â”‚
â”‚      â€¢ Context: Previous transcript (for better accuracy)                   â”‚
â”‚   3. Run AI inference on GPU/CPU                                             â”‚
â”‚   4. Extract text segments from AI output                                   â”‚
â”‚                                                                              â”‚
â”‚ Output: "Hello world, this is a test transcription."                        â”‚
â”‚                                                                              â”‚
â”‚ Performance: Typically 100-300ms per 6-second chunk on GPU                  â”‚
â”‚              (20-60x faster than real-time!)                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Text is ready!
         â–¼

STEP 7: ğŸ’¾ CUMULATIVE CONTEXT (Memory)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Whisper remembers what was said before for better accuracy                  â”‚
â”‚                                                                              â”‚
â”‚ First chunk:  "Hello world"                                                 â”‚
â”‚   â†’ Save to memory: "Hello world"                                           â”‚
â”‚                                                                              â”‚
â”‚ Second chunk: "this is cool"                                                â”‚
â”‚   â†’ Context provided: "Hello world"                                         â”‚
â”‚   â†’ AI understands: "...continuing from 'Hello world', so 'this' refers..." â”‚
â”‚   â†’ Save to memory: "Hello world this is cool"                              â”‚
â”‚                                                                              â”‚
â”‚ This makes transcription much more accurate!                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Send to frontend
         â–¼

STEP 8: ğŸ“¤ SEND TO UI (Frontend Display)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Text appears in your application window!                                    â”‚
â”‚                                                                              â”‚
â”‚ Event: "transcription-chunk"                                                â”‚
â”‚   {                                                                          â”‚
â”‚     text: "Hello world this is cool",                                       â”‚
â”‚     processing_time_ms: 150,                                                â”‚
â”‚     method: "Whisper"                                                        â”‚
â”‚   }                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            ğŸ¯ FINAL PROCESSING PASS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When you click "Stop Recording", Whisper does ONE more high-quality pass:

1. ğŸ“ Load the complete WAV file from disk
2. ğŸ”‡ Apply VAD to remove ALL silence (not just chunks)
3. ğŸ§  Process entire cleaned audio in one go (with 8 CPU threads instead of 4)
4. ğŸ“ Return ultra-accurate final transcript

Why? The final pass has full context and can make better decisions!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

### âš¡ PARAKEET NEMOTRON PIPELINE

Parakeet is like a **speed demon** - optimized for instant results with minimal delay. Perfect for live streaming!

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      ğŸ¤ YOUR VOICE â†’ PARAKEET NEMOTRON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STEP 1: ğŸ¤ MICROPHONE CAPTURE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Same as Whisper - raw audio from microphone                                 â”‚
â”‚ â€¢ Format: 48,000 samples per second                                         â”‚
â”‚ â€¢ Channels: 2 (Stereo)                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼

STEP 2: ğŸ›ï¸ CONVERT TO MONO
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Same process as Whisper                                                     â”‚
â”‚ Stereo â†’ Mono conversion                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼

STEP 3: ğŸ”„ RESAMPLE (48kHz â†’ 16kHz)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Same process as Whisper                                                     â”‚
â”‚ Parakeet also expects 16kHz audio                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼

STEP 4: âš¡ IMMEDIATE PROCESSING (No Buffering!)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸš€ KEY DIFFERENCE: Parakeet processes IMMEDIATELY as audio arrives!         â”‚
â”‚                                                                              â”‚
â”‚ Chunk Size: 0.56 seconds = 8,960 samples                                    â”‚
â”‚ (10x smaller than Whisper's 6-second chunks!)                               â”‚
â”‚                                                                              â”‚
â”‚ Incoming stream: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘]                                                  â”‚
â”‚                   â–²                                                          â”‚
â”‚                   â””â”€â”€â”€ Process NOW! (no waiting)                             â”‚
â”‚                                                                              â”‚
â”‚ Timeline:                                                                    â”‚
â”‚   0.00s - 0.56s: [â–ˆâ–ˆâ–ˆâ–ˆ] â†’ Process â†’ "Hello"                                 â”‚
â”‚   0.56s - 1.12s: [â–ˆâ–ˆâ–ˆâ–ˆ] â†’ Process â†’ "world"                                 â”‚
â”‚   1.12s - 1.68s: [â–ˆâ–ˆâ–ˆâ–ˆ] â†’ Process â†’ "this"                                  â”‚
â”‚   1.68s - 2.24s: [â–ˆâ–ˆâ–ˆâ–ˆ] â†’ Process â†’ "is"                                    â”‚
â”‚                                                                              â”‚
â”‚ Result: Words appear almost instantly as you speak!                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ No VAD checking (speed is priority)
         â–¼

STEP 5: âŒ NO VAD CHECK
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ Parakeet SKIPS Voice Activity Detection for speed                        â”‚
â”‚                                                                              â”‚
â”‚ Why?                                                                         â”‚
â”‚   â€¢ VAD adds processing delay                                               â”‚
â”‚   â€¢ Parakeet's streaming model handles silence well                         â”‚
â”‚   â€¢ Goal is minimum latency, not maximum efficiency                         â”‚
â”‚                                                                              â”‚
â”‚ Trade-off: Processes slightly more silence, but results come faster         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Straight to AI
         â–¼

STEP 6: ğŸ¦œ PARAKEET NEMOTRON INFERENCE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nemotron model: NVIDIA's streaming-optimized ASR                            â”‚
â”‚                                                                              â”‚
â”‚ Input: 8,960 audio samples (0.56 seconds of audio)                          â”‚
â”‚                                                                              â”‚
â”‚ Model Architecture:                                                          â”‚
â”‚   â€¢ Encoder: Processes audio features                                       â”‚
â”‚   â€¢ Decoder + Joint Network: Produces text                                  â”‚
â”‚   â€¢ Stateful: Remembers previous audio automatically                        â”‚
â”‚                                                                              â”‚
â”‚ Processing:                                                                  â”‚
â”‚   1. Audio â†’ Encoder (ONNX model: encoder.onnx)                             â”‚
â”‚   2. Features â†’ Decoder + Joint (ONNX model: decoder_joint.onnx)            â”‚
â”‚   3. Decoder uses built-in state from previous chunks                       â”‚
â”‚   4. Output: Text tokens â†’ Decoded string                                   â”‚
â”‚                                                                              â”‚
â”‚ Output: "Hello " (partial result)                                           â”‚
â”‚                                                                              â”‚
â”‚ Performance: 50-100ms per chunk on GPU (even faster than Whisper!)          â”‚
â”‚              (because chunks are 10x smaller)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Text is ready (almost instantly!)
         â–¼

STEP 7: ğŸ”„ BUILT-IN STATE (No Manual Context Needed)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ Parakeet automatically maintains internal state                          â”‚
â”‚                                                                              â”‚
â”‚ Unlike Whisper (where WE provide context), Nemotron has:                    â”‚
â”‚   â€¢ Hidden state vector (remembers what it heard)                           â”‚
â”‚   â€¢ Automatic reset on silence                                              â”‚
â”‚   â€¢ Seamless continuation between chunks                                    â”‚
â”‚                                                                              â”‚
â”‚ We just call: nemotron.transcribe_chunk(audio) â†’ it handles context!       â”‚
â”‚                                                                              â”‚
â”‚ This makes integration simpler and faster                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Send to frontend
         â–¼

STEP 8: ğŸ“¤ SEND TO UI (Frontend Display)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Text appears in your application window (almost instantly!)                 â”‚
â”‚                                                                              â”‚
â”‚ Event: "transcription-chunk"                                                â”‚
â”‚   {                                                                          â”‚
â”‚     text: "Hello ",                                                          â”‚
â”‚     processing_time_ms: 75,                                                 â”‚
â”‚     method: "Parakeet"                                                       â”‚
â”‚   }                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            ğŸ¯ FINAL PROCESSING PASS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When you click "Stop Recording", Parakeet does:

1. ğŸ“ Load the complete WAV file from disk
2. âŒ NO VAD processing (maintains streaming consistency)
3. ğŸ¦œ Process entire audio with Parakeet in small chunks
4. ğŸ“ Return final transcript

Difference from Whisper: No VAD on final pass to keep streaming characteristics!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

### ğŸ“Š SIDE-BY-SIDE COMPARISON

Let's compare both engines processing the same 12-second recording: "Hello world, this is a test."

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                           TIME COMPARISON DIAGRAM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§  WHISPER AI TIMELINE (6-second chunks + VAD)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Time:  0s         6s                    12s
       â”‚          â”‚                     â”‚
Audio: [â•â•â•â•â•â•â•â•â•â•]                     ]â•â•â•â•â•â•â•â•â•â•]
       â”‚          â”‚                     â”‚
       â”‚   Wait...â”‚                     Wait...
       â”‚          â–¼                              â–¼
VAD:              [Check... 95% speech âœ“]       [Check... 92% speech âœ“]
       â”‚          â”‚                     â”‚
       â”‚          â–¼                              â–¼
AI:               [Process 6s... 150ms]         [Process 6s... 140ms]
       â”‚          â”‚                     â”‚
Output:           "Hello world"                 "this is a test"

Total Latency: 6 seconds (buffering) + 150ms (processing) = 6.15 seconds


âš¡ PARAKEET NEMOTRON TIMELINE (0.56-second chunks, no VAD)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Time:  0.56s  1.12s  1.68s  2.24s  2.80s  ... 12s
       â”‚      â”‚      â”‚      â”‚      â”‚          â”‚
Audio: ]â–ˆ]    ]â–ˆ]    ]â–ˆ]    ]â–ˆ]    ]â–ˆ]   ... ]â–ˆ]
       â”‚      â”‚      â”‚      â”‚      â”‚          â”‚
       â–¼      â–¼      â–¼      â–¼      â–¼          â–¼
AI:    [75ms] [68ms] [72ms] [70ms] [71ms] ... [69ms]
       â”‚      â”‚      â”‚      â”‚      â”‚          â”‚
       â–¼      â–¼      â–¼      â–¼      â–¼          â–¼
Output:"Hel"  "lo "  "wor" "ld"  "this" ... "test"

Total Latency: 0.56 seconds (buffering) + 75ms (processing) = 0.635 seconds


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                WINNER: Parakeet
                     10x faster display of first word!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

### ğŸ¯ WHEN TO USE WHICH ENGINE?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          USE WHISPER AI WHEN...                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… You need maximum accuracy                                                 â”‚
â”‚ âœ… Recording has lots of silence (VAD helps skip it)                         â”‚
â”‚ âœ… You're transcribing lectures, meetings, or long-form content             â”‚
â”‚ âœ… Background noise is an issue (VAD filters it out)                         â”‚
â”‚ âœ… You prefer better context understanding (cumulative memory)              â”‚
â”‚ âœ… You can wait 6 seconds for each result                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        USE PARAKEET NEMOTRON WHEN...                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âš¡ You need minimum latency (live streaming, gaming, real-time apps)        â”‚
â”‚ âš¡ Continuous speech without long pauses                                     â”‚
â”‚ âš¡ You want to see words appear almost instantly                             â”‚
â”‚ âš¡ You're doing live captions or real-time subtitles                         â”‚
â”‚ âš¡ Speed is more important than perfect accuracy                             â”‚
â”‚ âš¡ You have a good GPU (CUDA acceleration is amazing!)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ§ª TECHNICAL SPECIFICATIONS

| Feature | Whisper AI | Parakeet Nemotron |
|---------|-----------|------------------|
| **Chunk Size** | 6.0 seconds (96,000 samples) | 0.56 seconds (8,960 samples) |
| **Latency** | ~6.15 seconds | ~0.635 seconds |
| **VAD** | âœ… Yes (energy-based) | âŒ No |
| **Context Management** | Manual (we provide previous text) | Automatic (built-in state) |
| **GPU Support** | CUDA, Vulkan, CPU | CUDA, CPU |
| **Model Format** | GGML (.bin files) | ONNX (.onnx files) |
| **Accuracy** | Excellent (95-98%) | Very Good (92-96%) |
| **Best For** | Accuracy | Speed |
| **Threads (Live)** | 4 CPU threads | GPU-optimized |
| **Threads (Final)** | 8 CPU threads | GPU-optimized |

---

### ğŸ’¡ BEGINNER TIP: How to Choose?

**Try this simple test:**

1. Install both models
2. Record yourself saying a sentence
3. Try Whisper first â†’ Notice the 6-second wait, then high accuracy
4. Try Parakeet â†’ Notice words appearing almost instantly

**My recommendation?**
- For meetings/lectures: Use Whisper
- For live streaming/gaming: Use Parakeet
- Can't decide? Start with Whisper (it's more forgiving of imperfect audio)

---

## ğŸ™ï¸ Voice Activity Detection (VAD)

**VAD** is the "gatekeeper" of the system. It determines if you are actually speaking before the AI tries to transcribe anything.

### â“ Why was VAD added?
1. **Efficiency**: AI transcription is heavy on the GPU/CPU. We shouldn't waste power transcribing "dead air" (silence).
2. **Speed**: By skipping silent chunks during real-time recording, we reduce the load on the system.
3. **Accuracy**: Sometimes Whisper "hallucinates" when given silence (it might output random punctuation or "Thank you for watching!"). VAD prevents this.
4. **Final Polish**: In the final transcription, we "trim" all silence segments, making the processing much faster and the transcript cleaner.

### ğŸ§  How It Works: Energy-Based Detection

Currently, Taurscribe uses **Energy-Based VAD** (RMS). It's like a sound-level meter at a concert.

**The Logic**:
- Calculate the **RMS (Root Mean Square)** of the audio chunk.
- Compare it to a **Threshold** (default: `0.005`).
- If Energy > Threshold â†’ **Speech detected!** âœ…
- If Energy < Threshold â†’ **Silence.** ğŸ”‡

> **Note**: While simple, this is extremely fast. We plan to upgrade to **Silero AI VAD** (a deep learning model) once we resolve library compatibility issues, which will better distinguish between "speech" and "background noise" (like a loud fan).

### ğŸ“Š VAD Flow Diagrams

#### 1. Real-Time Gatekeeper (Buffering Phase)
During recording, the 6-second chunks are checked before hitting the AI.

```mermaid
graph TD
    A[6s Audio Chunk Arrives] --> B{VAD Check};
    B -- "RMS > 0.005 (Speech)" --> C[ğŸš€ Run Whisper AI];
    B -- "RMS < 0.005 (Silence)" --> D[ğŸ›‘ Skip AI];
    C --> E[Show Text in UI];
    D --> F[Print 'Silence' to log];
```

#### 2. Final Silence Trimming (Stop Phase)
When you stop, we scan the *entire* file and stitch together only the speech parts.

```
ORIGINAL FILE:
[---SPEECH---] [...SILENCE...] [---SPEECH---] [...SILENCE...]
0s           5s             15s           20s           30s

VAD SCANNING:
Step 1: Identify Speech Segments
Seg A: 0s-7s (Speech + 500ms padding)
Seg B: 14s-22s (Speech + 500ms padding)

STITCHING:
[Seg A][Seg B] = 15s total audio (instead of 30s)

FINAL TRANSCRIPTION:
AI only processes the 15s of "Clean Audio"
```

### âš¡ Performance Impact

Adding VAD significantly improves transcription speed, especially for recordings with pauses.

| Feature | Without VAD | With VAD | Benefit |
|---------|-------------|----------|---------|
| **Real-time Latency** | Constant load | Low load during pauses | Cooler CPU/GPU |
| **Final Speed** (30s audio w/ 15s silence) | ~1000ms | ~550ms | **45% Faster** |
| **Accuracy** | May hallucinate on silence | Perfectly silent during pauses | No "phantom" text |

### ğŸ› ï¸ Implementation Reference
- **File**: `src-tauri/src/vad.rs` - Contains the `VADManager` logic.
- **Function**: `is_speech()` - Used for real-time 6s chunks.
- **Function**: `get_speech_timestamps()` - Used for final silence trimming.
- **Integration**: `lib.rs` - Orchestrates the check before calling Whisper.

---

### ğŸ“Š Performance Example

30-second recording on **RTX 4070** with **base.en-q5_0** model:

**Real-Time Chunks (during recording):**
- Chunk 1 (0-6s):   ~150ms â†’ **40x realtime**
- Chunk 2 (6-12s):  ~150ms â†’ **40x realtime**
- Chunk 3 (12-18s): ~150ms â†’ **40x realtime**
- Chunk 4 (18-24s): ~150ms â†’ **40x realtime**
- Chunk 5 (24-30s): ~150ms â†’ **40x realtime**

**Final Transcription (after recording):**
- File I/O:       50ms
- Stereo â†’ Mono:  10ms
- Resample:       100ms
- State Setup:    5ms
- Whisper AI:     750ms â†’ **40x realtime**
- Extract Text:   5ms

**Total**: ~920ms for 30s audio = **32.6x realtime**

### ğŸ” Key Technical Details

#### 1. **Dual Stream Strategy**
- **Stream 1**: Preserves original stereo for final quality
- **Stream 2**: Real-time mono for live preview

#### 2. **Buffering Strategy**
- **Why 6 seconds?** Balance between latency & accuracy
- Too short (1-2s) â†’ incomplete sentences â†’ hallucinations
- Too long (30s+) â†’ feels slow

#### 3. **Cumulative Context**
- Each chunk uses previous transcript as prompt
- Improves accuracy on names, technical terms
- Cleared on new recording

#### 4. **Resampling**
- **Mic**: 48kHz (or 44.1kHz) - hardware native
- **Whisper**: 16kHz - model requirement
- **rubato**: High-quality sinc resampling

#### 5. **Mono Conversion**
- **Why?** Whisper expects mono audio
- **Method**: Average left & right channels
- **When?** Before sending to Whisper, after saving to file

#### 6. **GPU Acceleration**
- **Encoder**: ~50ms (processes audio features)
- **Decoder**: ~100ms (generates text tokens)
- **Total**: 40x faster than realtime

#### 7. **Thread Safety**
- `Arc<Mutex<WhisperManager>>` shared between threads
- Channels for lock-free communication
- No data races, no deadlocks

---

## Complete Flow: Start to Finish

Let's walk through what happens when you click "Start Recording".

### ğŸ“± Phase 1: User Clicks Button

**File**: `src/App.tsx` lines 42-50

```typescript
<button
  onClick={async () => {
    try {
      const res = await invoke("start_recording");
      //               ^^^^^^ This is the bridge to Rust!
      setGreetMsg(res as string);
      setIsRecording(true);
    } catch (e) {
      setGreetMsg("Error: " + e);
    }
  }}
>
  Start Recording
</button>
```

**What happens**:
1. You click the button
2. JavaScript calls `invoke("start_recording")`
3. Tauri **bridges** from JavaScript â†’ Rust
4. Rust function `start_recording()` runs
5. Rust returns a result
6. JavaScript receives it and updates the UI

**Analogy**: You press a doorbell â†’ someone inside hears it â†’ they respond â†’ you hear their voice through the door.

---

### ğŸ¦€ Phase 2: Rust Backend Starts

**File**: `src-tauri/src/lib.rs` lines 114-333

Let's break down `start_recording()` step-by-step:

#### Step 1: Get the Microphone (lines 115-120)

```rust
let host = cpal::default_host();
let device = host.default_input_device().ok_or("No input device")?;
let config: cpal::StreamConfig = device
    .default_input_config()
    .map_err(|e| e.to_string())?
    .into();
```

**Plain English**:
1. "Hey computer, what audio system do you have?" â†’ `cpal::default_host()`
2. "Give me the default microphone" â†’ `default_input_device()`
3. "What format does it use?" â†’ `default_input_config()`

**Config contains**:
- Sample rate: 48000 Hz (48,000 measurements per second)
- Channels: 2 (stereo: left + right) or 1 (mono)
- Format: f32 (floating-point numbers from -1.0 to 1.0)

**Analogy**: Like asking "What camera do I have?" and learning it records 4K at 60fps.

#### Step 2: Create Save Location (lines 123-128)

```rust
let recordings_dir = get_recordings_dir()?;
// Returns: C:\Users\YOU\AppData\Local\Taurscribe\temp\

let filename = format!("recording_{}.wav", chrono::Utc::now().timestamp());
// Creates: recording_1737280000.wav

let path = recordings_dir.join(&filename);
```

**What's a timestamp?**
```rust
chrono::Utc::now().timestamp()  // Returns: 1737280000
// This is "Unix timestamp" = seconds since Jan 1, 1970
// Ensures unique filename every time!
```

**Why AppData?**
- Windows: `C:\Users\YOU\AppData\Local\Taurscribe\temp\`
- macOS: `~/Library/Application Support/Taurscribe/temp/`
- Linux: `~/.local/share/Taurscribe/temp/`

**Benefit**: Each user has their own recordings, even if multiple users share the computer.

#### Step 3: Create WAV File Writer (lines 135-144)

```rust
let spec = hound::WavSpec {
    channels: config.channels,          // 1 or 2
    sample_rate: config.sample_rate.0,  // e.g., 48000
    bits_per_sample: 32,                 // 32-bit precision
    sample_format: hound::SampleFormat::Float,  // Floating-point
};

let writer = hound::WavWriter::create(&path, spec).map_err(|e| e.to_string())?;
```

**What is this?**

Think of `WavSpec` as a **recipe card** that tells the file:
- How many channels (1 = mono, 2 = stereo)
- How many samples per second (48000 = high quality)
- How precise each number is (32-bit = very precise)
- What type of numbers (Float = decimals like 0.5, -0.3)

**Why Float?**
```
Audio samples are numbers representing sound pressure:
- 0.0 = silence (neutral air pressure)
- 1.0 = loudest possible (max pressure)
- -1.0 = loudest possible (min pressure)
- 0.5 = medium loud
```

**Analogy**: Recipe card for baking = "2 cups flour, 350Â°F, 30 minutes"

#### Step 4: Create Two Channels (lines 148-155)

```rust
let (file_tx, file_rx) = unbounded::<Vec<f32>>();
let (whisper_tx, whisper_rx) = unbounded::<Vec<f32>>();

let file_tx_clone = file_tx.clone();
let whisper_tx_clone = whisper_tx.clone();
```

**Visual**:
```
                    ğŸ¤ MICROPHONE
                          â”‚
                          â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                           â”‚
            â–¼                           â–¼
    ğŸ”µ Channel 1                 ğŸŸ¢ Channel 2
    (file_tx â†’ file_rx)          (whisper_tx â†’ whisper_rx)
            â”‚                           â”‚
            â–¼                           â–¼
    Thread 1: File Writer      Thread 2: Whisper AI
    Saves every sample         Buffers & transcribes
```

**Why Clone?**
- Original `file_tx` saved in `RecordingHandle` (to drop later)
- Clone `file_tx_clone` used in audio callback
- Both point to the **same channel**, just different "handles"

**Analogy**: 
- Channel = Mail chute
- tx = Slot where you drop letters
- rx = Mailbox where letters appear
- Clone = Having two keys to the same mailbox

#### Step 5: Spawn Thread 1 - File Writer (lines 162-172)

```rust
std::thread::spawn(move || {
    let mut writer = writer;
    
    while let Ok(samples) = file_rx.recv() {
        for sample in samples {
            writer.write_sample(sample).ok();
        }
    }
    
    writer.finalize().ok();
    println!("WAV file saved.");
});
```

**Line-by-line breakdown**:

```rust
std::thread::spawn(move || {
// ^^^^^^^^^^^^^^^^^^^ Create new thread
//                 ^^^^ Take ownership (move variables into thread)
//                     ^^ This is a closure (anonymous function)

    let mut writer = writer;
    // Take ownership of 'writer' (the WAV file)
    
    while let Ok(samples) = file_rx.recv() {
    // ^^^^^^^^^^^^^^^^^^^^ Pattern matching
    //                      ^^^^^^^^^^^^^^^ Wait for audio data
    //                                       (blocks until data arrives)
        for sample in samples {
            writer.write_sample(sample).ok();
            // Write each individual sample (e.g., 0.5, -0.3, 0.1)
            // .ok() converts Result to Option (ignore errors)
        }
    }
    // When channel closes (tx dropped), recv() returns Err
    // Loop exits
    
    writer.finalize().ok();
    // Close the file, write WAV header
});
```

**What's happening?**

1. Thread sits idle, waiting for audio
2. When audio arrives on channel â†’ write to file
3. Repeat until channel closes
4. Finalize file and exit thread

**Analogy**: 
- Thread = Dedicated secretary
- Their job: "Wait for documents, file them immediately"
- When you yell "Stop!" â†’ they finish current document and go home

#### Step 6: Spawn Thread 2 - Whisper AI (lines 180-285)

```rust
let whisper = state.whisper.clone();  // Clone Arc (shared ownership)

std::thread::spawn(move || {
    let mut buffer = Vec::new();
    let chunk_size = (sample_rate * 6) as usize;  // 6 seconds of audio
    
    while let Ok(samples) = whisper_rx.recv() {
        buffer.extend(samples);  // Add new audio to buffer
        
        while buffer.len() >= chunk_size {
            let chunk: Vec<f32> = buffer.drain(..chunk_size).collect();
            // Extract 6 seconds, remove from buffer
            
            match whisper.lock().unwrap().transcribe_chunk(&chunk, sample_rate) {
                Ok(transcript) => {
                    if !transcript.is_empty() {
                        println!("[TRANSCRIPT] \"{}\"", transcript);
                    }
                }
                Err(e) => eprintln!("[ERROR] {}", e),
            }
        }
    }
});
```

**The Buffer Strategy**:

```
Audio arrives in small chunks (10ms each)
     â†“
Store in buffer
     â†“
Wait until buffer has 6 seconds
     â†“
Extract 6 seconds â†’ Send to Whisper AI
     â†“
Continue buffering...
```

**Why 6 seconds?**

| Chunk Size | Problem |
|------------|---------|
| 1 second | Too short! Cuts words mid-sentence â†’ AI hallucinates |
| 30 seconds | Too long! High latency â†’ feels laggy |
| **6 seconds** | âœ… Sweet spot: Complete sentences + real-time feel |

**Real Example**:
```
You say: "Hello, my name is John Smith"

1s chunks: "Hello my" â†’ AI: "hello? my? our evidence?" âŒ (hallucination)
6s chunks: "Hello, my name is John Smith" â†’ AI: "Hello, my name is John Smith." âœ…
```

**Draining the Buffer**:

```rust
let chunk: Vec<f32> = buffer.drain(..chunk_size).collect();
//                          ^^^^^^ Removes items from buffer while iterating
```

**Visual**:
```
Before: buffer = [1, 2, 3, 4, 5, 6, 7, 8]
        chunk_size = 6

After:  chunk = [1, 2, 3, 4, 5, 6]
        buffer = [7, 8]
        
Next audio arrives: buffer = [7, 8, 9, 10, 11, ...]
```

#### Step 7: Convert Stereo to Mono (lines 306-312)

```rust
let mono_data: Vec<f32> = if channels > 1 {
    data.chunks(channels)
        .map(|chunk| chunk.iter().sum::<f32>() / channels as f32)
        .collect()
} else {
    data.to_vec()
};
```

**Why is this critical?**

**Stereo audio format**:
```
[L1, R1, L2, R2, L3, R3, ...]
 ^   ^   ^   ^
 |   |   |   |
Left Right Left Right (alternating)
```

**If we send stereo to Whisper**:
- Whisper thinks: "Hmm, this is mono audio at 2Ã— speed"
- Result: Chipmunk voices ğŸ¿ï¸
- AI gets confused â†’ hallucinations!

**Conversion to mono**:
```
Stereo: [L1, R1, L2, R2, L3, R3]
          â†“   â†“   â†“   â†“   â†“   â†“
Mono:   [(L1+R1)/2, (L2+R2)/2, (L3+R3)/2]
```

**Code explanation**:
```rust
data.chunks(channels)  // Split into pairs: [[L1, R1], [L2, R2], ...]
    .map(|chunk| {     // For each pair:
        chunk.iter()           // Iterate over pair
            .sum::<f32>()      // Add: L1 + R1
            / channels as f32  // Divide: / 2
    })
    .collect()  // Collect into Vec
```

**Analogy**: Stereo = Two speakers. Mono = One speaker playing average of both.

#### Step 8: Build Audio Stream (lines 290-322)

```rust
let stream = device.build_input_stream(
    &config,
    move |data: &[f32], _: &_| {
        // DATA CALLBACK: Runs every ~10ms with new audio
        
        file_tx_clone.send(data.to_vec()).ok();      // To file (stereo OK)
        whisper_tx_clone.send(mono_data).ok();       // To AI (must be mono)
    },
    move |err| {
        // ERROR CALLBACK: Runs if microphone has problems
        eprintln!("Audio input error: {}", err);
    },
    None,
)?;

stream.play()?;  // â–¶ï¸ START!
```

**What's a callback?**

A **callback** is a function that gets called automatically when something happens.

**Analogy**:
- Security camera with motion detection
- You set up: "When motion detected, take a photo"
- Camera automatically calls your function when motion occurs

**Audio callback**:
```
Every 10 milliseconds:
    â†“
Microphone captures new samples
    â†“
Callback function runs
    â†“
Send to two channels
```

**Timing**:
```
Time:     0ms    10ms   20ms   30ms   40ms   ...
Event:    [ğŸ¤] â†’ [ğŸ¤] â†’ [ğŸ¤] â†’ [ğŸ¤] â†’ [ğŸ¤]
Action:   Send   Send   Send   Send   Send
          â†“      â†“      â†“      â†“      â†“
Channels: [ğŸ’¾ğŸ¤–] [ğŸ’¾ğŸ¤–] [ğŸ’¾ğŸ¤–] [ğŸ’¾ğŸ¤–] [ğŸ’¾ğŸ¤–]
```

#### Step 9: Save Recording Handle (lines 326-330)

```rust
*state.recording_handle.lock().unwrap() = Some(RecordingHandle {
    stream: SendStream(stream),
    file_tx,
    whisper_tx,
});
```

**Breaking it down**:

```rust
state.recording_handle  // Get Mutex<Option<RecordingHandle>>
    .lock()            // Lock the mutex (wait if another thread has it)
    .unwrap()          // Get MutexGuard (panic if poisoned)
                       // Now we have: &mut Option<RecordingHandle>

*                      // Dereference to get the actual Option
= Some(...)            // Set it to Some with new RecordingHandle
```

**Why save it?**

Later, when you click "Stop", we need to:
1. Stop the stream (stop mic)
2. Close the channels (signal threads to finish)

We save these in `RecordingHandle` so `stop_recording()` can access them!

**Analogy**: 
- Saving = Writing down the recipe you used
- Later when cleaning up, you know exactly what to clean

---

### ğŸ›‘ Phase 3: Stopping the Recording

**File**: `src-tauri/src/lib.rs` lines 336-369

```rust
fn stop_recording(state: State<AudioState>) -> Result<String, String> {
    let mut handle = state.recording_handle.lock().unwrap();
    
    if let Some(recording) = handle.take() {
        // Step 1: Stop everything
        drop(recording.stream);      // Stop microphone
        drop(recording.file_tx);     // Close file channel
        drop(recording.whisper_tx);  // Close whisper channel
        
        // Step 2: Wait for file to finish writing
        std::thread::sleep(std::time::Duration::from_millis(500));
        
        // Step 3: Run final high-quality transcription
        let path = state.last_recording_path.lock().unwrap().clone().unwrap();
        match state.whisper.lock().unwrap().transcribe_file(&path) {
            Ok(text) => Ok(text),  // Return transcript to frontend!
            Err(e) => Ok(format!("Recording saved, but transcription failed: {}", e))
        }
    } else {
        Err("Not recording".to_string())
    }
}
```

**What's `handle.take()`?**

```rust
// Before:
handle = Some(RecordingHandle { ... })

// After take():
let recording = handle.take();  // recording = Some(RecordingHandle { ... })
handle = None                   // Now None!
```

**Why `drop()`?**

```rust
drop(recording.stream);
// Explicitly drops (frees) the stream
// This stops the microphone callback
```

**When channels close**:
```
Main thread: drop(file_tx)
                â†“
File writer thread: file_rx.recv() returns Err
                â†“
Thread sees "channel closed"
                â†“
Exits while loop
                â†“
Finalizes file and exits
```

**Why sleep 500ms?**

```rust
std::thread::sleep(std::time::Duration::from_millis(500));
```

Give the file writer thread time to:
1. Write remaining samples
2. Finalize WAV file
3. Close file handle

**Without sleep**: We might try to transcribe before file is fully written!

**Final transcription**:
```rust
state.whisper.lock().unwrap().transcribe_file(&path)
```

This processes the **entire file at once** (not 6s chunks):
- Slower than real-time chunks
- But more accurate!
- Returns complete transcript to frontend

---

## Component Deep Dive

### Frontend: App.tsx

The frontend is simple. Let's understand each part:

#### State Management

```typescript
const [greetMsg, setGreetMsg] = useState("");
// What to display to user (status messages, transcript)

const [isRecording, setIsRecording] = useState(false);
// Is recording active? (controls button states)

const [backendInfo, setBackendInfo] = useState("Loading...");
// GPU backend info (CUDA/Vulkan/CPU)
```

**What's `useState`?**

React hook that stores state:
```typescript
const [value, setValue] = useState(initialValue);
//     ^^^^^  ^^^^^^^^
//     Current value    Function to update it
```

**Example**:
```typescript
const [count, setCount] = useState(0);

setCount(5);     // count is now 5
setCount(count + 1);  // count is now 6
```

#### Loading Backend Info (lines 12-22)

```typescript
useEffect(() => {
    async function loadBackend() {
        try {
            const backend = await invoke("get_backend_info");
            setBackendInfo(backend as string);
        } catch (e) {
            setBackendInfo("Unknown");
        }
    }
    loadBackend();
}, []);  // Empty array = run once on mount
```

**What's `useEffect`?**

Runs code when component loads:
```typescript
useEffect(() => {
    // Code runs when component mounts
}, []);  // Empty dependencies = run once
```

**This calls Rust**:
```typescript
invoke("get_backend_info")
    â†“
Calls Rust function: get_backend_info()
    â†“
Returns: "CUDA" or "Vulkan" or "CPU"
    â†“
Updates UI
```

#### Buttons (lines 41-88)

**Start Recording Button**:
```typescript
<button
    onClick={async () => {
        try {
            const res = await invoke("start_recording");
            //               ^^^^^^ Bridge to Rust
            setGreetMsg(res as string);
            setIsRecording(true);
        } catch (e) {
            setGreetMsg("Error: " + e);
        }
    }}
    disabled={isRecording}  // Disable if already recording
>
    Start Recording
</button>
```

**Stop Recording Button**:
```typescript
<button
    onClick={async () => {
        const res = await invoke("stop_recording");
        setGreetMsg(res as string);  // Display final transcript
        setIsRecording(false);
    }}
    disabled={!isRecording}  // Disable if not recording
>
    Stop Recording
</button>
```

**Benchmark Button** (for testing):
```typescript
<button
    onClick={async () => {
        const res = await invoke("benchmark_test", {
            filePath: "taurscribe-runtime/samples/otherjack.wav"
        });
        setGreetMsg(res as string);
    }}
>
    ğŸš€ Benchmark
</button>
```

**What's `invoke()`?**

Tauri's magic function that calls Rust:
```typescript
// JavaScript side:
const result = await invoke("function_name", { arg1: value1 });

// Maps to Rust side:
#[tauri::command]
fn function_name(arg1: Type) -> Result<String, String> {
    // ... Rust code ...
}
```

---

### Backend: lib.rs

We've covered the main functions. Let's look at some details we skipped:

#### The `#[tauri::command]` Attribute

```rust
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}
```

**What does `#[tauri::command]` do?**

It's a **macro** that generates code to:
1. Expose function to JavaScript
2. Handle serialization (Rust â†” JSON)
3. Add error handling

**Without macro** (what Tauri generates):
```rust
// You write this:
#[tauri::command]
fn greet(name: &str) -> String { ... }

// Tauri generates something like:
pub fn greet_handler(json_args: String) -> String {
    let name: &str = parse_json(json_args);
    let result = greet(name);
    serialize_to_json(result)
}
```

#### State Management

```rust
tauri::Builder::default()
    .manage(AudioState {
        recording_handle: Mutex::new(None),
        whisper: Arc::new(Mutex::new(whisper)),
        last_recording_path: Mutex::new(None),
    })
```

**What's `.manage()`?**

Adds shared state that all Tauri commands can access:

```rust
#[tauri::command]
fn some_command(state: State<AudioState>) -> Result<String, String> {
    // 'state' is automatically injected by Tauri
    // All commands get the SAME instance
}
```

**Analogy**:
- `.manage()` = Creating a shared whiteboard
- Every command = Different people who can access the same whiteboard
- `Mutex` = Only one person can write at a time

#### Registering Commands

```rust
.invoke_handler(tauri::generate_handler![
    greet,
    start_recording,
    stop_recording,
    get_backend_info,
    benchmark_test
])
```

**What's this?**

Tells Tauri: "These functions can be called from JavaScript"

**Without this**: JavaScript `invoke("start_recording")` wouldn't work!

---

### Whisper Manager: whisper.rs

The AI brain of the application.

#### Initialization (lines 59-99)

```rust
pub fn initialize(&mut self) -> Result<String, String> {
    // 1. Silence C++ logs
    unsafe {
        set_log_callback(Some(null_log_callback), std::ptr::null_mut());
    }
    
    // 2. Find model file
    let model_path = "taurscribe-runtime/models/ggml-tiny.en-q5_1.bin";
    let absolute_path = std::fs::canonicalize(model_path)
        .or_else(|_| std::fs::canonicalize(format!("../{}", model_path)))
        .or_else(|_| std::fs::canonicalize(format!("../../{}", model_path)))?;
    
    // 3. Try GPU, fallback to CPU
    let (ctx, backend) = self.try_gpu(&absolute_path)
        .or_else(|_| self.try_cpu(&absolute_path))?;
    
    // 4. Warm up GPU
    let warmup_audio = vec![0.0_f32; 16000];  // 1 second of silence
    self.transcribe_chunk(&warmup_audio, 16000)?;
    
    Ok(format!("Backend: {}", backend))
}
```

**Why multiple paths?**

```rust
std::fs::canonicalize(model_path)                    // Try: ./taurscribe-runtime/...
    .or_else(|_| std::fs::canonicalize(format!("../{}", model_path)))  // Try: ../taurscribe-runtime/...
    .or_else(|_| std::fs::canonicalize(format!("../../{}", model_path)))?;  // Try: ../../taurscribe-runtime/...
```

**Why?** Depending on how you run the app:
- `cargo run` from src-tauri/ â†’ needs `../`
- Run compiled .exe â†’ needs `./`
- Development vs production â†’ different paths

**What's `canonicalize`?**

Converts relative path to absolute path:
```rust
// Input: "taurscribe-runtime/models/model.bin"
// Output: "C:/Users/YOU/Desktop/Taurscribe/taurscribe-runtime/models/model.bin"
```

**Why warm up GPU?**

First GPU call is slow (compiles kernels):
```
First run:  Compile kernels (5s) + Run AI (0.5s) = 5.5s ğŸ˜¢
Subsequent: Run AI (0.5s) = 0.5s âœ…
```

Warm-up = Run once with silence during initialization, so first real transcription is fast!

#### GPU vs CPU (lines 102-164)

```rust
fn try_gpu(&self, model_path: &Path) -> Result<(WhisperContext, GpuBackend), String> {
    let mut params = WhisperContextParameters::default();
    params.use_gpu(true);
    
    match WhisperContext::new_with_params(path, params) {
        Ok(ctx) => {
            let backend = self.detect_gpu_backend();
            Ok((ctx, backend))
        }
        Err(e) => Err(format!("GPU failed: {:?}", e))
    }
}

fn detect_gpu_backend(&self) -> GpuBackend {
    if self.is_cuda_available() {
        GpuBackend::Cuda   // NVIDIA GPU
    } else {
        GpuBackend::Vulkan  // AMD/Intel GPU or universal
    }
}

fn is_cuda_available(&self) -> bool {
    std::process::Command::new("nvidia-smi")
        .output()
        .map(|output| output.status.success())
        .unwrap_or(false)
}
```

**GPU Detection Strategy**:
```
1. Try loading with GPU enabled
   â”œâ”€ Success? â†’ Detect which backend (CUDA vs Vulkan)
   â””â”€ Fail? â†’ Try CPU

2. To detect CUDA:
   â”œâ”€ Run: nvidia-smi command
   â”œâ”€ Success? â†’ NVIDIA GPU present â†’ CUDA
   â””â”€ Fail? â†’ No NVIDIA GPU â†’ Assume Vulkan
```

**Why this matters**:
- CUDA: NVIDIA GPUs (RTX 3080, etc.) - Very fast!
- Vulkan: AMD/Intel GPUs, or universal fallback - Still fast!
- CPU: No GPU - Slower, but works everywhere

**Speed comparison**:
```
CPU:    6s audio â†’ 10s processing (0.6Ã— realtime)
Vulkan: 6s audio â†’ 2s processing (3Ã— realtime)
CUDA:   6s audio â†’ 0.5s processing (12Ã— realtime)
```

#### Transcribing Chunks (lines 171-272)

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],
    input_sample_rate: u32,
) -> Result<String, String> {
    // 1. Resample to 16kHz
    let audio_data = if input_sample_rate != 16000 {
        resample_to_16khz(samples, input_sample_rate)?
    } else {
        samples.to_vec()
    };
    
    // 2. Create Whisper state
    let mut state = self.context.as_mut().unwrap().create_state()?;
    
    // 3. Configure
    let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
    params.set_language(Some("en"));
    params.set_n_threads(4);
    
    // 4. CONTEXT: Use previous transcript to improve accuracy
    if !self.last_transcript.is_empty() {
        params.set_initial_prompt(&self.last_transcript);
    }
    
    // 5. Run AI
    state.full(params, &audio_data)?;
    
    // 6. Extract text
    let mut transcript = String::new();
    for i in 0..state.full_n_segments() {
        if let Some(segment) = state.get_segment(i) {
            transcript.push_str(&segment.to_string());
        }
    }
    
    // 7. Save for next time
    let final_text = transcript.trim().to_string();
    if !final_text.is_empty() {
        self.last_transcript = final_text.clone();
    }
    
    Ok(final_text)
}
```

**Why resample to 16kHz?**

Whisper AI was trained on 16kHz audio:
```
48kHz: High quality, but wasted on speech
       (Human speech is mostly < 8kHz)
       
16kHz: Perfect for speech
       (Captures all speech frequencies)
       
8kHz:  Too low (phone quality)
```

**Resampling**:
```
Input:  48000 samples/second
Output: 16000 samples/second
Ratio:  16000/48000 = 1/3

Every 3 input samples â†’ 1 output sample (with interpolation)
```

**The Context Trick**:

```rust
if !self.last_transcript.is_empty() {
    params.set_initial_prompt(&self.last_transcript);
}
```

**Why this is genius**:

```
Without context:
Chunk 1: "Hello my name"
Chunk 2: (AI has no context) â†’ "is John? a shun? ajon?" âŒ

With context:
Chunk 1: "Hello my name"
Chunk 2: (AI knows "Hello my name" was said) â†’ "is John Smith." âœ…
```

**Analogy**: Like telling someone "Here's what we were talking about" before continuing the conversation.

---

## Common Beginner Questions

### Q1: What's the difference between `String` and `&str`?

**Answer**: Ownership!

```rust
let s1: String = String::from("hello");  // OWNED (heap-allocated)
let s2: &str = "hello";                  // BORROWED (string slice)

// String = Like owning a car
// &str = Like borrowing a car
```

**When to use**:
- Function parameters: `&str` (don't need ownership)
- Return values: `String` (caller takes ownership)
- Building strings: `String` (need mutability)

**Example**:
```rust
fn print_message(msg: &str) {  // Just reading, use &str
    println!("{}", msg);
}

fn build_message(name: &str) -> String {  // Building new string, return String
    format!("Hello, {}!", name)
}
```

### Q2: What does `unwrap()` do and why is it dangerous?

**Answer**: `unwrap()` extracts value from `Result`/`Option`, but **panics on error**.

```rust
let maybe: Option<i32> = Some(5);
let value = maybe.unwrap();  // value = 5 âœ…

let nothing: Option<i32> = None;
let value = nothing.unwrap();  // ğŸ’¥ PANIC! Program crashes!
```

**Better alternatives**:

```rust
// 1. Use ? operator (propagate error)
let value = maybe.ok_or("No value")?;

// 2. Use match (handle both cases)
match maybe {
    Some(v) => println!("Got: {}", v),
    None => println!("No value"),
}

// 3. Use if let (handle Some case only)
if let Some(v) = maybe {
    println!("Got: {}", v);
}

// 4. Provide default
let value = maybe.unwrap_or(0);  // Default to 0
```

**When `unwrap()` is OK**:
- Prototyping/examples
- You KNOW it can't fail (but use `expect()` with message)

```rust
let value = maybe.expect("This should never be None because...");
```

### Q3: What's `.ok()` doing?

**Answer**: Converts `Result` to `Option` (discards error).

```rust
let result: Result<i32, String> = Ok(5);

let option: Option<i32> = result.ok();  // Some(5)

// If error:
let result: Result<i32, String> = Err("failed".to_string());
let option: Option<i32> = result.ok();  // None (error discarded!)
```

**In Taurscribe**:
```rust
writer.write_sample(sample).ok();
//                          ^^^^ Ignore errors (just drop failed samples)
```

**Why ignore errors?**
- Dropping a few audio samples won't be noticed
- More important to keep recording than to stop on minor error
- Real errors (file full, etc.) will show up anyway

### Q4: Why `move` in closures?

**Answer**: Because closure will outlive the function.

```rust
fn example() {
    let data = vec![1, 2, 3];
    
    // WITHOUT move:
    thread::spawn(|| {
        println!("{:?}", data);  // âŒ ERROR!
        // data borrowed, but function might end before thread finishes
    });
    
    // WITH move:
    thread::spawn(move || {
        println!("{:?}", data);  // âœ… OK!
        // Thread owns data, so it's safe
    });
}
```

**Rule**: If closure goes to another thread, use `move`.

### Q5: Why do we need two passes (real-time + final)?

**Answer**: Trade-off between speed and accuracy.

**Real-time chunks (6 seconds)**:
- Fast processing (while you speak)
- Good for immediate feedback
- Less context â†’ slightly less accurate
- Shows in console for debugging

**Final transcription (whole file)**:
- Full context (all audio at once)
- More accurate
- Slower (processes after recording)
- Returned to user

**Analogy**:
- Real-time = Rough draft while writing
- Final = Edited final version

### Q6: Can I use Taurscribe for other languages?

**Yes!** Change one line in `whisper.rs`:

```rust
// English (default)
params.set_language(Some("en"));

// Spanish
params.set_language(Some("es"));

// French
params.set_language(Some("fr"));

// Japanese
params.set_language(Some("ja"));

// Auto-detect
params.set_language(None);
```

**Full list**: [Whisper supported languages](https://github.com/openai/whisper#available-models-and-languages)

### Q7: How do I make it faster?

**Options**:

1. **Use smaller model**:
```rust
// Faster but less accurate:
let model_path = "taurscribe-runtime/models/ggml-tiny.en-q5_1.bin";

// Slower but more accurate:
let model_path = "taurscribe-runtime/models/ggml-large-v3.bin";
```

2. **Enable GPU** (already done!):
- Ensure CUDA/Vulkan drivers installed
- Check `get_backend_info` shows GPU

3. **Reduce chunk size**:
```rust
let chunk_size = (sample_rate * 3) as usize;  // 3s instead of 6s
// Faster response, but might cut sentences
```

4. **Increase threads**:
```rust
params.set_n_threads(8);  // Use more CPU cores
```

### Q8: What if recording crashes?

**Safety features**:

1. **File still saved**: WAV writer in separate thread finalizes even if main crashes
2. **Location known**: AppData directory (recoverable)
3. **Partial transcripts**: Console shows real-time output (check logs)

**Recovery**:
```rust
// Find recordings at:
// Windows: C:\Users\YOU\AppData\Local\Taurscribe\temp\
// Look for: recording_*.wav files
```

### Q9: How much RAM does this use?

**Rough breakdown**:

| Component | RAM Usage |
|-----------|-----------|
| Whisper model (tiny) | ~100 MB |
| Whisper model (base) | ~200 MB |
| Whisper model (large) | ~3 GB |
| Audio buffer (6s) | ~1 MB |
| Total app overhead | ~50 MB |

**For 5-minute recording**:
```
Audio: 48000 samples/s Ã— 2 channels Ã— 4 bytes Ã— 300s = ~115 MB
Model: ~100-3000 MB (depends on model)
Total: ~215 MB - 3.1 GB
```

### Q10: Can I save transcripts to file?

**Yes! Add this function**:

```rust
#[tauri::command]
fn save_transcript(text: String, filename: String) -> Result<String, String> {
    let recordings_dir = get_recordings_dir()?;
    let path = recordings_dir.join(filename);
    
    std::fs::write(&path, text)
        .map_err(|e| format!("Failed to save: {}", e))?;
    
    Ok(format!("Saved to: {}", path.display()))
}
```

**Call from frontend**:
```typescript
const transcript = await invoke("stop_recording");
await invoke("save_transcript", {
    text: transcript,
    filename: "my_transcript.txt"
});
```

---

## Conclusion

Taurscribe demonstrates key Rust concepts:

âœ… **Ownership** - Threads take ownership of data they need  
âœ… **Borrowing** - Functions borrow without taking ownership  
âœ… **Concurrency** - Multiple threads work safely in parallel  
âœ… **Error Handling** - `Result` and `?` operator for safety  
âœ… **Type Safety** - Compiler prevents bugs at compile-time  

**Architecture Benefits**:

| Feature | Benefit |
|---------|---------|
| Separate threads | UI never freezes |
| Channels | Safe communication |
| Arc<Mutex<T>> | Shared state protection |
| Real-time + final | Speed + accuracy |
| GPU acceleration | 12Ã— faster processing |

**Key Takeaway for Beginners**:

Rust might feel strict at first, but it prevents entire categories of bugs:
- No data races
- No use-after-free
- No null pointer crashes
- No memory leaks

Once your Rust code compiles, it usually works correctly!

---

## Next Steps

**To learn more Rust**:
1. [The Rust Book](https://doc.rust-lang.org/book/) - Official, comprehensive
2. [Rust By Example](https://doc.rust-lang.org/rust-by-example/) - Learn by doing
3. [Rustlings](https://github.com/rust-lang/rustlings) - Interactive exercises

**To extend Taurscribe**:
1. Add model selector in UI
2. Save transcripts to files automatically
3. Add keyboard shortcuts (Space to record)
4. Implement Voice Activity Detection (skip silence)
5. Add real-time text display (not just console)

**Questions?** Review this guide, check code comments, or explore the Rust documentation!

---

## Cumulative Context Feature

### What Changed

Taurscribe now uses **cumulative context** instead of **last-chunk-only context** for better transcription accuracy.

### Before vs After

#### âŒ Before (Last Chunk Only)

```rust
// Only the most recent chunk was saved
if !final_text.is_empty() {
    self.last_transcript = final_text.clone();  // Overwrites!
}
```

**Example**:
```
Chunk 1: "Hello my name is"
    â†’ Context saved: "Hello my name is"

Chunk 2: "John Smith and I"
    â†’ Context saved: "John Smith and I"  (chunk 1 lost!)

Chunk 3: "work at Microsoft"
    â†’ Context saved: "work at Microsoft"  (chunks 1-2 lost!)
```

**Problem**: Each chunk only knows about the immediately previous chunk.

#### âœ… After (Cumulative Context)

```rust
// Append each chunk to build full transcript
if !final_text.is_empty() {
    if !self.last_transcript.is_empty() {
        self.last_transcript.push(' ');  // Add space
    }
    self.last_transcript.push_str(&final_text);  // Append!
}
```

**Example**:
```
Chunk 1: "Hello my name is"
    â†’ Context saved: "Hello my name is"

Chunk 2: "John Smith and I"
    â†’ Context saved: "Hello my name is John Smith and I"

Chunk 3: "work at Microsoft"
    â†’ Context saved: "Hello my name is John Smith and I work at Microsoft"
```

**Benefit**: Each chunk knows the **entire conversation** so far!

### Visual Comparison

**Old Approach (Last Chunk Only)**:
```
Time:     0sâ”€â”€â”€â”€6sâ”€â”€â”€â”€12sâ”€â”€â”€18sâ”€â”€â”€24s
          â”‚     â”‚     â”‚     â”‚     â”‚
Chunks:   [  1  ][  2  ][  3  ][  4  ]
          â”‚     â”‚     â”‚     â”‚     â”‚
Context:  None  "1"   "2"   "3"   "4"
                 â†‘     â†‘     â†‘     â†‘
                 â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                 Only previous chunk
```

**New Approach (Cumulative)**:
```
Time:     0sâ”€â”€â”€â”€6sâ”€â”€â”€â”€12sâ”€â”€â”€18sâ”€â”€â”€24s
          â”‚     â”‚     â”‚     â”‚     â”‚
Chunks:   [  1  ][  2  ][  3  ][  4  ]
          â”‚     â”‚     â”‚     â”‚     â”‚
Context:  None  "1"   "1 2" "1 2 3" "1 2 3 4"
                 â†‘     â†‘     â†‘     â†‘
                 â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                 All previous chunks!
```

### Code Changes Made

**1. Modified `transcribe_chunk()` in `whisper.rs`** (lines 252-261):

```rust
let final_text = transcript.trim().to_string();

// Update history for next time (CUMULATIVE: append all chunks)
if !final_text.is_empty() {
    // Append new chunk to existing transcript
    if !self.last_transcript.is_empty() {
        self.last_transcript.push(' ');  // Add space between chunks
    }
    self.last_transcript.push_str(&final_text);
}
```

**2. Added `clear_context()` method in `whisper.rs`**:

```rust
/// Clear the transcript history (call when starting a new recording)
pub fn clear_context(&mut self) {
    self.last_transcript.clear();
    println!("[INFO] Context cleared - starting fresh");
}
```

**3. Clear context on new recording in `lib.rs`**:

```rust
// Clear previous transcript context (start fresh for new recording)
state.whisper.lock().unwrap().clear_context();
```

### Benefits of Cumulative Context

**1. Better Long-Form Accuracy**

Old (Last Chunk Only):
```
You: "My name is John Smith. I graduated from MIT in 2020. I now work at Microsoft."

Chunk 1: "My name is John Smith"           âœ…
Chunk 2: "I graduated from MIT"            âœ…
Chunk 3: "in 2020? 2020s? twenty twenty?" âŒ (no context about MIT/graduation)
Chunk 4: "I work at? Microsoft?"           âŒ (no context about career)
```

New (Cumulative):
```
You: "My name is John Smith. I graduated from MIT in 2020. I now work at Microsoft."

Chunk 1: "My name is John Smith"                    âœ…
Chunk 2: (knows "My name is John Smith")
         â†’ "I graduated from MIT"                   âœ…
Chunk 3: (knows "My name is John Smith I graduated from MIT")
         â†’ "in 2020"                                âœ… (understands graduation context!)
Chunk 4: (knows full story)
         â†’ "I now work at Microsoft"                âœ… (understands career progression!)
```

**2. Better Pronoun Resolution**

Old:
```
You: "John went to the store. He bought milk. It was expensive."

Chunk 1: "John went to the store"
Chunk 2: "He bought milk"          (who is "he"? might guess wrong)
Chunk 3: "It was expensive"        (what is "it"? no idea!)
```

New:
```
You: "John went to the store. He bought milk. It was expensive."

Chunk 1: "John went to the store"
Chunk 2: (knows "John went to the store")
         â†’ "He bought milk"        (knows "he" = John!)
Chunk 3: (knows "John went to the store He bought milk")
         â†’ "It was expensive"      (knows "it" = milk!)
```

**3. Better Topic Continuity**

Old:
```
You: "Let's discuss quantum computing. The qubits are fascinating. Their superposition allows..."

Chunk 1: "Let's discuss quantum computing"
Chunk 2: "The qubits are fascinating"      (might mishear as "cubits", "Q bits")
Chunk 3: "Their superposition allows"      (what's "their"? confused!)
```

New:
```
You: "Let's discuss quantum computing. The qubits are fascinating. Their superposition allows..."

Chunk 1: "Let's discuss quantum computing"
Chunk 2: (knows we're talking about quantum computing)
         â†’ "The qubits are fascinating"    (correctly identifies "qubits"!)
Chunk 3: (knows full quantum computing context)
         â†’ "Their superposition allows"    (knows "their" = qubits!)
```

### Potential Concerns Addressed

**Concern 1: Memory Usage**

Won't this use too much memory for long recordings?

**Answer**: Not really!

```
1 hour recording = ~600 chunks (6s each)
Average chunk = ~30 words
Total words = 600 Ã— 30 = 18,000 words
Memory = ~18,000 Ã— 5 bytes = 90 KB

Even 10 hours = 900 KB (less than 1 MB!)
```

**Text is cheap!** The audio buffer uses way more memory than the text.

**Concern 2: Whisper Context Limit**

Doesn't Whisper have a context limit?

**Answer**: Yes, but it's handled automatically!

Whisper's `set_initial_prompt()` has a limit (~224 tokens â‰ˆ 150-200 words). If you exceed it:
- Whisper automatically truncates to the most recent text
- Still better than having no context!

**In practice**:
- First few chunks: Full cumulative context
- After ~10-15 chunks: Whisper uses last ~200 words
- Still maintains topic continuity

**Concern 3: Performance**

Does more context slow down transcription?

**Answer**: Negligible impact!

```
Processing time:
- Audio encoding: 95% of time
- Context processing: ~5% of time

With more context:
- Context processing: ~6% of time
- Total impact: +1% slower (barely noticeable!)
```

**Benefit far outweighs cost!**

### Testing the Changes

**Test 1: Short Recording**

```
Say: "Hello my name is John"

Expected output:
[TRANSCRIPT] "Hello my name is John"
```

**Test 2: Multi-Chunk Recording**

```
Say: "Hello my name is John Smith. I work at Microsoft. I love programming."

Expected console output:
[TRANSCRIPT] "Hello my name is John Smith"
[TRANSCRIPT] "I work at Microsoft"
[TRANSCRIPT] "I love programming"

Expected final transcript:
"Hello my name is John Smith I work at Microsoft I love programming"
```

**Test 3: Multiple Recordings**

```
Recording 1: "This is recording one"
Stop
Recording 2: "This is recording two"

Expected:
- Recording 1 context should NOT affect Recording 2
- Each recording starts fresh
```

### How to Verify It's Working

**1. Check Console Logs**

When you start recording:
```
[INFO] Context cleared - starting fresh
```

**2. Check Transcription Quality**

Try saying:
```
"My name is John. I went to the store. It was closed. So I went home."
```

**With cumulative context**, the AI should:
- Know "I" refers to John
- Know "It" refers to the store
- Maintain narrative coherence

### Advanced: Limiting Context Size (Optional)

If you want to limit context to prevent it from growing too large:

```rust
// In whisper.rs, modify the append logic:
if !final_text.is_empty() {
    if !self.last_transcript.is_empty() {
        self.last_transcript.push(' ');
    }
    self.last_transcript.push_str(&final_text);
    
    // OPTIONAL: Limit to last 500 words
    let words: Vec<&str> = self.last_transcript.split_whitespace().collect();
    if words.len() > 500 {
        // Keep only last 500 words
        self.last_transcript = words[words.len() - 500..].join(" ");
        println!("[INFO] Context trimmed to last 500 words");
    }
}
```

**When to use this**:
- Very long recordings (hours)
- Memory-constrained systems
- Want to focus on recent context only

### Summary

**What Changed**:
âœ… Context now accumulates across all chunks  
âœ… Each chunk knows the entire conversation  
âœ… Context clears when starting new recording  

**Benefits**:
âœ… Better long-form accuracy  
âœ… Better pronoun resolution  
âœ… Better topic continuity  
âœ… More coherent transcriptions  

**Trade-offs**:
âš ï¸ Slightly more memory (negligible)  
âš ï¸ Whisper auto-truncates if too long (handled automatically)  

**Result**: ğŸ¯ **Much better transcription quality for longer recordings!**

---

## Annotated Rust Code Examples

This section shows actual code from Taurscribe with detailed annotations explaining each Rust concept.

### Example 1: Struct Definition with Generics

**File**: `lib.rs` lines 16-20

```rust
struct AudioState {
    recording_handle: Mutex<Option<RecordingHandle>>,
    //                ^^^^^ Mutex = Thread-safe lock
    //                      ^^^^^^ Option = Can be Some or None
    //                             ^^^^^^^^^^^^^^^^ The type inside Option
    
    whisper: Arc<Mutex<WhisperManager>>,
    //       ^^^ Arc = Shared ownership across threads
    //            ^^^^^ Mutex = Only one thread can access at a time
    //                  ^^^^^^^^^^^^^^ The actual data type
    
    last_recording_path: Mutex<Option<String>>,
    //                   ^^^^^ Same pattern: Mutex protects Option<String>
}
```

**What this means:**
- `Mutex` = "Only one thread can read/write this at a time"
- `Option<T>` = "Maybe there's a value, maybe not"
- `Arc` = "Multiple threads can share ownership of this"

### Example 2: Error Handling with Result

**File**: `lib.rs` lines 114-120

```rust
fn start_recording(state: State<AudioState>) -> Result<String, String> {
//                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//                                              Return type: Either Ok(String) or Err(String)

    let host = cpal::default_host();
    let device = host.default_input_device().ok_or("No input device")?;
    //                                          ^^^^^^^^^^^^^^^^^^^^^^^^
    //                                          ok_or() converts Option to Result
    //                                          ? operator: if Err, return early
    
    let config: cpal::StreamConfig = device
        .default_input_config()
        .map_err(|e| e.to_string())?  // Convert error type, then propagate
        .into();                        // Convert to StreamConfig
```

**The `?` operator explained:**
```rust
// This:
let device = host.default_input_device().ok_or("No input device")?;

// Is equivalent to:
let device = match host.default_input_device().ok_or("No input device") {
    Ok(value) => value,
    Err(e) => return Err(e),  // Exit function early with error
};
```

### Example 3: Pattern Matching with if let

**File**: `lib.rs` lines 338-342

```rust
let mut handle = state.recording_handle.lock().unwrap();
//              ^^^ mut = we can modify 'handle'
//                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Lock the mutex, unwrap the Result

if let Some(recording) = handle.take() {
// ^^^^^ Pattern matching: "if handle.take() is Some(value)"
//                        bind that value to 'recording'
    drop(recording.stream);  // Explicitly drop (free) the stream
    drop(recording.file_tx); // Close the channel
    drop(recording.whisper_tx);
} else {
    // handle.take() returned None (no recording was active)
    Err("Not recording".to_string())
}
```

**Alternative ways to write this:**
```rust
// Method 1: if let (what you have)
if let Some(recording) = handle.take() {
    // use recording
}

// Method 2: match (more explicit)
match handle.take() {
    Some(recording) => {
        // use recording
    }
    None => {
        // handle None
    }
}

// Method 3: unwrap_or_else (if you want a default)
let recording = handle.take().unwrap_or_else(|| {
    return Err("Not recording".to_string());
});
```

### Example 4: Closures and Move Semantics

**File**: `lib.rs` lines 295-315

```rust
move |data: &[f32], _: &_| {
// ^^^^ 'move' keyword: take ownership of captured variables
//      This closure will run in a different thread, so we need to move data

    // 'data' is a borrowed slice - we can read it but don't own it
    file_tx_clone.send(data.to_vec()).ok();
    //                    ^^^^^^^^ Create owned Vec from borrowed slice
    //                            This is necessary because send() needs ownership

    // Convert stereo to mono if needed
    let mono_data: Vec<f32> = if channels > 1 {
    //                        ^^^^^^^^^^^^^^ 'channels' was captured from outside
        data.chunks(channels)  // Split into chunks of size 'channels'
            .map(|chunk| chunk.iter().sum::<f32>() / channels as f32)
            //   ^^^^^^ Another closure! This one captures 'channels'
            //          .map() transforms each chunk
            .collect()  // Collect iterator into Vec
    } else {
        data.to_vec()  // Already mono, just convert to Vec
    };

    whisper_tx_clone.send(mono_data).ok();
    //                    ^^^^^^^^^^ Send the mono audio
}
```

**Why `move`?**
```rust
// Without 'move', the closure borrows variables:
let closure = || {
    println!("{}", variable);  // Borrows 'variable'
};

// With 'move', the closure takes ownership:
let closure = move || {
    println!("{}", variable);  // Takes ownership of 'variable'
    // After this, 'variable' can't be used in the original scope!
};
```

### Example 5: Thread Spawning and Channels

**File**: `lib.rs` lines 148-172

```rust
// Create a channel (thread-safe queue)
let (file_tx, file_rx) = unbounded::<Vec<f32>>();
//  ^^^^^^^^  ^^^^^^^^
//  Sender    Receiver
//  (tx = transmit, rx = receive)

// Clone the sender (you can have multiple senders, but only one receiver)
let file_tx_clone = file_tx.clone();

// Spawn a new thread
std::thread::spawn(move || {
//              ^^^^ Spawn = create new thread
//                   move = take ownership of captured variables
    
    let mut writer = writer;  // 'writer' is moved into this thread
    
    // Receive data from the channel
    while let Ok(samples) = file_rx.recv() {
    //                    ^^^^^^^^^^^^^^^^ Receive from channel
    //                                     Blocks until data arrives
    //                                     Returns Result: Ok(data) or Err(disconnected)
        for sample in samples {
            writer.write_sample(sample).ok();
        }
    }
    // When file_tx is dropped (closed), recv() will return Err
    // and the loop exits
    
    writer.finalize().ok();
    println!("WAV file saved.");
});
```

**Channel behavior:**
- `send()` - Non-blocking, returns `Result`
- `recv()` - Blocks until data arrives or channel closes
- When all senders are dropped, receiver gets `Err`

### Example 6: Arc and Shared Ownership

**File**: `lib.rs` lines 174-175, 211-214

```rust
// Clone the Arc (not the data!)
let whisper = state.whisper.clone();
//            ^^^^^^^^^^^^^^^^^^^^^^
//            This creates a NEW Arc pointing to the SAME data
//            Both Arcs share ownership

std::thread::spawn(move || {
    // Later in the thread:
    match whisper
        .lock()      // Lock the Mutex (blocks if another thread has it)
        .unwrap()    // Unwrap the Result (panic if lock fails - shouldn't happen)
        .transcribe_chunk(&chunk, sample_rate)  // Call method on WhisperManager
    {
        Ok(transcript) => { /* ... */ }
        Err(e) => { /* ... */ }
    }
});
```

**Arc vs Rc:**
```rust
use std::sync::Arc;  // Thread-safe
use std::rc::Rc;     // Single-threaded only

let data = Arc::new(Mutex::new(5));  // Can share across threads
let data2 = Rc::new(5);               // Only single thread!
```

### Example 7: Enum and Pattern Matching

**File**: `whisper.rs` lines 14-29

```rust
#[derive(Debug, Clone)]
// ^^^^^^^^^^^^^^^^^^^^ Derive macros: automatically generate code
//                      Debug = can print with {:?}
//                      Clone = can clone the enum

pub enum GpuBackend {
    Cuda,    // Variant 1
    Vulkan,  // Variant 2
    Cpu,     // Variant 3
}

// Implement Display trait (allows formatting as string)
impl std::fmt::Display for GpuBackend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {  // Exhaustive matching - must handle all cases!
            GpuBackend::Cuda => write!(f, "CUDA"),
            GpuBackend::Vulkan => write!(f, "Vulkan"),
            GpuBackend::Cpu => write!(f, "CPU"),
        }
    }
}
```

**Using the enum:**
```rust
let backend = GpuBackend::Cpu;  // Create enum value
println!("{}", backend);         // Uses Display::fmt â†’ prints "CPU"

// Pattern matching
match backend {
    GpuBackend::Cuda => println!("NVIDIA GPU"),
    GpuBackend::Vulkan => println!("AMD/Intel GPU"),
    GpuBackend::Cpu => println!("CPU only"),
}
```

### Example 8: String vs &str

**File**: `lib.rs` lines 29-31

```rust
fn greet(name: &str) -> String {
//        ^^^^ Borrowed string slice (doesn't own the string)
//                    ^^^^^^ Returns owned String
    format!("Hello, {}! You've been greeted from Rust!", name)
    //       ^^^^^^ format! macro creates a new String
}
```

**String conversions:**
```rust
let s: &str = "hello";           // String literal (borrowed)
let s2: String = s.to_string();  // Convert to owned String
let s3: String = String::from(s); // Same as above
let s4: &str = &s2;              // Borrow String as &str

// In function calls:
fn takes_string(s: String) { }      // Takes ownership
fn takes_str(s: &str) { }           // Borrows (preferred for parameters)

takes_string(s2.clone());  // Clone if you need to keep s2
takes_str(&s2);            // Borrow (doesn't take ownership)
```

### Example 9: Iterator Methods

**File**: `lib.rs` lines 306-309

```rust
let mono_data: Vec<f32> = if channels > 1 {
    data.chunks(channels)           // Create iterator over chunks
        .map(|chunk| {               // Transform each chunk
            chunk.iter()              // Create iterator over chunk elements
                .sum::<f32>()        // Sum all elements (returns f32)
                / channels as f32    // Divide by channel count
        })
        .collect()                    // Collect iterator into Vec
} else {
    data.to_vec()                    // Convert slice to Vec
};
```

**Common iterator methods:**
```rust
vec.iter()           // Iterator over references
vec.iter_mut()       // Iterator over mutable references
vec.into_iter()      // Iterator that takes ownership

.map(|x| x * 2)      // Transform each element
.filter(|x| x > 5)   // Keep only elements matching condition
.collect()           // Collect into collection (Vec, etc.)
.sum()               // Sum all elements
.count()             // Count elements
```

### Example 10: Error Handling Chain

**File**: `whisper.rs` lines 68-71

```rust
let absolute_path = std::fs::canonicalize(model_path)
    .or_else(|_| std::fs::canonicalize(format!("../{}", model_path)))
    //         ^^^^^^ If first fails, try this
    .or_else(|_| std::fs::canonicalize(format!("../../{}", model_path)))
    //         ^^^^^^ If that fails, try this
    .map_err(|e| format!("Could not find model at '{}'. Error: {}", model_path, e))?;
    //        ^^^^^^ Convert error type to String
    //                                                                    ^^ Propagate error
```

**Error handling methods:**
```rust
result.ok()                    // Result â†’ Option (discard error)
result.ok_or("error")          // Option â†’ Result
result.map_err(|e| format!("{}", e))  // Transform error type
result.or_else(|e| try_again())       // If error, try alternative
result.unwrap()                // Panic if Err (don't use in production!)
result.unwrap_or(default)      // Use default if Err
result?                        // Propagate error (return early if Err)
```

### Example 11: Unsafe Code (Advanced)

**File**: `lib.rs` lines 9-14

```rust
// Wrapper to make cpal::Stream Send/Sync.
// Safety: We only use this to keep the stream alive and drop it.
#[allow(dead_code)]
struct SendStream(cpal::Stream);
unsafe impl Send for SendStream {}
unsafe impl Sync for SendStream {}
```

**What's happening:**
- `cpal::Stream` is NOT `Send`/`Sync` (can't be shared across threads)
- But we know it's safe in our use case (we only drop it)
- `unsafe impl` tells Rust: "Trust me, this is safe"

**âš ï¸ Warning**: Only use `unsafe` when you're absolutely sure it's safe!

### Example 12: Method Chaining

**File**: `lib.rs` lines 386-401

```rust
tauri::Builder::default()
    .plugin(tauri_plugin_opener::init())  // Add plugin
    .manage(AudioState {                  // Add shared state
        recording_handle: Mutex::new(None),
        whisper: Arc::new(Mutex::new(whisper)),
        last_recording_path: Mutex::new(None),
    })
    .invoke_handler(tauri::generate_handler![  // Register commands
        greet,
        start_recording,
        stop_recording,
        get_backend_info,
        benchmark_test
    ])
    .run(tauri::generate_context!())  // Start the app
    .expect("error while running tauri application");
    // ^^^^^^ Unwrap Result, panic with message if Err
```

**Builder pattern**: Each method returns `Self`, allowing chaining.

### Quick Reference Table

| Concept | Syntax | Example |
|---------|--------|---------|
| Variable | `let x = 5;` | `let name = "Rust";` |
| Mutable | `let mut x = 5;` | `let mut counter = 0;` |
| Reference | `&x` | `let ref = &value;` |
| Mutable ref | `&mut x` | `let mut_ref = &mut value;` |
| Option | `Option<T>` | `Some(5)` or `None` |
| Result | `Result<T, E>` | `Ok(5)` or `Err("error")` |
| Match | `match x { ... }` | Pattern matching |
| If let | `if let Some(x) = opt { }` | Pattern matching shortcut |
| Unwrap | `x.unwrap()` | Get value or panic |
| Question mark | `x?` | Propagate error |
| Clone | `x.clone()` | Deep copy |
| Move | `move \|\| { }` | Take ownership in closure |

---

## Model Selection Feature

Taurscribe allows you to choose which Whisper AI model to use for transcription. Different models offer trade-offs between **speed** and **accuracy**.

### ğŸ¯ Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MODEL SELECTION ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   ğŸ“‚ taurscribe-runtime/models/                                     â”‚
â”‚      â”‚                                                               â”‚
â”‚      â”œâ”€â”€ ggml-tiny.en-q5_1.bin    (30 MB)   âš¡ Fastest              â”‚
â”‚      â”œâ”€â”€ ggml-base.en-q5_0.bin    (53 MB)                           â”‚
â”‚      â”œâ”€â”€ ggml-tiny.en.bin         (74 MB)                           â”‚
â”‚      â”œâ”€â”€ ggml-base.en.bin         (141 MB)                          â”‚
â”‚      â”œâ”€â”€ ggml-small.en.bin        (465 MB)                          â”‚
â”‚      â”œâ”€â”€ ggml-large-v3-turbo.bin  (547 MB)                          â”‚
â”‚      â””â”€â”€ ggml-large-v3.bin        (2.9 GB)  ğŸ¯ Most Accurate        â”‚
â”‚                                                                      â”‚
â”‚   ğŸ”„ Frontend (App.tsx)                                             â”‚
â”‚      â”‚                                                               â”‚
â”‚      â””â”€â”€â–º invoke("list_models")  â”€â”€â–º Returns ModelInfo[]            â”‚
â”‚      â””â”€â”€â–º invoke("switch_model") â”€â”€â–º Reloads Whisper context        â”‚
â”‚                                                                      â”‚
â”‚   ğŸ¦€ Backend (lib.rs + whisper.rs)                                  â”‚
â”‚      â”‚                                                               â”‚
â”‚      â””â”€â”€â–º WhisperManager.initialize(model_id)                       â”‚
â”‚      â””â”€â”€â–º WhisperManager.list_available_models()                    â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“Š Available Models

| Model | Size | Speed | Accuracy | Best For |
|-------|------|-------|----------|----------|
| **Tiny (Q5_1)** | ~30 MB | âš¡âš¡âš¡âš¡âš¡ | â­â­ | Quick notes, testing |
| **Base (Q5_0)** | ~53 MB | âš¡âš¡âš¡âš¡ | â­â­â­ | **Default - Good balance** |
| **Small** | ~465 MB | âš¡âš¡âš¡ | â­â­â­â­ | Meetings, lectures |
| **Large V3 Turbo** | ~547 MB | âš¡âš¡ | â­â­â­â­â­ | Professional use |
| **Large V3** | ~2.9 GB | âš¡ | â­â­â­â­â­ | Maximum accuracy |

**Note**: Quantized models (Q5_0, Q5_1) are smaller and faster with minimal accuracy loss.

### ğŸ¦€ Backend Implementation

#### The ModelInfo Struct

**File**: `src-tauri/src/whisper.rs`

```rust
/// Available Whisper models with their display names and file paths
#[derive(Debug, Clone, serde::Serialize)]
pub struct ModelInfo {
    pub id: String,           // e.g., "tiny.en-q5_1"
    pub display_name: String, // e.g., "Tiny English (Q5_1)"
    pub file_name: String,    // e.g., "ggml-tiny.en-q5_1.bin"
    pub size_mb: f32,         // Size in megabytes
}
```

**Why `serde::Serialize`?**
- Tauri needs to send this data from Rust â†’ JavaScript
- `Serialize` allows automatic conversion to JSON
- Without it, Tauri commands would fail with "IpcResponse not satisfied"

#### Listing Available Models

```rust
/// List all available Whisper models
pub fn list_available_models() -> Result<Vec<ModelInfo>, String> {
    let models_dir = Self::get_models_dir()?;
    let mut models = Vec::new();

    // Read directory entries
    let entries = std::fs::read_dir(&models_dir)
        .map_err(|e| format!("Failed to read models directory: {}", e))?;

    for entry in entries {
        let path = entry?.path();
        
        if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
            // Filter: Only Whisper models (not Silero VAD, etc.)
            if file_name.starts_with("ggml-") 
                && file_name.ends_with(".bin") 
                && !file_name.contains("silero") 
            {
                // Parse model info from filename
                let id = file_name
                    .trim_start_matches("ggml-")
                    .trim_end_matches(".bin")
                    .to_string();
                
                let size_mb = path.metadata()
                    .map(|m| m.len() as f32 / (1024.0 * 1024.0))
                    .unwrap_or(0.0);
                
                models.push(ModelInfo {
                    id: id.clone(),
                    display_name: Self::format_model_name(&id),
                    file_name: file_name.to_string(),
                    size_mb,
                });
            }
        }
    }

    // Sort by size (smallest first for UI)
    models.sort_by(|a, b| a.size_mb.partial_cmp(&b.size_mb).unwrap());

    Ok(models)
}
```

**Key Points**:
- Scans the `taurscribe-runtime/models/` directory
- Filters out non-Whisper files (like Silero VAD)
- Extracts file size for display
- Sorts by size so fastest models appear first

#### Switching Models

**File**: `src-tauri/src/lib.rs`

```rust
/// Switch to a different Whisper model
#[tauri::command]
fn switch_model(state: State<AudioState>, model_id: String) -> Result<String, String> {
    // Safety check: Can't switch while recording!
    let handle = state.recording_handle.lock().unwrap();
    if handle.is_some() {
        return Err("Cannot switch models while recording".to_string());
    }
    drop(handle); // Release lock early (important!)
    
    println!("[INFO] Switching to model: {}", model_id);
    
    // Re-initialize Whisper with new model
    let mut whisper = state.whisper.lock().unwrap();
    whisper.initialize(Some(&model_id))
}
```

**Why `drop(handle)` early?**
- We locked `recording_handle` to check if recording
- We need to release it BEFORE locking `whisper`
- Holding multiple locks increases deadlock risk
- `drop()` explicitly releases the lock

#### Modified Initialize Function

```rust
/// Initialize the Whisper context with a specific model
/// If model_id is None, uses the default model (tiny.en-q5_1)
pub fn initialize(&mut self, model_id: Option<&str>) -> Result<String, String> {
    // Get models directory
    let models_dir = Self::get_models_dir()?;
    
    // Determine which model to load (default: tiny.en-q5_1)
    let target_model = model_id.unwrap_or("tiny.en-q5_1");
    let file_name = format!("ggml-{}.bin", target_model);
    let absolute_path = models_dir.join(&file_name);
    
    if !absolute_path.exists() {
        return Err(format!("Model file not found: {}", absolute_path.display()));
    }

    // ... GPU initialization code ...
    
    // Store which model is loaded
    self.current_model = Some(target_model.to_string());
    
    Ok(format!("Backend: {}", backend))
}
```

### âš›ï¸ Frontend Implementation

#### TypeScript Interface

**File**: `src/App.tsx`

```typescript
// TypeScript interface matches Rust's ModelInfo struct
interface ModelInfo {
  id: string;           // e.g., "tiny.en-q5_1"
  display_name: string; // e.g., "Tiny English (Q5_1)"
  file_name: string;    // e.g., "ggml-tiny.en-q5_1.bin"
  size_mb: number;      // Size in megabytes
}
```

**Why define this interface?**
- TypeScript provides type safety
- Autocomplete when accessing properties
- Catches typos at compile time, not runtime

#### Loading Models on Mount

```typescript
useEffect(() => {
  async function loadInitialData() {
    try {
      // Load available models from Rust backend
      const modelList = await invoke("list_models");
      setModels(modelList as ModelInfo[]);

      // Load currently active model
      const current = await invoke("get_current_model");
      setCurrentModel(current as string | null);
    } catch (e) {
      console.error("Failed to load models:", e);
    }
  }
  loadInitialData();
}, []); // Empty dependency array = run once on mount
```

**What's `useEffect`?**
- React Hook for side effects (API calls, subscriptions)
- Runs after component renders
- Empty `[]` means "run only once when component mounts"

#### Model Change Handler

```typescript
const handleModelChange = async (modelId: string) => {
  if (modelId === currentModel) return; // No-op if same model
  
  setIsLoading(true);  // Show loading spinner
  setLoadingMessage(`Loading ${models.find(m => m.id === modelId)?.display_name}...`);

  try {
    // Call Rust backend to switch models
    const result = await invoke("switch_model", { modelId });
    setCurrentModel(modelId);
    setGreetMsg(`âœ… ${result}`);
  } catch (e) {
    setGreetMsg(`âŒ Error switching model: ${e}`);
  } finally {
    setIsLoading(false);  // Always hide spinner
  }
};
```

**What's `finally`?**
- Runs whether `try` succeeds or `catch` handles error
- Perfect for cleanup (hiding spinners, resetting state)

#### The Dropdown UI

```tsx
<select
  id="model-select"
  className="model-select"
  value={currentModel || ""}           // Controlled component
  onChange={(e) => handleModelChange(e.target.value)}
  disabled={isRecording || isLoading}  // Prevent switching during recording
>
  {models.map((model) => (
    <option key={model.id} value={model.id}>
      {model.display_name} ({formatSize(model.size_mb)})
    </option>
  ))}
</select>
```

**Key Concepts**:
- **Controlled Component**: React controls the value (not the DOM)
- **`key` prop**: React needs unique keys to track list items
- **Disabled states**: Prevents bugs from switching mid-recording

### ğŸ”„ Data Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       USER CHANGES MODEL                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  1ï¸âƒ£ User selects "Large V3" from dropdown                          â”‚
â”‚         â”‚                                                            â”‚
â”‚         â–¼                                                            â”‚
â”‚  2ï¸âƒ£ onChange fires â†’ handleModelChange("large-v3")                 â”‚
â”‚         â”‚                                                            â”‚
â”‚         â–¼                                                            â”‚
â”‚  3ï¸âƒ£ invoke("switch_model", { modelId: "large-v3" })                â”‚
â”‚         â”‚                                                            â”‚
â”‚         â–¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tauri IPC Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚                                                                      â”‚
â”‚  4ï¸âƒ£ Rust: switch_model() checks if recording                       â”‚
â”‚         â”‚                                                            â”‚
â”‚         â”œâ”€â”€ If recording â†’ Return Err("Cannot switch...")
â”‚         â”‚                                                            â”‚
â”‚         â””â”€â”€ If not â†’ Continue                                        â”‚
â”‚                 â”‚                                                    â”‚
â”‚                 â–¼                                                    â”‚
â”‚  5ï¸âƒ£ whisper.initialize(Some("large-v3"))                           â”‚
â”‚         â”‚                                                            â”‚
â”‚         â”œâ”€â”€ Load ggml-large-v3.bin from disk                        â”‚
â”‚         â”œâ”€â”€ Initialize GPU context (CUDA/Vulkan)                    â”‚
â”‚         â”œâ”€â”€ Warm-up pass (compile GPU kernels)                      â”‚
â”‚         â””â”€â”€ Return Ok("Backend: CUDA")                              â”‚
â”‚                 â”‚                                                    â”‚
â”‚                 â–¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tauri IPC Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚
â”‚                                                                      â”‚
â”‚  6ï¸âƒ£ Frontend receives result                                       â”‚
â”‚         â”‚                                                            â”‚
â”‚         â”œâ”€â”€ setCurrentModel("large-v3")                             â”‚
â”‚         â”œâ”€â”€ setGreetMsg("âœ… Backend: CUDA")                         â”‚
â”‚         â””â”€â”€ setIsLoading(false)                                     â”‚
â”‚                                                                      â”‚
â”‚  7ï¸âƒ£ UI updates with new model info                                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âš ï¸ Safety Considerations

**Why can't we switch models while recording?**

1. **Active threads**: Recording spawns threads using the current WhisperManager
2. **Shared state**: `Arc<Mutex<WhisperManager>>` is shared between main thread and Whisper thread
3. **Context invalidation**: Switching models replaces `self.context` - threads would crash

```rust
// This check prevents crashes:
if handle.is_some() {
    return Err("Cannot switch models while recording".to_string());
}
```

**Alternative approach** (more complex):
- Use atomic flags to signal threads
- Wait for threads to acknowledge
- Then switch model safely

### ğŸ’¡ Tips for Beginners

1. **Start with smaller models**: Tiny and Base are great for development
2. **Use quantized versions**: `-q5_0` and `-q5_1` are smaller with minimal quality loss
3. **Monitor GPU usage**: Task Manager â†’ Performance â†’ GPU
4. **Check console logs**: Rust prints model loading status

### ğŸ”§ Adding New Models

To add a new Whisper model:

1. Download the `.bin` file from [Hugging Face](https://huggingface.co/ggerganov/whisper.cpp/tree/main)
2. Place it in `taurscribe-runtime/models/`
3. Restart the app (or refresh model list)
4. The model will appear in the dropdown!

**Naming convention**: `ggml-{model_name}.bin`

---

## ğŸ“ Module Architecture

This section documents Taurscribe's modular architecture introduced in January 2026.

---

## ğŸ—‚ï¸ **File Organization Summary**

### ğŸ“ **New Modular Architecture** (Refactored January 2026)

Taurscribe follows a **feature-based module structure** for maximum maintainability:

```
Taurscribe/
â”œâ”€â”€ ğŸ¨ Frontend
â”‚   â”œâ”€â”€ src/App.tsx           # Main UI logic (585 lines)
â”‚   â”œâ”€â”€ src/App.css           # Styling
â”‚   â”œâ”€â”€ src/main.tsx          # React entry point
â”‚   â””â”€â”€ index.html            # HTML shell
â”‚
â”œâ”€â”€ ğŸ¦€ Backend (Rust) - REFACTORED STRUCTURE
â”‚   â”œâ”€â”€ src-tauri/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ¯ Core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs              # App entry point (115 lines) âœ¨ 90% reduction!
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ main.rs             # Binary entry (6 lines)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ types.rs            # Shared types & enums (30 lines)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ state.rs            # Global AudioState (54 lines)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ utils.rs            # Helper functions (46 lines)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ¤ Audio Processing
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ audio.rs            # Audio primitives (16 lines)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ whisper.rs          # Whisper AI manager (780 lines)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ parakeet.rs         # Parakeet AI manager (578 lines)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vad.rs              # Voice Activity Detection (214 lines)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“¡ Commands (Tauri API)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs          # Module exports (11 lines)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ misc.rs         # Test commands (5 lines)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ models.rs       # Model management (60 lines)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ settings.rs     # Engine & backend config (55 lines)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ recording.rs    # Start/stop recording (344 lines)
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ transcription.rs # Benchmarks & samples (223 lines)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ–¼ï¸ System Tray
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ tray/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ mod.rs          # Module exports (2 lines)
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ icons.rs        # Icon management & menu (92 lines)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ âŒ¨ï¸ Global Hotkeys
â”‚   â”‚   â”‚       â””â”€â”€ hotkeys/
â”‚   â”‚   â”‚           â”œâ”€â”€ mod.rs          # Module exports (2 lines)
â”‚   â”‚   â”‚           â””â”€â”€ listener.rs     # Ctrl+Win listener (74 lines)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ build.rs          # Build script (4 lines)
â”‚   â”‚   â””â”€â”€ Cargo.toml        # Rust dependencies (109 lines)
â”‚
â”œâ”€â”€ âš™ï¸ Configuration
â”‚   â”œâ”€â”€ package.json          # Node.js config (29 lines)
â”‚   â”œâ”€â”€ vite.config.ts        # Vite config
â”‚   â”œâ”€â”€ tsconfig.json         # TypeScript config
â”‚   â””â”€â”€ .gitignore
â”‚
â”œâ”€â”€ ğŸ“¦ Runtime Assets
â”‚   â””â”€â”€ taurscribe-runtime/
â”‚       â”œâ”€â”€ models/           # AI model files (.bin, .onnx)
â”‚       â””â”€â”€ samples/          # Test audio files (.wav)
â”‚
â””â”€â”€ ğŸ“š Documentation
    â”œâ”€â”€ ARCHITECTURE.md       # This file!
    â””â”€â”€ README.md
```

---

## ğŸ“š **Module Organization Guide**

### ğŸ¯ **Why This Structure?**

The codebase was refactored from a **monolithic 1,151-line `lib.rs`** into a clean, modular architecture that:

- âœ… Makes code **easy to find** (organized by feature)
- âœ… Enables **parallel development** (multiple people can work on different modules)
- âœ… Simplifies **testing** (each module is self-contained)
- âœ… Reduces **merge conflicts** (changes are isolated)
- âœ… Follows **Rust best practices** (single responsibility principle)

### ğŸ“‚ **Module Breakdown**

#### **1ï¸âƒ£ Core Modules** (Foundation)

| File | Lines | Purpose |
|------|-------|---------|
| `lib.rs` | 115 | **App entry point** - Initializes engines, sets up Tauri, registers commands |
| `types.rs` | 30 | **Shared types** - `AppState`, `ASREngine`, `TranscriptionChunk`, `SampleFile` |
| `state.rs` | 54 | **Global state** - `AudioState` struct that holds all shared data |
| `utils.rs` | 46 | **Helper functions** - `clean_transcript()`, `get_recordings_dir()` |
| `audio.rs` | 16 | **Audio primitives** - `SendStream`, `RecordingHandle` |

**Key Concept**: These modules provide the foundation that all other modules depend on.

#### **2ï¸âƒ£ AI Engines** (Audio Processing)

| File | Lines | Purpose |
|------|-------|---------|
| `whisper.rs` | 780 | **Whisper AI** - Model loading, CUDA/Vulkan, chunk transcription, context management |
| `parakeet.rs` | 578 | **Parakeet AI** - NVIDIA Nemotron, CTC/TDT variants, streaming transcription |
| `vad.rs` | 214 | **Voice Activity Detection** - Energy-based & Silero model speech detection |

**Key Concept**: These modules are unchanged from the original structure - they were already well-organized!

#### **3ï¸âƒ£ Commands Module** (Tauri API Handlers)

The `commands/` directory contains all Tauri commands organized by domain:

| File | Lines | Handles |
|------|-------|---------|
| `misc.rs` | 5 | Test commands (`greet`) |
| `models.rs` | 60 | Model management: `list_models`, `switch_model`, `list_parakeet_models`, `init_parakeet` |
| `settings.rs` | 55 | Engine settings: `get_backend_info`, `set_active_engine`, `set_tray_state` |
| `recording.rs` | 344 | Recording lifecycle: `start_recording`, `stop_recording` (includes threading logic) |
| `transcription.rs` | 223 | Testing: `benchmark_test`, `list_sample_files` |

**Why Split by Domain?**
- Easy to find: "Where's the recording logic?" â†’ `recording.rs`
- Clear ownership: Each file has a specific responsibility
- Better imports: Only import what you need

**Example**: Adding a new model-related command?
```rust
// Go to: src-tauri/src/commands/models.rs
#[tauri::command]
pub fn my_new_model_command(state: State<AudioState>) -> Result<String, String> {
    // Implementation here
}

// Then add to lib.rs invoke_handler:
commands::my_new_model_command,
```

#### **4ï¸âƒ£ Tray Module** (System Tray)

| File | Lines | Purpose |
|------|-------|---------|
| `tray/icons.rs` | 92 | Icon macros, `update_tray_icon()`, `setup_tray()` - manages tray icon state |

**Key Functions**:
- `setup_tray()` - Creates tray icon with menu on app startup
- `update_tray_icon()` - Changes icon color based on app state (green/red/yellow)

#### **5ï¸âƒ£ Hotkeys Module** (Global Keyboard)

| File | Lines | Purpose |
|------|-------|---------|
| `hotkeys/listener.rs` | 74 | `start_hotkey_listener()` - Monitors Ctrl+Win keypresses system-wide |

**How it works**:
1. Spawns background thread
2. Uses `rdev` to listen to all keyboard events
3. Emits Tauri events when Ctrl+Win is pressed/released
4. Frontend listens for these events and triggers recording

---

## ğŸ”„ **Data Flow Through Modules**

Here's how a recording session flows through the new architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      USER CLICKS "RECORD"                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FRONTEND (App.tsx)                                             â”‚
â”‚  - invoke("start_recording")                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COMMANDS MODULE (commands/recording.rs)                        â”‚
â”‚  - start_recording() receives request                           â”‚
â”‚  - Gets state from AudioState (state.rs)                        â”‚
â”‚  - Calls utils::get_recordings_dir()                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AUDIO MODULE (audio.rs)                                        â”‚
â”‚  - Creates RecordingHandle with streams                         â”‚
â”‚  - Spawns file writer thread                                    â”‚
â”‚  - Spawns transcription thread                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â–¼                 â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  WHISPER.RS     â”‚  â”‚  PARAKEET.RS    â”‚
          â”‚  (depending on  â”‚  â”‚  (depending on  â”‚
          â”‚  active engine) â”‚  â”‚  active engine) â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚                 â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  VAD.RS         â”‚
                    â”‚  (speech check) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                    Live transcription
                    streamed to frontend
```

---

## ğŸ“ **Module Design Philosophy**

### **Feature-First Organization**

Instead of organizing by technical layer (controllers, services, models), we organize by **feature**:

âŒ **Bad** (Layer-first):
```
src/
  â”œâ”€â”€ controllers/
  â”œâ”€â”€ services/
  â””â”€â”€ models/
```

âœ… **Good** (Feature-first):
```
src/
  â”œâ”€â”€ commands/      # All user-facing commands
  â”œâ”€â”€ audio/         # All audio processing
  â”œâ”€â”€ tray/          # All tray functionality
  â””â”€â”€ hotkeys/       # All hotkey functionality
```

**Why?** When you need to modify "recording", all recording-related code is in one place!

### **Dependency Rules**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              lib.rs (top)               â”‚  â† Depends on everything
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  commands/  tray/  hotkeys/             â”‚  â† Depend on core & engines
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  whisper.rs  parakeet.rs  vad.rs        â”‚  â† Depend on core only
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  types.rs  state.rs  utils.rs  audio.rs â”‚  â† No dependencies (bottom)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Rule**: Lower modules never depend on higher modules. This prevents circular dependencies!

### **File Size Guidelines**

| Size | Status | Action |
|------|--------|--------|
| < 200 lines | âœ… Ideal | Perfect size, easy to understand |
| 200-500 lines | âœ… Good | Manageable, consider splitting if it grows |
| 500-800 lines | âš ï¸ Large | Should be split soon, but acceptable for now |
| > 800 lines | âŒ Too Big | **Split immediately!** Hard to maintain |

**Current Status**: All modules are â‰¤ 780 lines (whisper.rs is the largest, but it's cohesive).

---

## ğŸ” Quick Function Lookup

### **Need to add a feature?**

| Task | File | Function |
|------|------|----------|
| Change UI layout | `App.tsx` | Component JSX |
| Add new button | `App.tsx` | Add button in render |
| Add Tauri command | `commands/*.rs` â†’ `lib.rs` | Create in appropriate commands file + add to `.invoke_handler()` |
| Change model behavior | `whisper.rs` / `parakeet.rs` | Modify `transcribe_chunk()` or `transcribe_file()` |
| Adjust recording | `commands/recording.rs` | `start_recording()` audio callback |
| Add model command | `commands/models.rs` | New function + register in `lib.rs` |
| Add engine setting | `commands/settings.rs` | New function + register in `lib.rs` |
| Change VAD threshold | `vad.rs` | `VADManager::new()` threshold value |
| Modify tray behavior | `tray/icons.rs` | `update_tray_icon()` or `setup_tray()` |
| Change hotkey combo | `hotkeys/listener.rs` | Modify key detection logic |
| Add helper function | `utils.rs` | Create new public function |
| Add shared type | `types.rs` | Define struct/enum with derive macros |
| Add dependency | `Cargo.toml` | Add to `[dependencies]` |
| Change styling | `App.css` | Modify CSS classes |

### **Debugging a feature?**

| Issue | Check File | Check Function |
|-------|-----------|---------------|
| Recording not starting | `commands/recording.rs` | `start_recording()` |
| No audio in WAV file | `commands/recording.rs` | File writer thread (line ~601) |
| Transcription wrong | `whisper.rs` / `parakeet.rs` | `transcribe_chunk()` or `transcribe_file()` |
| UI not updating | `App.tsx` | State setters, event listeners |
| Model not loading | `whisper.rs` / `parakeet.rs` | `initialize()`, check GPU detection |
| Model switching fails | `commands/models.rs` | `switch_model()` or `init_parakeet()` |
| Backend info wrong | `commands/settings.rs` | `get_backend_info()` |
| Hotkey not working | `hotkeys/listener.rs` | `start_hotkey_listener()` callback |
| Tray icon wrong | `commands/settings.rs` | `set_tray_state()` â†’ `tray/icons.rs` |
| Tray menu not working | `tray/icons.rs` | `setup_tray()` event handlers |
| Audio format issues | `audio.rs` | `RecordingHandle` struct |
| State not persisting | `state.rs` | `AudioState` struct fields |
| Transcript cleaning | `utils.rs` | `clean_transcript()` |

### **Module Cheat Sheet** ğŸ¯

Quick reference for finding code:

| I want to... | Go to |
|-------------|-------|
| Add a new command | `commands/*.rs` (choose appropriate file) |
| Modify recording behavior | `commands/recording.rs` |
| Change AI engine logic | `whisper.rs` or `parakeet.rs` |
| Add a new model | `commands/models.rs` |
| Change app settings | `commands/settings.rs` |
| Modify tray icon | `tray/icons.rs` |
| Change hotkey combo | `hotkeys/listener.rs` |
| Add shared types | `types.rs` |
| Add utility function | `utils.rs` |
| Modify global state | `state.rs` |
| Change audio handling | `audio.rs` |
| Run benchmarks | `commands/transcription.rs` |

### **Adding a New Feature: Step-by-Step** ğŸ“

**Example: Adding a "Pause Recording" feature**

1. **Add State** (`state.rs`):
   ```rust
   pub is_paused: Mutex<bool>,
   ```

2. **Add Command** (`commands/recording.rs`):
   ```rust
   #[tauri::command]
   pub fn pause_recording(state: State<AudioState>) -> Result<(), String> {
       *state.is_paused.lock().unwrap() = true;
       Ok(())
   }
   ```

3. **Register Command** (`lib.rs`):
   ```rust
   .invoke_handler(tauri::generate_handler![
       // ... existing commands ...
       commands::pause_recording,
   ])
   ```

4. **Call from Frontend** (`App.tsx`):
   ```typescript
   await invoke("pause_recording");
   ```

Done! âœ…

---

## ğŸ§  LLM Integration: SmolLM2 Grammar Correction

This section documents the **complete integration of a Transformer-based Large Language Model (LLM)** into Taurscribe for grammar correction. We'll cover every crate, every function, every issue encountered, and how they were solved.

---

### ğŸ¯ Purpose

After transcription, the text may contain grammatical errors, especially for real-time streaming. SmolLM2 (a 135M parameter model from Hugging Face) is integrated to:

1. **Correct grammar errors** in transcribed text
2. **Run locally** (no API calls, full privacy)
3. **Use GPU acceleration** (CUDA) when available
4. **Integrate seamlessly** with the existing Tauri architecture

---

### ğŸ“¦ Crates Used

Here are ALL the Rust crates we added and why:

#### **1. candle-core (version 0.9.2)**
```toml
candle-core = { version = "0.9.2", default-features = false }
```
**What it does**: The core tensor library from Hugging Face. Like PyTorch but for Rust.

**Key Types Used**:
- `DType::F32` - 32-bit floating point numbers for model weights
- `Device::Cpu` / `Device::new_cuda(0)` - Where computations run
- `Tensor` - Multi-dimensional arrays (like NumPy arrays)

**Why `default-features = false`?**: By default, candle enables CUDA kernel compilation which requires `nvcc`. This fails outside the x64 Native Tools Command Prompt. Disabling default features means we manually control CUDA support.

---

#### **2. candle-nn (version 0.9.2)**
```toml
candle-nn = { version = "0.9.2", default-features = false }
```
**What it does**: Neural network building blocks (layers, activations, etc.)

**Key Types Used**:
- `VarBuilder` - Loads model weights from safetensors files
- `VarBuilder::from_mmaped_safetensors()` - Memory-maps the file for efficiency

---

#### **3. candle-transformers (version 0.9.2)**
```toml
candle-transformers = { version = "0.9.2", default-features = false }
```
**What it does**: Pre-built transformer architectures (Llama, GPT, BERT, etc.)

**Key Types Used**:
- `Llama` - The actual LLM model class
- `Config` - Model configuration (hidden_size, num_layers, etc.)
- `Cache` - KV-cache for efficient token generation
- `LlamaEosToks::Single(u32)` - End-of-sequence token wrapper
- `LogitsProcessor` - Sampling strategy for text generation

---

#### **4. tokenizers (version 0.21.0)**
```toml
tokenizers = "0.21.0"
```
**What it does**: Hugging Face's tokenizer library. Converts text â†” token IDs.

**Key Types Used**:
- `Tokenizer` - Loads tokenizer.json and handles encoding/decoding
- `Tokenizer::encode()` - "Hello world" â†’ [1234, 5678, ...]
- `Tokenizer::decode()` - [1234, 5678, ...] â†’ "Hello world"
- `Tokenizer::token_to_id()` - Get ID for special tokens like `<|im_end|>`

---

#### **5. anyhow (version 1.0)**
```toml
anyhow = "1.0"
```
**What it does**: Simplified error handling with the `Result<T>` type and `anyhow!` macro.

**Why?**: Candle functions return various error types. `anyhow` lets us convert them all to one unified error type.

---

### ğŸ—‚ï¸ Files Created/Modified

| File | Purpose |
|------|---------|
| `src/llm.rs` | **NEW** - LlmManager struct and all LLM logic |
| `src/lib.rs` | Added `mod llm;` and initialization |
| `src/state.rs` | Added `llm: Arc<Mutex<LlmManager>>` to AudioState |
| `src/commands/transcription.rs` | Added `correct_text` Tauri command |
| `Cargo.toml` | Added candle, tokenizers, anyhow dependencies |
| `src/App.tsx` | Added "Correct Grammar" button and logic |
| `src/App.css` | Added `.btn-correct` styling |

---

### ğŸ“ Model Files Required & Architecture

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        ğŸ“ LLM MODEL FILE STRUCTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

taurscribe-runtime/
â”‚
â”œâ”€â”€ models/
â”‚   â”‚
â”‚   â”œâ”€â”€ ggml-*.bin              â† Whisper models (existing)
â”‚   â”‚
â”‚   â”œâ”€â”€ silero_vad.onnx         â† Voice Activity Detection (existing)
â”‚   â”‚
â”‚   â””â”€â”€ llm/                    â† ğŸ†• NEW: SmolLM2 Grammar Correction
â”‚       â”‚
â”‚       â”œâ”€â”€ config.json         â† Model architecture (576 hidden, 30 layers)
â”‚       â”‚     â”‚
â”‚       â”‚     â””â”€â”€â–º Tells candle-transformers HOW to build the neural network
â”‚       â”‚
â”‚       â”œâ”€â”€ tokenizer.json      â† Vocabulary + tokenization rules (49,152 tokens)
â”‚       â”‚     â”‚
â”‚       â”‚     â””â”€â”€â–º Converts "hello world" â†” [1234, 5678] (text â†” numbers)
â”‚       â”‚
â”‚       â””â”€â”€ model.safetensors   â† The actual weights (~270 MB, 135M parameters)
â”‚             â”‚
â”‚             â””â”€â”€â–º 135 million numbers that encode "knowledge" of grammar
â”‚
â””â”€â”€ bin/                        â† Shared libraries (whisper DLLs, etc.)
```

---

### ğŸ“„ config.json Explained

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          config.json (SmolLM2-135M)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  {                                                                          â”‚
â”‚    "hidden_size": 576,           â† Size of each hidden layer (576 neurons)â”‚
â”‚    "intermediate_size": 1536,    â† Feed-forward expansion (576 â†’ 1536)    â”‚
â”‚    "num_hidden_layers": 30,      â† Number of transformer blocks           â”‚
â”‚    "num_attention_heads": 9,     â† Parallel attention "eyes"              â”‚
â”‚    "num_key_value_heads": 3,     â† Grouped-Query Attention (GQA)          â”‚
â”‚    "vocab_size": 49152,          â† Total tokens in vocabulary             â”‚
â”‚    "max_position_embeddings": 8192, â† Max context length                  â”‚
â”‚    "rms_norm_eps": 1e-05,        â† Numerical stability for normalization  â”‚
â”‚    "rope_theta": 100000,         â† Rotary Position Embedding base         â”‚
â”‚    "tie_word_embeddings": true   â† Share input/output embedding weights   â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LOADED BY: SmolLM2Config struct (llm.rs)                 â”‚
â”‚                                                                             â”‚
â”‚   let config_str = std::fs::read_to_string(&config_path)?;                 â”‚
â”‚   let smol_config: SmolLM2Config = serde_json::from_str(&config_str)?;     â”‚
â”‚   let config: Config = smol_config.into();  // Convert to candle format   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“„ tokenizer.json Explained

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         tokenizer.json (SmolLM2)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  {                                                                          â”‚
â”‚    "version": "1.0",                                                        â”‚
â”‚    "model": {                                                               â”‚
â”‚      "type": "BPE",              â† Byte-Pair Encoding algorithm            â”‚
â”‚      "vocab": {                                                             â”‚
â”‚        "hello": 1234,            â† Token ID mappings                       â”‚
â”‚        "world": 5678,                                                       â”‚
â”‚        "<|im_start|>": 100264,   â† Special: Start of message               â”‚
â”‚        "<|im_end|>": 100265,     â† Special: End of message                 â”‚
â”‚        ...49,152 more tokens...                                            â”‚
â”‚      },                                                                     â”‚
â”‚      "merges": [                 â† BPE merge rules                         â”‚
â”‚        "h e",                    â† Merge 'h' + 'e' â†’ "he"                  â”‚
â”‚        "he llo",                 â† Merge "he" + "llo" â†’ "hello"            â”‚
â”‚        ...                                                                  â”‚
â”‚      ]                                                                      â”‚
â”‚    },                                                                       â”‚
â”‚    "special_tokens_map": {...}                                              â”‚
â”‚  }                                                                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ”„ Tokenizer Flow Diagram

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                          ğŸ”„ TOKENIZER ENCODE/DECODE FLOW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                         ENCODE (Text â†’ Token IDs)
                         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

User Input: "Fix this: hello wrold"
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: BUILD PROMPT (ChatML Format)                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  "<|im_start|>system\n"                                                   â”‚
â”‚  "Fix grammar errors. Output only the corrected text.<|im_end|>\n"       â”‚
â”‚  "<|im_start|>user\n"                                                     â”‚
â”‚  "hello wrold<|im_end|>\n"                                               â”‚
â”‚  "<|im_start|>assistant\n"                                               â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: TOKENIZE (String â†’ Vec<u32>)                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  tokenizer.encode(prompt, true)                                           â”‚
â”‚                                                                           â”‚
â”‚  "<|im_start|>" â†’ 100264                                                  â”‚
â”‚  "system"       â†’ 9125                                                    â”‚
â”‚  "\n"           â†’ 198                                                     â”‚
â”‚  "Fix"          â†’ 22093                                                   â”‚
â”‚  " grammar"     â†’ 32548                                                   â”‚
â”‚  " errors"      â†’ 6103                                                    â”‚
â”‚  "."            â†’ 13                                                      â”‚
â”‚  ...                                                                      â”‚
â”‚  "hello"        â†’ 15339                                                   â”‚
â”‚  " wr"          â†’ 2949                                                    â”‚
â”‚  "old"          â†’ 727                 â† "wrold" split into "wr" + "old"  â”‚
â”‚  "<|im_end|>"   â†’ 100265                                                  â”‚
â”‚                                                                           â”‚
â”‚  Result: [100264, 9125, 198, 22093, 32548, 6103, 13, ..., 100265]        â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: FEED TO LLM                                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  Token IDs â†’ Tensor::new(&tokens, &device)                               â”‚
â”‚           â†’ model.forward(&input, start_pos, cache)                      â”‚
â”‚           â†’ Logits (probability distribution over 49,152 tokens)         â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


                         DECODE (Token IDs â†’ Text)
                         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LLM Output: [15496, 995, 13, 100265]  (generated tokens)
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: SAMPLE TOKENS                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  logits_processor.sample(&logits)                                        â”‚
â”‚                                                                           â”‚
â”‚  Iteration 1: Logits[49152] â†’ Pick token 15496 ("Hello")                 â”‚
â”‚  Iteration 2: Logits[49152] â†’ Pick token 995   (" world")                â”‚
â”‚  Iteration 3: Logits[49152] â†’ Pick token 13    (".")                     â”‚
â”‚  Iteration 4: Logits[49152] â†’ Pick token 100265 ("<|im_end|>") â†’ STOP!   â”‚
â”‚                                                                           â”‚
â”‚  result_tokens = [15496, 995, 13]  (excluding <|im_end|>)                â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: DECODE TO TEXT                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  tokenizer.decode(&result_tokens, true)                                  â”‚
â”‚                                                                           â”‚
â”‚  15496 â†’ "Hello"                                                         â”‚
â”‚  995   â†’ " world"                                                        â”‚
â”‚  13    â†’ "."                                                             â”‚
â”‚                                                                           â”‚
â”‚  Result: "Hello world."                                                   â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
Final Output: "Hello world." âœ… (Grammar corrected!)
```

---

### ğŸ“„ model.safetensors Explained

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    model.safetensors (~270 MB, 135M parameters)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  FORMAT: SafeTensors (Hugging Face's safe binary format)                   â”‚
â”‚                                                                             â”‚
â”‚  CONTENTS:                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  model.embed_tokens.weight      [49152, 576]   â† Word embeddings       â”‚â”‚
â”‚  â”‚                                                   49152 tokens Ã— 576D  â”‚â”‚
â”‚  â”‚                                                                        â”‚â”‚
â”‚  â”‚  model.layers.0.self_attn.q_proj.weight  [576, 576]  â† Query matrix    â”‚â”‚
â”‚  â”‚  model.layers.0.self_attn.k_proj.weight  [192, 576]  â† Key matrix      â”‚â”‚
â”‚  â”‚  model.layers.0.self_attn.v_proj.weight  [192, 576]  â† Value matrix    â”‚â”‚
â”‚  â”‚  model.layers.0.self_attn.o_proj.weight  [576, 576]  â† Output matrix   â”‚â”‚
â”‚  â”‚  model.layers.0.mlp.gate_proj.weight     [1536, 576] â† FFN gate        â”‚â”‚
â”‚  â”‚  model.layers.0.mlp.up_proj.weight       [1536, 576] â† FFN up          â”‚â”‚
â”‚  â”‚  model.layers.0.mlp.down_proj.weight     [576, 1536] â† FFN down        â”‚â”‚
â”‚  â”‚  model.layers.0.input_layernorm.weight   [576]       â† Layer norm      â”‚â”‚
â”‚  â”‚  ...                                                                    â”‚â”‚
â”‚  â”‚  (Repeat for layers 1-29)                                              â”‚â”‚
â”‚  â”‚  ...                                                                    â”‚â”‚
â”‚  â”‚  model.layers.29.self_attn.q_proj.weight [576, 576]                    â”‚â”‚
â”‚  â”‚  ...                                                                    â”‚â”‚
â”‚  â”‚  model.norm.weight                       [576]       â† Final norm       â”‚â”‚
â”‚  â”‚  lm_head.weight                          [49152, 576] â† Output layer   â”‚â”‚
â”‚  â”‚                                          (tied with embed_tokens)      â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                             â”‚
â”‚  TOTAL: ~135 million floating-point numbers (f32 = 4 bytes each)           â”‚
â”‚         135M Ã— 4 bytes = ~540 MB uncompressed                              â”‚
â”‚         Actual: ~270 MB (uses float16 in places)                           â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  LOADED BY: VarBuilder (candle-nn)                          â”‚
â”‚                                                                             â”‚
â”‚   // Memory-map the file (doesn't load all into RAM immediately)           â”‚
â”‚   let vb = unsafe {                                                        â”‚
â”‚       VarBuilder::from_mmaped_safetensors(                                 â”‚
â”‚           &[weights_path],    // Path to model.safetensors                 â”‚
â”‚           DType::F32,         // Data type                                 â”‚
â”‚           &self.device        // CPU or CUDA device                        â”‚
â”‚       )?                                                                   â”‚
â”‚   };                                                                       â”‚
â”‚                                                                             â”‚
â”‚   // Build the model architecture and load weights                         â”‚
â”‚   let model = Llama::load(vb, &config)?;                                   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ—ï¸ Codebase Integration Diagram

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    ğŸ—ï¸ LLM INTEGRATION CODEBASE ARCHITECTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

src-tauri/
â”‚
â”œâ”€â”€ src/
â”‚   â”‚
â”‚   â”œâ”€â”€ lib.rs                    â† ğŸ“ MAIN ENTRY POINT
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ mod llm;              â† ğŸ†• NEW: Declares llm module
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ run() {
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ // Initialize Whisper...
â”‚   â”‚       â”œâ”€â”€ // Initialize Parakeet...
â”‚   â”‚       â”œâ”€â”€ // Initialize VAD...
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ // ğŸ†• NEW: Initialize LLM
â”‚   â”‚       â”‚   println!("[INFO] Initializing LLM...");
â”‚   â”‚       â”‚   let mut llm = LlmManager::new();
â”‚   â”‚       â”‚   llm.initialize()?;
â”‚   â”‚       â”‚   let llm = Arc::new(Mutex::new(llm));
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ // Create state with all managers
â”‚   â”‚       â”‚   AudioState::new(whisper, parakeet, vad, llm)
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â”€ // Register commands
â”‚   â”‚           .invoke_handler([..., commands::correct_text])
â”‚   â”‚   }
â”‚   â”‚
â”‚   â”œâ”€â”€ state.rs                  â† ğŸ“ SHARED STATE
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ pub struct AudioState {
â”‚   â”‚       â”œâ”€â”€ whisper: Arc<Mutex<WhisperManager>>,
â”‚   â”‚       â”œâ”€â”€ parakeet: Arc<Mutex<ParakeetManager>>,
â”‚   â”‚       â”œâ”€â”€ vad: Arc<Mutex<VadManager>>,
â”‚   â”‚       â””â”€â”€ llm: Arc<Mutex<LlmManager>>,  â† ğŸ†• NEW!
â”‚   â”‚   }
â”‚   â”‚
â”‚   â”œâ”€â”€ llm.rs                    â† ğŸ†• NEW MODULE (241 lines)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ GpuBackend enum       â† Track CUDA vs CPU
â”‚   â”‚   â”œâ”€â”€ SmolLM2Config struct  â† Deserialize config.json
â”‚   â”‚   â”œâ”€â”€ impl From<SmolLM2Config> for Config  â† Convert to candle
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ pub struct LlmManager {
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ model: Option<Llama>         â† Neural network
â”‚   â”‚       â”œâ”€â”€ tokenizer: Option<Tokenizer> â† Text â†” tokens
â”‚   â”‚       â”œâ”€â”€ cache: Option<Cache>         â† KV-cache
â”‚   â”‚       â”œâ”€â”€ device: Device               â† CPU or CUDA
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ fn get_models_dir()          â† Find llm/ folder
â”‚   â”‚       â”œâ”€â”€ fn initialize()              â† Load model
â”‚   â”‚       â””â”€â”€ fn generate_correction()     â† Run inference
â”‚   â”‚   }
â”‚   â”‚
â”‚   â””â”€â”€ commands/
â”‚       â”‚
â”‚       â””â”€â”€ transcription.rs
â”‚           â”‚
â”‚           â””â”€â”€ #[tauri::command]
â”‚               pub fn correct_text(           â† ğŸ†• NEW COMMAND
â”‚                   state: State<AudioState>,
â”‚                   text: String
â”‚               ) -> Result<String, String> {
â”‚                   let mut llm = state.llm.lock()?;
â”‚                   llm.generate_correction(&text)
â”‚               }
â”‚
â”œâ”€â”€ Cargo.toml                    â† ğŸ“ DEPENDENCIES
â”‚   â”‚
â”‚   â””â”€â”€ [dependencies]
â”‚       â”œâ”€â”€ candle-core = { version = "0.9.2", default-features = false }
â”‚       â”œâ”€â”€ candle-nn = { version = "0.9.2", default-features = false }
â”‚       â”œâ”€â”€ candle-transformers = { version = "0.9.2", default-features = false }
â”‚       â”œâ”€â”€ tokenizers = "0.21.0"
â”‚       â””â”€â”€ anyhow = "1.0"
â”‚
â””â”€â”€ .cargo/config.toml            â† ğŸ“ BUILD CONFIG
    â”‚
    â””â”€â”€ [env]
        â”œâ”€â”€ CFLAGS = "/MD /EHsc"       â† ğŸ†• Fix CRT mismatch
        â””â”€â”€ CXXFLAGS = "/MD /EHsc"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                              FRONTEND INTEGRATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

src/
â”‚
â”œâ”€â”€ App.tsx                       â† ğŸ“ MAIN REACT COMPONENT
â”‚   â”‚
â”‚   â”œâ”€â”€ const [isCorrecting, setIsCorrecting] = useState(false);  â† ğŸ†• NEW
â”‚   â”‚
â”‚   â”œâ”€â”€ const handleGrammarCorrection = async () => {  â† ğŸ†• NEW
â”‚   â”‚   â”‚   setIsCorrecting(true);
â”‚   â”‚   â”‚   const corrected = await invoke("correct_text", { text: content });
â”‚   â”‚   â”‚   setContent(corrected);
â”‚   â”‚   â”‚   setIsCorrecting(false);
â”‚   â”‚   };
â”‚   â”‚
â”‚   â””â”€â”€ <button className="btn-correct" onClick={handleGrammarCorrection}>
â”‚           âœ¨ Correct Grammar
â”‚       </button>
â”‚
â””â”€â”€ App.css                       â† ğŸ“ STYLES
    â”‚
    â””â”€â”€ .btn-correct {             â† ğŸ†• NEW
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            transition: transform 0.2s;
        }
```

---

### ğŸ”Œ Data Flow: Frontend â†’ Backend â†’ LLM â†’ Frontend

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    ğŸ”Œ COMPLETE DATA FLOW DIAGRAM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          FRONTEND (React + TypeScript)                      â”‚
 â”‚                                                                             â”‚
 â”‚  User clicks "âœ¨ Correct Grammar" button                                    â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  invoke<string>("correct_text", { text: "hello wrold" })                   â”‚
 â”‚                â”‚                                                            â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚  Tauri IPC Bridge (JSON serialization)
                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          BACKEND (Rust + Tauri)                             â”‚
 â”‚                                                                             â”‚
 â”‚  #[tauri::command]                                                          â”‚
 â”‚  fn correct_text(state: State<AudioState>, text: String)                   â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  1. Lock the LlmManager mutex                              â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  let mut llm = state.llm.lock()?;                                          â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  2. Call generate_correction                               â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  llm.generate_correction(&text)                                            â”‚
 â”‚                â”‚                                                            â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          LLM MANAGER (llm.rs)                               â”‚
 â”‚                                                                             â”‚
 â”‚  fn generate_correction(&mut self, text: &str) -> Result<String>           â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  3. Build ChatML prompt                                    â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  "<|im_start|>system\nFix grammar...<|im_end|>\n..."                       â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  4. Tokenize                                               â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  tokenizer.encode(prompt, true) â†’ [100264, 9125, 198, ...]                 â”‚
 â”‚                â”‚                                                            â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          CANDLE (Neural Network)                            â”‚
 â”‚                                                                             â”‚
 â”‚  for i in 0..100 {                                                          â”‚
 â”‚      â”‚                                                                      â”‚
 â”‚      â”‚  5. Create tensor from tokens                                        â”‚
 â”‚      â–¼                                                                      â”‚
 â”‚      let input = Tensor::new(&tokens[start_pos..], &device)?;              â”‚
 â”‚      â”‚                                                                      â”‚
 â”‚      â”‚  6. Run forward pass (GPU computation!)                              â”‚
 â”‚      â–¼                                                                      â”‚
 â”‚      let logits = model.forward(&input, start_pos, cache)?;                â”‚
 â”‚      â”‚                                                                      â”‚
 â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
 â”‚      â”‚  â”‚              INSIDE THE NEURAL NETWORK                      â”‚    â”‚
 â”‚      â”‚  â”‚                                                             â”‚    â”‚
 â”‚      â”‚  â”‚  Tokens â†’ Embeddings (576-dim vectors)                     â”‚    â”‚
 â”‚      â”‚  â”‚     â”‚                                                       â”‚    â”‚
 â”‚      â”‚  â”‚     â–¼                                                       â”‚    â”‚
 â”‚      â”‚  â”‚  Layer 1: Attention â†’ MLP                                  â”‚    â”‚
 â”‚      â”‚  â”‚     â”‚                                                       â”‚    â”‚
 â”‚      â”‚  â”‚     â–¼                                                       â”‚    â”‚
 â”‚      â”‚  â”‚  Layer 2: Attention â†’ MLP                                  â”‚    â”‚
 â”‚      â”‚  â”‚     â”‚                                                       â”‚    â”‚
 â”‚      â”‚  â”‚     â–¼                                                       â”‚    â”‚
 â”‚      â”‚  â”‚  ... (28 more layers)                                      â”‚    â”‚
 â”‚      â”‚  â”‚     â”‚                                                       â”‚    â”‚
 â”‚      â”‚  â”‚     â–¼                                                       â”‚    â”‚
 â”‚      â”‚  â”‚  Layer 30: Attention â†’ MLP                                 â”‚    â”‚
 â”‚      â”‚  â”‚     â”‚                                                       â”‚    â”‚
 â”‚      â”‚  â”‚     â–¼                                                       â”‚    â”‚
 â”‚      â”‚  â”‚  Output: Logits [49,152 probabilities]                     â”‚    â”‚
 â”‚      â”‚  â”‚                                                             â”‚    â”‚
 â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
 â”‚      â”‚                                                                      â”‚
 â”‚      â”‚  7. Sample next token                                                â”‚
 â”‚      â–¼                                                                      â”‚
 â”‚      let next_token = logits_processor.sample(&logits)?;                   â”‚
 â”‚      â”‚                                                                      â”‚
 â”‚      â”‚  8. Check for end token                                              â”‚
 â”‚      â–¼                                                                      â”‚
 â”‚      if next_token == eos_id { break; }                                    â”‚
 â”‚  }                                                                          â”‚
 â”‚                â”‚                                                            â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          DECODE & RETURN                                    â”‚
 â”‚                                                                             â”‚
 â”‚  9. Decode tokens to text                                                   â”‚
 â”‚     tokenizer.decode(&result_tokens, true)                                 â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â–¼                                                            â”‚
 â”‚     [15496, 995, 13] â†’ "Hello world."                                      â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  10. Return Ok(corrected_text)                             â”‚
 â”‚                â–¼                                                            â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚  Tauri IPC Bridge (JSON deserialization)
                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          FRONTEND (React + TypeScript)                      â”‚
 â”‚                                                                             â”‚
 â”‚  const corrected = await invoke(...);                                       â”‚
 â”‚                â”‚                                                            â”‚
 â”‚                â”‚  11. Update state                                          â”‚
 â”‚                â–¼                                                            â”‚
 â”‚  setContent("Hello world.");  â† Display corrected text!                    â”‚
 â”‚                                                                             â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“š What is a Tokenizer? (Beginner's Guide)

Before the AI can understand text, it needs to convert human words into numbers. That's what a **tokenizer** does!

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    ğŸ”¤ TOKENIZER: TEXT â†” NUMBERS TRANSLATOR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤” THE PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Computers don't understand words like "hello" or "grammar".
They only understand numbers like 15339 or 49012.

We need a TRANSLATOR to convert between human language and computer language!


ğŸ¯ WHAT IS A TOKENIZER?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A tokenizer is like a DICTIONARY + TRANSLATOR combined:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          THE TOKENIZER'S JOB                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   HUMAN TEXT                    TOKENIZER                    NUMBERS        â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•                    â•â•â•â•â•â•â•â•â•                    â•â•â•â•â•â•â•        â”‚
â”‚                                                                             â”‚
â”‚   "Hello world!"    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  [ENCODE]  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   [15339, 1917, 0]  â”‚
â”‚                                     â”‚                                       â”‚
â”‚                                     â”‚                                       â”‚
â”‚   "Hello world!"    â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  [DECODE]  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   [15339, 1917, 0]  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ“– THE VOCABULARY (Dictionary)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The tokenizer has a vocabulary of ~49,152 "tokens" (word pieces).

Think of it like a HUGE dictionary where every entry is numbered:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     TOKENIZER VOCABULARY (Simplified)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚   Token ID   â”‚   Token Text     â”‚   Type                                 â”‚
â”‚   â•â•â•â•â•â•â•â•â•  â”‚   â•â•â•â•â•â•â•â•â•â•     â”‚   â•â•â•â•                                 â”‚
â”‚                                                                          â”‚
â”‚      0       â”‚   "<unk>"        â”‚   Unknown token (rare words)           â”‚
â”‚      1       â”‚   "<s>"          â”‚   Start of sequence                    â”‚
â”‚      2       â”‚   "</s>"         â”‚   End of sequence                      â”‚
â”‚    ...       â”‚   ...            â”‚   ...                                  â”‚
â”‚    100264    â”‚   "<|im_start|>" â”‚   Chat message start (special)         â”‚
â”‚    100265    â”‚   "<|im_end|>"   â”‚   Chat message end (special)           â”‚
â”‚    ...       â”‚   ...            â”‚   ...                                  â”‚
â”‚    15339     â”‚   "Hello"        â”‚   Common word                          â”‚
â”‚    1917      â”‚   " world"       â”‚   Word with leading space              â”‚
â”‚    13        â”‚   "."            â”‚   Punctuation                          â”‚
â”‚    262       â”‚   " the"         â”‚   Very common (low ID = frequent)      â”‚
â”‚    287       â”‚   " a"           â”‚   Very common                          â”‚
â”‚    ...       â”‚   ...            â”‚   ...                                  â”‚
â”‚    39421     â”‚   "Taurscribe"   â”‚   Rare word (high ID = uncommon)       â”‚
â”‚                                                                          â”‚
â”‚            TOTAL: 49,152 possible tokens                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ§© SUBWORD TOKENIZATION (BPE)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Modern tokenizers don't store every word. They use BPE (Byte-Pair Encoding):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HOW BPE WORKS: "unhappiness" Example                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   Word: "unhappiness"                                                       â”‚
â”‚                                                                             â”‚
â”‚   Step 1: Break into known pieces                                           â”‚
â”‚           "un" + "happiness"                                                â”‚
â”‚             â”‚         â”‚                                                     â”‚
â”‚             â–¼         â–¼                                                     â”‚
â”‚           [982]   Is "happiness" known?                                     â”‚
â”‚                        â”‚                                                    â”‚
â”‚                   NO! Break further:                                        â”‚
â”‚                   "happ" + "iness"                                          â”‚
â”‚                      â”‚         â”‚                                            â”‚
â”‚                      â–¼         â–¼                                            â”‚
â”‚                   [29453]   [1619]                                          â”‚
â”‚                                                                             â”‚
â”‚   Final tokens: [982, 29453, 1619]                                          â”‚
â”‚                  "un" + "happ" + "iness"                                    â”‚
â”‚                                                                             â”‚
â”‚   âœ… BENEFIT: Can handle ANY word, even made-up ones like "Taurscribe"!    â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ”„ ENCODE: Text â†’ Token IDs (Step-by-Step)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Example: "Fix grammar: hello wrold"

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           TOKENIZATION PROCESS                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   INPUT: "Fix grammar: hello wrold"                                         â”‚
â”‚                                                                             â”‚
â”‚   Step 1: Add special tokens (ChatML format)                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ <|im_start|>system                                                  â”‚   â”‚
â”‚   â”‚ Fix grammar errors and return only the corrected text.<|im_end|>   â”‚   â”‚
â”‚   â”‚ <|im_start|>user                                                    â”‚   â”‚
â”‚   â”‚ hello wrold<|im_end|>                                               â”‚   â”‚
â”‚   â”‚ <|im_start|>assistant                                               â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚   Step 2: Look up each piece in vocabulary                                  â”‚
â”‚                                                                             â”‚
â”‚   Text Piece          â”‚  Vocabulary Lookup  â”‚  Token ID                    â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•â•â•                   â”‚
â”‚   "<|im_start|>"      â”‚  Found!             â”‚  100264                      â”‚
â”‚   "system"            â”‚  Found!             â”‚  9125                        â”‚
â”‚   "\n"                â”‚  Found!             â”‚  198                         â”‚
â”‚   "Fix"               â”‚  Found!             â”‚  22093                       â”‚
â”‚   " grammar"          â”‚  Found!             â”‚  38428                       â”‚
â”‚   " errors"           â”‚  Found!             â”‚  8563                        â”‚
â”‚   " and"              â”‚  Found!             â”‚  323                         â”‚
â”‚   " return"           â”‚  Found!             â”‚  471                         â”‚
â”‚   ...                 â”‚  ...                â”‚  ...                         â”‚
â”‚   "hello"             â”‚  Found!             â”‚  15339                       â”‚
â”‚   " wr"               â”‚  Found (subword!)   â”‚  9923                        â”‚
â”‚   "old"               â”‚  Found (subword!)   â”‚  820                         â”‚
â”‚   "<|im_end|>"        â”‚  Found!             â”‚  100265                      â”‚
â”‚                                                                             â”‚
â”‚   OUTPUT: [100264, 9125, 198, 22093, 38428, ..., 15339, 9923, 820, 100265] â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ”„ DECODE: Token IDs â†’ Text
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The reverse process:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           DECODING PROCESS                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   INPUT: [15339, 1917]                                                      â”‚
â”‚                                                                             â”‚
â”‚   Token ID    â”‚  Lookup in Vocab  â”‚  Text Piece                            â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•â•â•â•                            â”‚
â”‚     15339     â”‚  vocab[15339]     â”‚  "Hello"                               â”‚
â”‚     1917      â”‚  vocab[1917]      â”‚  " world"                              â”‚
â”‚                                                                             â”‚
â”‚   Concatenate: "Hello" + " world" = "Hello world"                           â”‚
â”‚                                                                             â”‚
â”‚   OUTPUT: "Hello world"                                                     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ• PIZZA ANALOGY FOR TOKENIZATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Think of tokenization like ordering pizza:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   "I want a large pepperoni pizza with extra cheese"                        â”‚
â”‚                                                                             â”‚
â”‚   TOKENIZE (like writing an order slip):                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚   â”‚  Order #15339: Large                   â”‚                                â”‚
â”‚   â”‚  Order #28472: Pepperoni               â”‚                                â”‚
â”‚   â”‚  Order #19283: Pizza                   â”‚                                â”‚
â”‚   â”‚  Order #92837: Extra Cheese            â”‚                                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                                             â”‚
â”‚   The kitchen (AI) only sees ORDER NUMBERS, not words!                      â”‚
â”‚   But it knows what each number means because of the menu (vocabulary).     â”‚
â”‚                                                                             â”‚
â”‚   DECODE (reading the order slip back):                                     â”‚
â”‚   #15339 â†’ "Large"                                                          â”‚
â”‚   #28472 â†’ "Pepperoni"                                                      â”‚
â”‚   ...etc â†’ Original sentence!                                               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ§  What is a Transformer? (Beginner's Guide)

Now that we know how text becomes numbers, let's understand the **brain** that processes them: the **Transformer**!

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    ğŸ§  TRANSFORMER: THE AI BRAIN ARCHITECTURE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤” WHAT PROBLEM DOES IT SOLVE?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Given a sequence of words, predict the NEXT word:

   Input:  "The cat sat on the ____"
   Output: "mat" (most likely next word!)

The Transformer was invented in 2017 and revolutionized AI!
SmolLM2 (used in Taurscribe) is a small Transformer with 135 million "neurons".


ğŸ—ï¸ THE BASIC STRUCTURE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

A Transformer is like a FACTORY with multiple FLOORS (layers):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      TRANSFORMER ARCHITECTURE (SmolLM2)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   INPUT: Token IDs [15339, 1917, 0]  ("Hello world!")                       â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ğŸ“¥ EMBEDDING LAYER                                                 â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  Convert each token ID into a VECTOR (list of 576 numbers)          â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  Token 15339 â†’ [0.23, -0.45, 0.12, ..., 0.89]  (576 numbers)       â”‚   â”‚
â”‚   â”‚  Token 1917  â†’ [0.56, 0.78, -0.34, ..., -0.12] (576 numbers)       â”‚   â”‚
â”‚   â”‚  Token 0     â†’ [0.11, 0.22, 0.33, ..., 0.44]   (576 numbers)       â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  These vectors ENCODE the meaning of each token!                    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ğŸ”„ LAYER 1: ATTENTION + MLP                                        â”‚   â”‚
â”‚   â”‚      â”‚                                                              â”‚   â”‚
â”‚   â”‚      â”œâ”€â”€ ATTENTION: "Which tokens should I pay attention to?"       â”‚   â”‚
â”‚   â”‚      â”‚   (e.g., connect "it" to "cat" in "The cat is fluffy. It...") â”‚   â”‚
â”‚   â”‚      â”‚                                                              â”‚   â”‚
â”‚   â”‚      â””â”€â”€ MLP: Transform the information (neural network magic)       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ğŸ”„ LAYER 2: ATTENTION + MLP                                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚           ... (28 more layers)                                              â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ğŸ”„ LAYER 30: ATTENTION + MLP (Final layer!)                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ğŸ“¤ OUTPUT LAYER (LM Head)                                          â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  Convert final vectors back to PROBABILITIES for each possible     â”‚   â”‚
â”‚   â”‚  next token (49,152 options!)                                       â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  Output: [0.001, 0.002, ..., 0.847, ..., 0.0001]                    â”‚   â”‚
â”‚   â”‚          (49,152 probabilities that sum to 1.0)                     â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚  Token 1917 ("world") has probability 0.847 = Most likely next!    â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   OUTPUT: Next token = 1917 ("world")                                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ¯ ATTENTION MECHANISM: THE MAGIC INGREDIENT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Attention is the CORE innovation that makes Transformers so powerful!

PROBLEM: How does the model know that "it" refers to "cat" in:
         "The cat sat on the mat. It was fluffy."

SOLUTION: ATTENTION! The model learns to "look at" relevant tokens.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       HOW ATTENTION WORKS (Simplified)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   Sentence: "The cat sat on the mat. It was fluffy."                        â”‚
â”‚                                                                             â”‚
â”‚   When processing "It", the model asks:                                     â”‚
â”‚   "Which previous words should I pay attention to?"                         â”‚
â”‚                                                                             â”‚
â”‚   Attention Weights (learned automatically!):                               â”‚
â”‚                                                                             â”‚
â”‚   Word        â”‚  Attention Score  â”‚  Visual                                â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚ â•â•â•â•â•â•â•â•                               â”‚
â”‚   "The"       â”‚  0.02             â”‚  â–‘                                     â”‚
â”‚   "cat"       â”‚  0.85  â† HIGHEST! â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                      â”‚
â”‚   "sat"       â”‚  0.03             â”‚  â–‘                                     â”‚
â”‚   "on"        â”‚  0.01             â”‚  â–‘                                     â”‚
â”‚   "the"       â”‚  0.02             â”‚  â–‘                                     â”‚
â”‚   "mat"       â”‚  0.05             â”‚  â–ˆ                                     â”‚
â”‚   "It"        â”‚  0.02             â”‚  â–‘                                     â”‚
â”‚                                                                             â”‚
â”‚   The model learned that "It" most likely refers to "cat"!                  â”‚
â”‚   This is learned from training data (millions of sentences).               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ“– ATTENTION ANALOGY: Reading Comprehension
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Imagine you're taking a reading comprehension test:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                             â”‚
â”‚   Passage: "The quick brown fox jumps over the lazy dog.                    â”‚
â”‚             The dog barks at the fox. The fox runs away."                   â”‚
â”‚                                                                             â”‚
â”‚   Question: "What did the dog do?"                                          â”‚
â”‚                                                                             â”‚
â”‚   Your brain uses ATTENTION:                                                â”‚
â”‚   - You scan the passage                                                    â”‚
â”‚   - Focus on "dog" mentions                                                 â”‚
â”‚   - Find "The dog barks"                                                    â”‚
â”‚   - Answer: "barked at the fox"                                             â”‚
â”‚                                                                             â”‚
â”‚   THAT'S EXACTLY what the Transformer's attention does,                     â”‚
â”‚   but with math instead of human intuition!                                 â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ”¢ MULTI-HEAD ATTENTION (SmolLM2 has 9 heads)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Instead of ONE attention pattern, the model has MULTIPLE "heads":

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        MULTI-HEAD ATTENTION (9 Heads)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   Each head can learn DIFFERENT patterns:                                   â”‚
â”‚                                                                             â”‚
â”‚   Head 1: Grammar patterns       ("the" usually precedes nouns)            â”‚
â”‚   Head 2: Subject-verb matching  (connect "cat" â†’ "is")                    â”‚
â”‚   Head 3: Coreference ("it" â†’ "cat")                                        â”‚
â”‚   Head 4: Position patterns      (notice word order)                        â”‚
â”‚   Head 5: Semantic similarity    (connect related concepts)                â”‚
â”‚   Head 6-9: Other patterns discovered during training                       â”‚
â”‚                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â”‚   "The cat sat on the mat"                                          â”‚   â”‚
â”‚   â”‚      â”‚   â”‚   â”‚                                                      â”‚   â”‚
â”‚   â”‚      â”‚   â”‚   â””â”€â”€ Head 1: Grammar (article + noun)                   â”‚   â”‚
â”‚   â”‚      â”‚   â”‚                                                          â”‚   â”‚
â”‚   â”‚      â”‚   â””â”€â”€â”€â”€â”€â”€ Head 2: Subject-verb (cat â†’ sat)                   â”‚   â”‚
â”‚   â”‚      â”‚                                                              â”‚   â”‚
â”‚   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Head 3: Position (first noun = likely subject)     â”‚   â”‚
â”‚   â”‚                                                                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚   All 9 heads work IN PARALLEL, then combine their findings!                â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ§® MLP (Multi-Layer Perceptron): The "Thinking" Part
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

After attention, the MLP transforms the information:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              MLP LAYER                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   Input: 576 numbers (from attention)                                       â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Gate Layer: 576 â†’ 1536 (expand)                                    â”‚   â”‚
â”‚   â”‚  [0.2, 0.5, ...] â†’ [0.1, 0.8, 0.2, 0.9, ...]                       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Up Layer: 576 â†’ 1536 (another expansion)                           â”‚   â”‚
â”‚   â”‚  [0.2, 0.5, ...] â†’ [0.3, 0.1, 0.7, 0.4, ...]                       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                    â”‚                                       â”‚
â”‚                â”‚   MULTIPLY (SiLU activation)                               â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚                         â–¼                                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Down Layer: 1536 â†’ 576 (compress back)                             â”‚   â”‚
â”‚   â”‚  [0.03, 0.08, 0.14, ...] â†’ [0.4, 0.6, ...]                         â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                â”‚                                                            â”‚
â”‚                â–¼                                                            â”‚
â”‚   Output: 576 numbers (transformed, ready for next layer!)                  â”‚
â”‚                                                                             â”‚
â”‚   Analogy: Like a filter that extracts and combines features               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ”„ THE GENERATION LOOP (Autoregressive)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Transformers generate text ONE TOKEN AT A TIME:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TEXT GENERATION LOOP (Autoregressive)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   Goal: Complete "The weather is"                                           â”‚
â”‚                                                                             â”‚
â”‚   ITERATION 1:                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Input:  "The weather is"                                            â”‚   â”‚
â”‚   â”‚ Model:  [Transformer 30 layers...]                                  â”‚   â”‚
â”‚   â”‚ Output: Probabilities â†’ "nice" (0.32), "cold" (0.28), "hot" (0.15)  â”‚   â”‚
â”‚   â”‚ Pick:   "nice" â† Highest probability!                               â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚   Result: "The weather is nice"                                             â”‚
â”‚                                                                             â”‚
â”‚   ITERATION 2:                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Input:  "The weather is nice"                                       â”‚   â”‚
â”‚   â”‚ Model:  [Transformer 30 layers...]                                  â”‚   â”‚
â”‚   â”‚ Output: Probabilities â†’ "today" (0.41), "." (0.25), "!" (0.18)      â”‚   â”‚
â”‚   â”‚ Pick:   "today"                                                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚   Result: "The weather is nice today"                                       â”‚
â”‚                                                                             â”‚
â”‚   ITERATION 3:                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Input:  "The weather is nice today"                                 â”‚   â”‚
â”‚   â”‚ Model:  [Transformer 30 layers...]                                  â”‚   â”‚
â”‚   â”‚ Output: Probabilities â†’ "." (0.67), "!" (0.22), "," (0.08)          â”‚   â”‚
â”‚   â”‚ Pick:   "."                                                         â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚   Result: "The weather is nice today."                                      â”‚
â”‚                                                                             â”‚
â”‚   ITERATION 4:                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Input:  "The weather is nice today."                                â”‚   â”‚
â”‚   â”‚ Output: "<|im_end|>" â† END token! STOP generating.                  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚   FINAL: "The weather is nice today."                                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ­ SMOLLM2 SPECIFICATIONS (Used in Taurscribe)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        SmolLM2-135M-Instruct Stats                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   ARCHITECTURE:                                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                             â”‚
â”‚   â€¢ Model Type:         Llama-style Transformer                             â”‚
â”‚   â€¢ Parameters:         135 Million (135M)                                  â”‚
â”‚   â€¢ Layers:             30 transformer blocks                               â”‚
â”‚   â€¢ Hidden Size:        576 dimensions per token                            â”‚
â”‚   â€¢ Attention Heads:    9 heads (parallel attention patterns)               â”‚
â”‚   â€¢ Key/Value Heads:    3 heads (grouped-query attention for efficiency)    â”‚
â”‚   â€¢ MLP Size:           1536 (intermediate expansion)                       â”‚
â”‚   â€¢ Vocabulary:         49,152 tokens                                       â”‚
â”‚   â€¢ Max Context:        8,192 tokens (~6,000 words)                         â”‚
â”‚                                                                             â”‚
â”‚   SIZE COMPARISON:                                                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                          â”‚
â”‚   â€¢ GPT-3:     175 BILLION parameters   (1,300x larger!)                    â”‚
â”‚   â€¢ GPT-4:     ~1.7 TRILLION parameters (12,600x larger!)                   â”‚
â”‚   â€¢ SmolLM2:   135 MILLION parameters   (small enough to run locally!)     â”‚
â”‚                                                                             â”‚
â”‚   MEMORY USAGE:                                                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                             â”‚
â”‚   â€¢ Model weights: ~270 MB (fp32) or ~135 MB (fp16)                         â”‚
â”‚   â€¢ Runtime RAM:   ~500 MB - 1 GB                                           â”‚
â”‚   â€¢ GPU VRAM:      ~500 MB (fits on almost any GPU!)                        â”‚
â”‚                                                                             â”‚
â”‚   PERFORMANCE:                                                              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                              â”‚
â”‚   â€¢ CPU: ~5-10 tokens/second                                                â”‚
â”‚   â€¢ GPU (CUDA): ~50-100 tokens/second                                       â”‚
â”‚   â€¢ Grammar correction latency: 1-3 seconds typically                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ğŸ” BURGER RESTAURANT ANALOGY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The Transformer is like a fancy burger restaurant:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   TRANSFORMER = BURGER RESTAURANT                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚   CUSTOMER ORDER: "hello wrold" (needs grammar correction)                  â”‚
â”‚                                                                             â”‚
â”‚   1. ğŸ“¥ ORDERING SYSTEM (Tokenizer)                                         â”‚
â”‚      "hello wrold" â†’ Order Ticket #[15339, 9923, 820]                       â”‚
â”‚                                                                             â”‚
â”‚   2. ğŸ INGREDIENT PREP (Embedding Layer)                                   â”‚
â”‚      Each order number â†’ Specific ingredients ready                         â”‚
â”‚      Token 15339 â†’ [bun, lettuce, tomato, ...]                             â”‚
â”‚                                                                             â”‚
â”‚   3. ğŸ‘¨â€ğŸ³ CHEF STATIONS (30 Transformer Layers)                              â”‚
â”‚      Each chef adds something:                                              â”‚
â”‚        â€¢ Chef 1: Checks grammar context                                     â”‚
â”‚        â€¢ Chef 2: Understands word relationships                            â”‚
â”‚        â€¢ Chef 3: Figures out corrections needed                            â”‚
â”‚        â€¢ ... (30 chefs total!)                                              â”‚
â”‚                                                                             â”‚
â”‚   4. ğŸ¯ ATTENTION (Quality Control)                                         â”‚
â”‚      "Wait, 'wrold' looks wrong. Let me check 'hello' context..."         â”‚
â”‚      â†’ Realizes it should be 'world'!                                       â”‚
â”‚                                                                             â”‚
â”‚   5. ğŸ“¤ OUTPUT WINDOW (LM Head)                                             â”‚
â”‚      "Here's your corrected order: 'Hello world.'"                          â”‚
â”‚                                                                             â”‚
â”‚   6. ğŸ” FINAL PRODUCT (Decoded Text)                                        â”‚
â”‚      Token IDs â†’ "Hello world."                                             â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Downloaded from**: `huggingface.co/HuggingFaceTB/SmolLM2-135M-Instruct`

---

### ğŸ”¬ Code Deep Dive: llm.rs

Let's go through EVERY function in detail:

#### **1. GpuBackend Enum**
```rust
#[derive(Debug, Clone, Serialize)]
pub enum GpuBackend {
    Cuda,   // NVIDIA GPU acceleration
    Cpu,    // Fallback CPU mode
}
```
**Why?**: Track which compute device we're using. Could be extended to add `Metal` (Apple) or `Vulkan` in the future.

---

#### **2. SmolLM2Config Struct (Hugging Face Format)**
```rust
#[derive(Debug, Clone, Deserialize)]
struct SmolLM2Config {
    hidden_size: usize,           // 576 - Size of hidden layers
    intermediate_size: usize,     // 1536 - Size of feed-forward layers
    vocab_size: usize,            // 49152 - Number of tokens in vocabulary
    num_hidden_layers: usize,     // 30 - Number of transformer blocks
    num_attention_heads: usize,   // 9 - Number of attention heads
    num_key_value_heads: Option<usize>,  // 3 - For grouped-query attention
    rms_norm_eps: f64,            // 1e-05 - Epsilon for RMS normalization
    rope_theta: f32,              // 100000 - RoPE position encoding base
    use_flash_attn: bool,         // false - Flash attention optimization
    bos_token_id: u32,            // 0 - Beginning-of-sequence token ID
    eos_token_id: u32,            // 0 - End-of-sequence token ID
    max_position_embeddings: usize, // 8192 - Maximum context length
    tie_word_embeddings: bool,    // true - Share input/output embeddings
}
```

**Why a separate struct?**: Hugging Face config.json has different field names than candle-transformers expects. We deserialize to this struct, then convert to candle's `Config`.

---

#### **3. Config Conversion (From Trait)**
```rust
impl From<SmolLM2Config> for Config {
    fn from(cfg: SmolLM2Config) -> Self {
        Config {
            hidden_size: cfg.hidden_size,
            intermediate_size: cfg.intermediate_size,
            vocab_size: cfg.vocab_size,
            num_hidden_layers: cfg.num_hidden_layers,
            num_attention_heads: cfg.num_attention_heads,
            num_key_value_heads: cfg.num_key_value_heads.unwrap_or(cfg.num_attention_heads),
            rms_norm_eps: cfg.rms_norm_eps,
            rope_theta: cfg.rope_theta,
            use_flash_attn: cfg.use_flash_attn,
            bos_token_id: Some(cfg.bos_token_id),
            eos_token_id: Some(LlamaEosToks::Single(cfg.eos_token_id)),  // SPECIAL WRAPPER!
            max_position_embeddings: cfg.max_position_embeddings,
            rope_scaling: None,  // No RoPE scaling for SmolLM2
            tie_word_embeddings: cfg.tie_word_embeddings,
        }
    }
}
```

**Key Issue Solved**: `eos_token_id` required `LlamaEosToks::Single()` wrapper because candle supports models with multiple EOS tokens (like Llama 3).

---

#### **4. LlmManager Struct**
```rust
pub struct LlmManager {
    model: Option<Llama>,         // The actual neural network
    tokenizer: Option<Tokenizer>, // Text â†” token converter
    cache: Option<Cache>,         // KV-cache for efficient generation
    device: Device,               // CPU or CUDA
    backend: GpuBackend,          // Track which device we're using
    model_id: Option<String>,     // "smollm2-135m"
    config: Option<Config>,       // Model configuration
}
```

**Design Pattern**: All fields are `Option<T>` because initialization happens after construction. This is a common pattern in Rust for "builder-style" objects.

---

#### **5. get_models_dir() - Model Discovery**
```rust
fn get_models_dir() -> Result<PathBuf> {
    let possible_paths = [
        "taurscribe-runtime/models/llm",
        "../taurscribe-runtime/models/llm",
        "../../taurscribe-runtime/models/llm",
    ];

    for path in possible_paths {
        if let Ok(canonical) = std::fs::canonicalize(path) {
            if canonical.is_dir() {
                return Ok(canonical);
            }
        }
    }

    Err(anyhow!("Could not find LLM models directory"))
}
```

**Pattern Reused**: Same discovery pattern as `WhisperManager::get_models_dir()` and `ParakeetManager::get_models_dir()`. Checks relative paths because the working directory varies between dev and production.

---

#### **6. initialize() - Model Loading**
```rust
pub fn initialize(&mut self) -> Result<String> {
    let models_dir = Self::get_models_dir()?;

    // Platform-specific CUDA detection
    #[cfg(all(target_os = "windows", target_arch = "x86_64"))]
    {
        if let Ok(device) = Device::new_cuda(0) {
            println!("[LLM] CUDA device available");
            self.device = device;
            self.backend = GpuBackend::Cuda;
        } else {
            println!("[LLM] CUDA not available, using CPU");
            self.device = Device::Cpu;
            self.backend = GpuBackend::Cpu;
        }
    }
    // ... similar for Linux ...
    
    // Load model files
    let config_str = std::fs::read_to_string(&config_path)?;
    let smol_config: SmolLM2Config = serde_json::from_str(&config_str)?;
    let config: Config = smol_config.into();

    let tokenizer = Tokenizer::from_file(&tokenizer_path)
        .map_err(|e| anyhow!("{}", e))?;

    // Memory-map weights for efficiency (doesn't load entire file into RAM)
    let vb = unsafe {
        VarBuilder::from_mmaped_safetensors(&[weights_path], DType::F32, &self.device)?
    };

    // Create the model (loads weights into GPU/CPU memory)
    let model = Llama::load(vb, &config)?;
    
    // Create KV-cache for efficient token generation
    let cache = Cache::new(true, DType::F32, &config, &self.device)?;

    // Store everything
    self.model = Some(model);
    self.tokenizer = Some(tokenizer);
    self.cache = Some(cache);
    self.config = Some(config);
    self.model_id = Some("smollm2-135m".to_string());

    Ok(format!("SmolLM2 loaded on {:?}", self.backend))
}
```

**Key Concepts Explained**:

1. **`#[cfg(all(target_os = "windows", target_arch = "x86_64"))]`** - Conditional compilation. This code ONLY runs on Windows x64. Different code runs on Linux, macOS, ARM, etc.

2. **`Device::new_cuda(0)`** - Tries to create a CUDA device (GPU index 0). Returns `Err` if no NVIDIA GPU or drivers available.

3. **`VarBuilder::from_mmaped_safetensors()`** - Memory-maps the safetensors file. This is marked `unsafe` because it assumes the file won't change while mapped.

4. **`Cache::new(true, DType::F32, &config, &self.device)`** - Creates KV-cache for transformer. The `true` means "use cache" (vs. recomputing attention every time).

---

#### **7. generate_correction() - Text Generation**
```rust
pub fn generate_correction(&mut self, text: &str) -> Result<String> {
    // Get references to model components
    let model = self.model.as_ref().ok_or_else(|| anyhow!("Model not initialized"))?;
    let tokenizer = self.tokenizer.as_ref().ok_or_else(|| anyhow!("Tokenizer not initialized"))?;
    let cache = self.cache.as_mut().ok_or_else(|| anyhow!("Cache not initialized"))?;

    // Build the prompt using ChatML format
    let prompt = format!(
        "<|im_start|>system\nFix grammar errors. Output only the corrected text.<|im_end|>\n\
         <|im_start|>user\n{}<|im_end|>\n\
         <|im_start|>assistant\n",
        text
    );

    // Tokenize the prompt
    let encoding = tokenizer.encode(prompt, true).map_err(|e| anyhow!("{}", e))?;
    let mut tokens: Vec<u32> = encoding.get_ids().to_vec();

    // Create sampler with temperature=0.3 (low = more deterministic)
    let mut logits_processor = LogitsProcessor::new(42, Some(0.3), None);
    let mut result_tokens: Vec<u32> = Vec::new();

    // Get the end token ID
    let eos_id = tokenizer.token_to_id("<|im_end|>").unwrap_or(2);

    // Autoregressive generation loop
    for i in 0..100 {  // Max 100 new tokens
        // Context size: full prompt on first iteration, then just last token
        let context_size = if i > 0 { 1 } else { tokens.len() };
        let start_pos = tokens.len().saturating_sub(context_size);
        
        // Create input tensor
        let input = Tensor::new(&tokens[start_pos..], &self.device)?.unsqueeze(0)?;

        // Run forward pass through the model
        let logits = model.forward(&input, start_pos, cache)?;
        
        // Get logits for the last token position
        let logits = logits.squeeze(0)?;
        let logits = logits.get(logits.dim(0)? - 1)?;

        // Sample next token
        let next_token = logits_processor.sample(&logits)?;
        tokens.push(next_token);
        result_tokens.push(next_token);

        // Stop if we hit the end token
        if next_token == eos_id {
            break;
        }
    }

    // Decode tokens back to text
    let decoded = tokenizer.decode(&result_tokens, true).map_err(|e| anyhow!("{}", e))?;

    Ok(decoded.trim().to_string())
}
```

**Autoregressive Generation Explained**:

```
Initial tokens: [<|im_start|>, system, Fix, grammar, ..., assistant, \n]
                                                                      â†“
                                                              Model predicts "The"
                                                                      â†“
Tokens now:     [<|im_start|>, system, Fix, grammar, ..., assistant, \n, The]
                                                                          â†“
                                                              Model predicts "quick"
                                                                          â†“
Tokens now:     [..., \n, The, quick]
                                 â†“
                     Continue until <|im_end|>
```

**KV-Cache Optimization**:
- On first iteration: Process ALL tokens (expensive)
- On subsequent iterations: Process ONLY the new token (cheap)
- The `cache` stores key/value matrices from previous iterations
- This is why `start_pos` is passed to `forward()`

---

### ğŸ› ï¸ Integration with Tauri

#### **1. State Management (state.rs)**
```rust
pub struct AudioState {
    // ... existing fields ...
    pub llm: Arc<Mutex<crate::llm::LlmManager>>,  // NEW!
}

impl AudioState {
    pub fn new(
        whisper: Arc<Mutex<WhisperManager>>,
        parakeet: Arc<Mutex<ParakeetManager>>,
        vad: Arc<Mutex<VadManager>>,
        llm: Arc<Mutex<LlmManager>>,  // NEW!
    ) -> Self {
        // ...
    }
}
```

**Why Arc<Mutex>?**: The LlmManager needs to be:
- Shared across threads (`Arc` = Atomic Reference Counting)
- Mutably accessed by multiple commands (`Mutex` = Mutual Exclusion lock)

---

#### **2. Initialization (lib.rs)**
```rust
pub fn run() {
    // Initialize Whisper...
    // Initialize Parakeet...
    // Initialize VAD...
    
    // NEW: Initialize LLM
    println!("[INFO] Initializing LLM for grammar correction...");
    let mut llm = LlmManager::new();
    match llm.initialize() {
        Ok(msg) => println!("[SUCCESS] {}", msg),
        Err(e) => println!("[WARN] LLM not available: {}", e),
    }
    let llm = Arc::new(Mutex::new(llm));

    // Create state with all managers
    let state = AudioState::new(whisper, parakeet, vad, llm);

    tauri::Builder::default()
        .manage(state)  // Register with Tauri
        .invoke_handler(tauri::generate_handler![
            // ... existing commands ...
            commands::correct_text,  // NEW!
        ])
        // ...
}
```

---

#### **3. Tauri Command (commands/transcription.rs)**
```rust
#[tauri::command]
pub fn correct_text(state: State<AudioState>, text: String) -> Result<String, String> {
    let mut llm = state.llm.lock().map_err(|e| e.to_string())?;
    llm.generate_correction(&text).map_err(|e| e.to_string())
}
```

**How Tauri Commands Work**:
1. Frontend calls `invoke("correct_text", { text: "hello wrold" })`
2. Tauri deserializes arguments
3. Injects `State<AudioState>` automatically
4. Calls this function
5. Serializes return value back to frontend

---

#### **4. Frontend Usage (App.tsx)**
```typescript
const [isCorrecting, setIsCorrecting] = useState(false);

const handleGrammarCorrection = async () => {
    if (!content.trim()) return;
    setIsCorrecting(true);
    try {
        const corrected = await invoke<string>("correct_text", { text: content });
        setContent(corrected);
    } catch (error) {
        console.error("Grammar correction failed:", error);
    } finally {
        setIsCorrecting(false);
    }
};

// JSX
<button 
    className="btn-correct" 
    onClick={handleGrammarCorrection}
    disabled={isCorrecting || !content.trim()}
>
    {isCorrecting ? "Correcting..." : "âœ¨ Correct Grammar"}
</button>
```

---

### âš ï¸ Issues Encountered & Solutions

#### **Issue 1: TokenOutputStream Not Found**
```
error[E0433]: failed to resolve: could not find `TokenOutputStream` in `generation`
```
**Solution**: `candle-transformers 0.9.2` uses a different API. Used `tokenizer.decode()` directly instead.

---

#### **Issue 2: Missing Config Fields**
```
error[E0063]: missing fields `bos_token_id`, `eos_token_id`, `max_position_embeddings`...
```
**Solution**: The `candle_transformers::models::llama::Config` struct requires more fields than our initial config. Added all required fields to `From<SmolLM2Config>` implementation.

---

#### **Issue 3: LlamaEosToks Type Mismatch**
```
error[E0308]: mismatched types - expected `LlamaEosToks`, found `u32`
```
**Solution**: Llama 3 models can have multiple EOS tokens. Wrapped single token in `LlamaEosToks::Single(u32)`.

---

#### **Issue 4: NVCC Compilation Error**
```
nvcc error while compiling "src\\affine.cu"
```
**Problem**: Candle's default features try to compile CUDA kernels, which requires `nvcc` in PATH.
**Solution**: Use `default-features = false` for candle crates:
```toml
candle-core = { version = "0.9.2", default-features = false }
```
**Note**: CUDA still works! The pre-compiled CUDA support is still available via cudarc.

---

#### **Issue 5: Windows Linker Error - Runtime Library Mismatch** ğŸ—ï¸

```
error LNK2038: mismatch detected for 'RuntimeLibrary': 
value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease'

LINK : fatal error LNK1319: 1 mismatches detected
```

**What Happened**: The Windows linker refused to build our application because different parts of the code were trying to use different "power sources" for basic operations like memory management.

---

**ğŸ—ï¸ The Building Analogy: Two Power Systems**

Think of your software project as a **construction site** building an office tower (Taurscribe):

1. **The City Power Grid (Dynamic Runtime `/MD`)** ğŸ™ï¸
   - Shared electrical system everyone plugs into
   - Efficient because everyone shares one source
   - Standard for modern Windows applications
   - Files: `msvcrt.lib` (import) / `msvcrt.dll` (runtime)

2. **Private Diesel Generator (Static Runtime `/MT`)** âš¡
   - Each contractor brings their own generator
   - Self-contained but heavy
   - Used for standalone tools
   - Files: `libcmt.lib` (everything bundled in)

**The Conflict**: 
- **Our Main App (Rust)**: "We're using the City Grid (`/MD`)"
- **Whisper Library**: "Great, we're also on the Grid! (`/MD`)"
- **ESAxx Library (inside tokenizers)**: "Wait, I brought my own Generator! (`/MT`)"

The **Site Foreman (Windows Linker)** said: 
> "STOP! You can't wire half the building to the city grid and half to a private generator! If someone allocates memory on the grid and tries to free it via the generator circuit, THE BUILDING EXPLODES! ğŸ’¥"

---

**ğŸ” Why This Matters (Technical Details)**

The **C Runtime Library (CRT)** provides basic services every program needs:
- Memory allocation (`malloc`, `free`)
- File I/O (`fopen`, `fclose`)
- String operations (`strlen`, `strcpy`)
- Math functions (`sin`, `cos`, `sqrt`)

**There are 4 versions of the CRT on Windows:**

| Library | Type | Debug? | Flag |
|---------|------|--------|------|
| `libcmt.lib` | Static | No | `/MT` |
| `libcmtd.lib` | Static | Yes | `/MTd` |
| `msvcrt.lib` | Dynamic (import) | No | `/MD` |
| `msvcrtd.lib` | Dynamic (import) | Yes | `/MDd` |

**What went wrong:**
1. **Rust** defaults to `/MD` (dynamic) when building DLLs
2. **whisper-rs** (C++ dependency) compiled with `/MD` âœ…
3. **esaxx-rs** (C++ dependency) compiled with `/MT` âŒ

**The Danger**: If you mix them:
```
1. esaxx allocates memory using its static runtime (generator)
2. esaxx hands that pointer to your main app
3. Your main app tries to free() it using the dynamic runtime (grid)
4. CRASH! The grid manager says "I didn't create this memory!"
```

---

**âœ… The Solution: Force Everyone to Use the Grid**

Instead of trying to make esaxx rebuild from source with different flags (very difficult), we told the C++ compiler:

> "When building ANY C++ dependency (including esaxx), always use the Dynamic Runtime."

**Added to `.cargo/config.toml`:**
```toml
[target.x86_64-pc-windows-msvc]
rustflags = [
    "-L",
    "C:/Users/abdul/OneDrive/Desktop/Taurscribe/taurscribe-runtime/bin",
    "-C", "link-arg=/NODEFAULTLIB:LIBCMT",  # â† Ignore the static library
]

[env]
CFLAGS = "/MD"      # â† Force C dependencies to use Dynamic Runtime
CXXFLAGS = "/MD"    # â† Force C++ dependencies to use Dynamic Runtime
```

**What each flag does:**

1. **`/NODEFAULTLIB:LIBCMT`**: 
   - Tells the linker: "If you see instructions to use the static library, ignore them."
   - It's like cutting the cord to the diesel generator

2. **`CFLAGS = "/MD"` and `CXXFLAGS = "/MD"`**:
   - Environment variables that get passed to ALL C/C++ builds
   - Forces every library to compile with the Dynamic Runtime flag
   - Now when cargo rebuilds esaxx, it uses `/MD` instead of `/MT`

**Result**: 
- âœ… Main App: Dynamic (`/MD`)
- âœ… Whisper: Dynamic (`/MD`) 
- âœ… Esaxx: **NOW Dynamic** (`/MD`) â† Fixed!
- âœ… All other C++ deps: Dynamic (`/MD`)

Everyone is now plugged into the same power source! The linker is happy. ğŸ‰

---

**ğŸ“ Key Lessons Learned:**

1. **Windows DLLs should always use Dynamic Runtime** (`/MD`)
   - This is the standard and avoids these conflicts

2. **Mixing `/MT` and `/MD` in a DLL is undefined behavior**
   - Even if it links, it can crash at runtime

3. **Cargo build scripts respect `CFLAGS`/`CXXFLAGS`**
   - Setting these in `.cargo/config.toml` affects ALL C/C++ dependencies
   - This is how we fixed esaxx without modifying its source code

4. **The linker is protecting you!**
   - `LNK1319` seems annoying, but it prevents memory corruption bugs
   - Always take linker errors seriously on Windows

---

**ğŸ”§ Alternative Approaches We Tried (and why they failed):**

**Attempt 1**: Use `/NODEFAULTLIB:LIBCMT` alone
```toml
rustflags = ["-C", "link-arg=/NODEFAULTLIB:LIBCMT"]
```
âŒ **Failed**: The linker still detected the metadata mismatch in the `.obj` files before even looking at libraries.

**Attempt 2**: Force everything to Static (`+crt-static`)
```toml
rustflags = ["-C", "target-feature=+crt-static"]
```
âŒ **Failed catastrophically**: 90 new linker errors!
- Missing symbols: `__imp_tgammaf`, `__imp_copysignf`, `__imp_modff`, etc.
- Why? Whisper and ONNX Runtime were compiled expecting dynamic CRT
- They couldn't find basic math functions in the static library

**Attempt 3**: âœ… **Current solution** - Force C/C++ to Dynamic
```toml
CFLAGS = "/MD"
CXXFLAGS = "/MD"
```
âœ… **Success**: Everyone uses the same runtime from the start.

---

This forces ALL C/C++ dependencies to use dynamic CRT from compilation, not just at link time.

---

### ğŸ“Š Performance Characteristics

| Metric | Value |
|--------|-------|
| Model Size | 135M parameters |
| Weights Size | ~270 MB (safetensors) |
| Loading Time | ~2-3 seconds (first load) |
| Inference Speed (GPU) | ~50 tokens/second |
| Inference Speed (CPU) | ~5 tokens/second |
| Max Context Length | 8192 tokens |
| Typical Correction | 50-200ms |

---

### ğŸ§  How Transformers Work (Simplified)

```
INPUT: "hello wrold this is a tset"
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TOKENIZER                                                     â”‚
â”‚ Converts text to numbers that the model understands           â”‚
â”‚ "hello" â†’ 1234, "wrold" â†’ 5678, ...                          â”‚
â”‚ Result: [1234, 5678, 9012, 3456, 7890, 2345]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EMBEDDING LAYER                                               â”‚
â”‚ Converts each token ID to a vector (576 numbers)              â”‚
â”‚ 1234 â†’ [0.01, -0.02, 0.03, ..., 0.15]                        â”‚
â”‚ Result: Matrix of shape [6 tokens Ã— 576 dimensions]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TRANSFORMER LAYERS (Ã—30)                                      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ATTENTION                                                â”‚ â”‚
â”‚  â”‚ "Which words are related to each other?"                 â”‚ â”‚
â”‚  â”‚ "wrold" pays attention to "hello" (context)              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                    â”‚                                          â”‚
â”‚                    â–¼                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ FEED-FORWARD NETWORK (MLP)                              â”‚ â”‚
â”‚  â”‚ "What transformation should we apply?"                   â”‚ â”‚
â”‚  â”‚ 576 â†’ 1536 â†’ 576 (expand then compress)                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                               â”‚
â”‚  (Repeat 30 times for deep understanding)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OUTPUT LAYER                                                  â”‚
â”‚ Predicts the next token                                       â”‚
â”‚ Result: Probability distribution over 49,152 tokens           â”‚
â”‚ P("world") = 0.85, P("word") = 0.10, ...                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SAMPLING (LogitsProcessor)                                    â”‚
â”‚ Pick the most likely token (with temperature=0.3)             â”‚
â”‚ Selected: "Hello"                                             â”‚
â”‚                                                               â”‚
â”‚ Then repeat for next token, and next, until <|im_end|>       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
OUTPUT: "Hello world, this is a test."
```

---

### ğŸ”® Future Improvements

1. **Multiple Models**: Support larger SmolLM2 variants (360M, 1.7B)
2. **Streaming Output**: Show corrections as they generate
3. **Context Awareness**: Use previous transcript for better corrections
4. **Custom Instructions**: Let users customize the correction style
5. **DirectML Support**: Add DirectML backend for AMD GPUs on Windows

---

## ğŸ¤ COMPLETE AUDIO PIPELINE: From Button Click to Transcription

This section answers ALL your questions about how audio recording and transcription works in Taurscribe!

### ğŸ“ Table of Contents

1. [Where Does the Code Start?](#where-does-the-code-start)
2. [How Does Recording Start?](#how-does-recording-start)
3. [How is Audio Captured?](#how-is-audio-captured)
4. [How is Audio Sent to Whisper?](#how-is-audio-sent-to-whisper)
5. [How is Audio Fed into Whisper Model?](#how-is-audio-fed-into-whisper-model)
6. [How is Audio Sent to Parakeet?](#how-is-audio-sent-to-parakeet)
7. [How is Audio Fed into Parakeet Model?](#how-is-audio-fed-into-parakeet-model)
8. [How is Text Outputted?](#how-is-text-outputted)
9. [Complete Visual Flow](#complete-visual-flow)

---

### ğŸš¦ Where Does the Code Start?

**The journey begins when YOU click the microphone button!**

#### ğŸ“ Location: `src/App.tsx` (Line 168)

```tsx
const res = await invoke("start_recording");
```

**What happens here:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: USER INTERACTION                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  You (User) clicks: [ğŸ¤ Start Recording]                â”‚
â”‚                                                          â”‚
â”‚  React Event Handler fires:                             â”‚
â”‚  â”œâ”€ Sets isRecording = true                             â”‚
â”‚  â”œâ”€ Updates UI (button turns red)                       â”‚
â”‚  â””â”€ Calls: invoke("start_recording")                    â”‚
â”‚                                                          â”‚
â”‚  What is invoke()?                                       â”‚
â”‚  âœ Tauri's "magic bridge" function                      â”‚
â”‚  âœ Sends message from JavaScript â†’ Rust backend         â”‚
â”‚  âœ Like calling a phone: "Hey backend, start recording!"â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
   (Travels through Tauri IPC bridge...)
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RUST BACKEND RECEIVES THE CALL                         â”‚
â”‚  ğŸ“ src-tauri/src/commands/recording.rs (Line 12)       â”‚
â”‚                                                          â”‚
â”‚  #[tauri::command]                                       â”‚
â”‚  pub fn start_recording(...)                            â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy**: You pressing a doorbell (button click) that sends an electric signal (invoke) through wires (Tauri IPC) to ring a bell (Rust function) inside the house (backend).

---

### ğŸ¬ How Does Recording Start?

#### ğŸ“ Location: `src-tauri/src/commands/recording.rs` (Lines 13-272)

The `start_recording` function is the **control center** that sets up everything. Let's break it down step-by-step:

```rust
#[tauri::command]
pub fn start_recording(
    app_handle: AppHandle,
    state: State<AudioState>,
) -> Result<String, String>
```

**Step-by-Step Breakdown:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Setup Microphone (Lines 17-23)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  let host = cpal::default_host();                            â”‚
â”‚  let device = host.default_input_device()                    â”‚
â”‚                                                               â”‚
â”‚  What's happening:                                            â”‚
â”‚  â”œâ”€ Ask the OS: "Which microphone should I use?"            â”‚
â”‚  â”œâ”€ Get the default mic (the one you selected in settings)   â”‚
â”‚  â””â”€ Get its config (sample rate, channels, etc.)            â”‚
â”‚                                                               â”‚
â”‚  Analogy: Finding the restaurant's supplier                  â”‚
â”‚  "Which farm delivers fresh vegetables?"                     â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Prepare Output File (Lines 25-30)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  let filename = format!(                                      â”‚
â”‚      "recording_{}.wav",                                      â”‚
â”‚      chrono::Utc::now().timestamp()                          â”‚
â”‚  );                                                           â”‚
â”‚  let path = recordings_dir.join(&filename);                  â”‚
â”‚                                                               â”‚
â”‚  Example: "recording_1738368000.wav"                         â”‚
â”‚                                                               â”‚
â”‚  Analogy: Getting a fresh notepad                            â”‚
â”‚  "I need a new notebook to write in!"                        â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Reset AI Context (Lines 32-41)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  if active_engine == ASREngine::Whisper {                    â”‚
â”‚      state.whisper.lock().unwrap().clear_context();         â”‚
â”‚  } else {                                                     â”‚
â”‚      state.parakeet.lock().unwrap().clear_context();        â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  Why? Start fresh for new recording!                         â”‚
â”‚  The AI needs to "forget" the previous conversation.         â”‚
â”‚                                                               â”‚
â”‚  Analogy: Erasing the blackboard                             â”‚
â”‚  "Clear the board before starting new lesson!"               â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Create Communication Pipes (Lines 54-55)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  let (file_tx, file_rx) = unbounded::<Vec<f32>>();          â”‚
â”‚  let (whisper_tx, whisper_rx) = unbounded::<Vec<f32>>();    â”‚
â”‚                                                               â”‚
â”‚  What are these?                                              â”‚
â”‚  âœ CHANNELS! Think: Garden hoses for data                   â”‚
â”‚  âœ tx = Transmitter (sends data)                            â”‚
â”‚  âœ rx = Receiver (receives data)                            â”‚
â”‚                                                               â”‚
â”‚  Two separate pipes:                                          â”‚
â”‚  1. file_tx â†’ file_rx (saves audio to disk)                 â”‚
â”‚  2. whisper_tx â†’ whisper_rx (sends to AI)                   â”‚
â”‚                                                               â”‚
â”‚  Analogy: Setting up conveyor belts                          â”‚
â”‚  Belt 1: Raw food â†’ Freezer                                  â”‚
â”‚  Belt 2: Raw food â†’ Chef (for cooking)                       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Spawn File Saver Thread (Lines 62-72)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  std::thread::spawn(move || {                                â”‚
â”‚      let mut writer = writer;                                â”‚
â”‚      while let Ok(samples) = file_rx.recv() {                â”‚
â”‚          for sample in samples {                             â”‚
â”‚              writer.write_sample(sample).ok();               â”‚
â”‚          }                                                    â”‚
â”‚      }                                                        â”‚
â”‚      writer.finalize().ok();                                 â”‚
â”‚  });                                                          â”‚
â”‚                                                               â”‚
â”‚  What's happening:                                            â”‚
â”‚  â”œâ”€ Create a NEW background thread                           â”‚
â”‚  â”œâ”€ This thread WAITS for audio data on file_rx             â”‚
â”‚  â”œâ”€ When data arrives, write it to WAV file                  â”‚
â”‚  â””â”€ Runs in parallel with everything else!                   â”‚
â”‚                                                               â”‚
â”‚  Analogy: Hiring a dedicated recorder                        â”‚
â”‚  "Your only job: Write down everything on tape!"             â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 6: Spawn Transcriber Thread (Lines 82-235)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  std::thread::spawn(move || {                                â”‚
â”‚      let mut buffer = Vec::new();                            â”‚
â”‚      while let Ok(samples) = whisper_rx.recv() {             â”‚
â”‚          buffer.extend(samples);                             â”‚
â”‚                                                               â”‚
â”‚          // Process in chunks...                             â”‚
â”‚          if active_engine == ASREngine::Whisper {            â”‚
â”‚              // Whisper path (we'll detail this later)       â”‚
â”‚          } else {                                             â”‚
â”‚              // Parakeet path (we'll detail this later)      â”‚
â”‚          }                                                    â”‚
â”‚      }                                                        â”‚
â”‚  });                                                          â”‚
â”‚                                                               â”‚
â”‚  What's happening:                                            â”‚
â”‚  â”œâ”€ Create ANOTHER background thread                         â”‚
â”‚  â”œâ”€ This thread WAITS for audio data on whisper_rx          â”‚
â”‚  â”œâ”€ Collects audio into a buffer (basket)                    â”‚
â”‚  â”œâ”€ When buffer is full enough, send to AI!                  â”‚
â”‚  â””â”€ Emits results back to frontend                           â”‚
â”‚                                                               â”‚
â”‚  Analogy: Hiring a translator                                â”‚
â”‚  "Listen to everything and translate in real-time!"          â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 7: Start Microphone Stream (Lines 240-263)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  let stream = device.build_input_stream(                     â”‚
â”‚      &config,                                                 â”‚
â”‚      move |data: &[f32], _: &_| {                            â”‚
â”‚          // THIS CALLBACK RUNS EVERY 10ms!                   â”‚
â”‚          file_tx_clone.send(data.to_vec()).ok();             â”‚
â”‚          whisper_tx_clone.send(mono_data).ok();              â”‚
â”‚      },                                                       â”‚
â”‚      ...                                                      â”‚
â”‚  )?;                                                          â”‚
â”‚                                                               â”‚
â”‚  stream.play()?; // ğŸ¬ START RECORDING!                      â”‚
â”‚                                                               â”‚
â”‚  What's happening:                                            â”‚
â”‚  â”œâ”€ Tell the microphone: "Start capturing!"                  â”‚
â”‚  â”œâ”€ EVERY 10 MILLISECONDS, the callback fires                â”‚
â”‚  â”œâ”€ Each time: Get ~480 samples (10ms of audio)              â”‚
â”‚  â”œâ”€ Send copies to BOTH channels (file + transcriber)        â”‚
â”‚  â””â”€ This keeps running until we call stream.stop()           â”‚
â”‚                                                               â”‚
â”‚  Analogy: Opening the water faucet                           â”‚
â”‚  Water (audio) now flows continuously!                       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**The Result**: Three things are now running in parallel!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ğŸ¤ MICROPHONE THREAD                            â”‚
â”‚         Captures audio every 10ms                       â”‚
â”‚              â†“                                          â”‚
â”‚         Sends to channels                               â”‚
â”‚              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚              â†“                  â†“                       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚    â”‚ ğŸ’¾ FILE SAVER   â”‚   â”‚ ğŸ§  TRANSCRIBER   â”‚         â”‚
â”‚    â”‚    THREAD       â”‚   â”‚     THREAD       â”‚         â”‚
â”‚    â”‚                 â”‚   â”‚                  â”‚         â”‚
â”‚    â”‚ Writes to disk  â”‚   â”‚ Sends to AI      â”‚         â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                         â”‚
â”‚    ALL RUNNING AT THE SAME TIME! âš¡                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ™ï¸ How is Audio Captured?

#### ğŸ“ Location: `src-tauri/src/commands/recording.rs` (Lines 243-254)

This is the **audio callback** - the heart of the recording system!

```rust
move |data: &[f32], _: &_| {
    // Send raw audio to file
    file_tx_clone.send(data.to_vec()).ok();
    
    // Convert stereo â†’ mono
    let mono_data: Vec<f32> = if channels > 1 {
        data.chunks(channels)
            .map(|chunk| chunk.iter().sum::<f32>() / channels as f32)
            .collect()
    } else {
        data.to_vec()
    };
    
    // Send mono audio to transcriber
    whisper_tx_clone.send(mono_data).ok();
}
```

**Breaking It Down:**

```
EVERY 10 MILLISECONDS (100 times per second):

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AUDIO CALLBACK FIRES                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  Input: data = [0.001, 0.002, -0.001, 0.003, ...]           â”‚
â”‚         â†‘ Array of audio samples (floating point numbers)    â”‚
â”‚         â†‘ Each number = microphone membrane position         â”‚
â”‚         â†‘ Range: -1.0 (fully in) to +1.0 (fully out)        â”‚
â”‚                                                               â”‚
â”‚  Typical size: ~480 samples for 10ms at 48kHz                â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Send to File Saver                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  file_tx_clone.send(data.to_vec()).ok();                     â”‚
â”‚                                                               â”‚
â”‚  What happens:                                                â”‚
â”‚  1. Clone the audio data (make a copy)                       â”‚
â”‚  2. Send it through the file_tx channel                      â”‚
â”‚  3. File saver thread receives it                            â”‚
â”‚  4. Writes to WAV file                                        â”‚
â”‚                                                               â”‚
â”‚  Why clone? We need TWO copies (file + AI)!                  â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Convert Stereo â†’ Mono                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  Why? AI models expect MONO (1 channel) audio!               â”‚
â”‚                                                               â”‚
â”‚  Stereo (2 channels):                                         â”‚
â”‚  [L1, R1, L2, R2, L3, R3, ...]                               â”‚
â”‚   â†‘   â†‘   â†‘   â†‘   â†‘   â†‘                                      â”‚
â”‚  Left Right ...                                               â”‚
â”‚                                                               â”‚
â”‚  Conversion Formula: (Left + Right) / 2                      â”‚
â”‚                                                               â”‚
â”‚  data.chunks(2)  â† Split into pairs: [L1, R1], [L2, R2] ...â”‚
â”‚      .map(|chunk| {                                           â”‚
â”‚          (chunk[0] + chunk[1]) / 2.0  â† Average them         â”‚
â”‚      })                                                       â”‚
â”‚                                                               â”‚
â”‚  Result (mono):                                               â”‚
â”‚  [M1, M2, M3, ...]                                            â”‚
â”‚   â†‘   â†‘   â†‘                                                   â”‚
â”‚  Averaged samples                                             â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Send to Transcriber                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  whisper_tx_clone.send(mono_data).ok();                      â”‚
â”‚                                                               â”‚
â”‚  The mono audio travels through the channel...               â”‚
â”‚  Arrives at the Transcriber Thread!                          â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Visual Flow:**

```
ğŸ¤ Microphone captures sound waves
     â†“
   [Audio Hardware ADC]
     â†“
   Digital samples (10ms chunks)
     â†“
     ğŸ“¦ [0.001, -0.002, 0.003, ...]
     â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                    â”‚
     â–¼                    â–¼
 ğŸ’¾ File Saver      ğŸ§  Transcriber
 (Stereo)           (Mono)
     â”‚                    â”‚
     â–¼                    â–¼
 recording.wav      AI Processing
```

**Analogy**: Security Camera System

- **Camera** = Microphone (captures everything)
- **Video Feed** = Audio stream
- **Recording DVR** = File saver (saves raw footage)
- **AI Analyzer** = Transcriber (processes in real-time)
- **Split Signal** = Sending to both DVR and AI simultaneously

---

### ğŸ§  How is Audio Sent to Whisper?

Whisper has **TWO different paths**: Real-time chunks and Final pass.

#### Path 1: Real-Time Chunks (During Recording)

#### ğŸ“ Location: `src-tauri/src/commands/recording.rs` (Lines 94-139)

```rust
if active_engine == ASREngine::Whisper {
    buffer.extend(samples);
    
    while buffer.len() >= chunk_size {  // chunk_size = 6 seconds worth
        let chunk: Vec<f32> = buffer.drain(..chunk_size).collect();
        let is_speech = vad.lock().unwrap().is_speech(&chunk)?;
        
        if is_speech > 0.5 {
            whisper.lock().unwrap().transcribe_chunk(&chunk, sample_rate)?;
        }
    }
}
```

**Step-by-Step:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REAL-TIME TRANSCRIPTION (Whisper Path)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  STEP 1: Accumulate audio in buffer                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  buffer = [] (empty array)                                    â”‚
â”‚                                                               â”‚
â”‚  Every 10ms: New audio arrives!                              â”‚
â”‚  â”œâ”€ 10ms: buffer = [480 samples]                             â”‚
â”‚  â”œâ”€ 20ms: buffer = [960 samples]                             â”‚
â”‚  â”œâ”€ 30ms: buffer = [1440 samples]                            â”‚
â”‚  â””â”€ ...                                                       â”‚
â”‚  â””â”€ 6000ms: buffer = [288,000 samples] âœ… READY!            â”‚
â”‚                                                               â”‚
â”‚  chunk_size = sample_rate * 6 = 48000 * 6 = 288,000         â”‚
â”‚               â””â”€ 6 seconds of audio                          â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Extract chunk from buffer                           â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let chunk = buffer.drain(..chunk_size).collect();           â”‚
â”‚                                                               â”‚
â”‚  Before:                                                      â”‚
â”‚  buffer = [288,000 samples, maybe more...]                   â”‚
â”‚                                                               â”‚
â”‚  drain() = Take and REMOVE first 288,000 samples            â”‚
â”‚                                                               â”‚
â”‚  After:                                                       â”‚
â”‚  chunk = [288,000 samples] â† Extracted                       â”‚
â”‚  buffer = [remaining samples] â† What's left                  â”‚
â”‚                                                               â”‚
â”‚  Analogy: Scooping soup                                       â”‚
â”‚  Take a ladle (chunk) from the pot (buffer)                  â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Voice Activity Detection (VAD)                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  ğŸ“ src-tauri/src/vad.rs (Line 78)                           â”‚
â”‚                                                               â”‚
â”‚  let is_speech = vad.is_speech(&chunk)?;                     â”‚
â”‚                                                               â”‚
â”‚  What happens:                                                â”‚
â”‚  1. Calculate RMS (Root Mean Square) = Loudness              â”‚
â”‚     rms = sqrt(sum(xÂ²) / count)                              â”‚
â”‚                                                               â”‚
â”‚  2. Compare to threshold (0.005)                             â”‚
â”‚     - Too quiet? â†’ 0.0 (silence)                             â”‚
â”‚     - Very loud? â†’ 1.0 (speech)                              â”‚
â”‚     - In between? â†’ 0.0-1.0 (probability)                    â”‚
â”‚                                                               â”‚
â”‚  Example:                                                     â”‚
â”‚  - Silence: is_speech = 0.1                                  â”‚
â”‚  - Speech: is_speech = 0.85                                  â”‚
â”‚                                                               â”‚
â”‚  Why? Skip transcribing silence (saves time/money!)          â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Transcribe if speech detected                       â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  if is_speech > 0.5 {  // More than 50% sure it's speech    â”‚
â”‚      whisper.transcribe_chunk(&chunk, sample_rate)?;         â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  If VAD says "YES, this is speech":                          â”‚
â”‚  âœ Send to Whisper for transcription                        â”‚
â”‚                                                               â”‚
â”‚  If VAD says "NO, this is silence":                          â”‚
â”‚  âœ Skip! Save compute. Don't bother the AI.                 â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Whisper Transcription                               â”‚
â”‚  ğŸ“ src-tauri/src/whisper.rs (Line 345)                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  whisper.transcribe_chunk(&chunk, sample_rate)               â”‚
â”‚                                                               â”‚
â”‚  (We'll detail this next!)                                    â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Visual Timeline:**

```
Time: 0s â”€â”€â”€â”€â”€â”€â”€â”€ 6s â”€â”€â”€â”€â”€â”€â”€â”€ 12s â”€â”€â”€â”€â”€â”€â”€ 18s â”€â”€â”€â”€â”€â”€â”€ STOP

      â”‚ Collecting â”‚ Collecting â”‚ Collecting â”‚
      â”‚   audio    â”‚   audio    â”‚   audio    â”‚
      â–¼            â–¼            â–¼            â–¼
    Chunk 1      Chunk 2      Chunk 3      Chunk 4
    (6 sec)      (6 sec)      (6 sec)      (6 sec)
      â”‚            â”‚            â”‚            â”‚
      â–¼            â–¼            â–¼            â–¼
    VAD Check    VAD Check    VAD Check    VAD Check
   [0.9=Speech] [0.1=Silence] [0.85=Speech] [0.2=Silence]
      â”‚            â”‚            â”‚            â”‚
      â–¼            X            â–¼            X
   Whisper AI    SKIP!      Whisper AI    SKIP!
      â”‚                         â”‚
      â–¼                         â–¼
   "Hello there"           "How are you"
      â”‚                         â”‚
      â–¼                         â–¼
   Emit to UI              Emit to UI
```

---

### ğŸ”¬ How is Audio Fed into Whisper Model?

#### ğŸ“ Location: `src-tauri/src/whisper.rs` (Lines 345-458)

Now let's see what happens INSIDE the Whisper transcription function!

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],
    input_sample_rate: u32,
) -> Result<String, String>
```

**Complete Process:**

```
INPUT: chunk = [288,000 samples at 48kHz]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Resample Audio (Lines 357-391)                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Why? Whisper ONLY works with 16kHz audio!                   â”‚
â”‚  Your mic might record at 48kHz or 44.1kHz                   â”‚
â”‚                                                               â”‚
â”‚  if input_sample_rate != 16000 {                             â”‚
â”‚      // Use resampler to convert                             â”‚
â”‚      let resampler = SincFixedIn::new(                       â”‚
â”‚          16000 / input_sample_rate,  // Target ratio         â”‚
â”‚          ...                                                  â”‚
â”‚      );                                                       â”‚
â”‚      audio_data = resampler.process(&samples)?;              â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  Before: 288,000 samples @ 48kHz = 6 seconds                 â”‚
â”‚  After:  96,000 samples @ 16kHz = 6 seconds                  â”‚
â”‚                                                               â”‚
â”‚  Analogy: Video Format Conversion                            â”‚
â”‚  Converting 4K video â†’ 1080p (same content, different size)  â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Create Whisper State (Lines 394-396)               â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let mut state = ctx.create_state()?;                        â”‚
â”‚                                                               â”‚
â”‚  What's a "state"?                                            â”‚
â”‚  âœ A temporary workspace for THIS transcription              â”‚
â”‚  âœ Holds intermediate calculations                           â”‚
â”‚  âœ Gets thrown away after we're done                         â”‚
â”‚                                                               â”‚
â”‚  Analogy: Chef's Cutting Board                               â”‚
â”‚  A clean surface to prepare THIS dish                        â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Configure Parameters (Lines 400-415)               â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let mut params = FullParams::new(                           â”‚
â”‚      SamplingStrategy::Greedy { best_of: 1 }                â”‚
â”‚  );                                                           â”‚
â”‚                                                               â”‚
â”‚  params.set_n_threads(4);        // Use 4 CPU cores          â”‚
â”‚  params.set_language(Some("en")); // English                 â”‚
â”‚  params.set_translate(false);    // Don't translate          â”‚
â”‚                                                               â”‚
â”‚  // CONTEXT MAGIC! (Lines 413-415)                           â”‚
â”‚  if !self.last_transcript.is_empty() {                       â”‚
â”‚      params.set_initial_prompt(&self.last_transcript);       â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  What's initial_prompt?                                       â”‚
â”‚  âœ Tell Whisper what was said BEFORE                        â”‚
â”‚  âœ Helps maintain context across chunks                      â”‚
â”‚  âœ Example: "The cat sat on the" â†’ Next: "mat"              â”‚
â”‚                                                               â”‚
â”‚  Analogy: Story Context                                       â”‚
â”‚  "Previously on Taurscribe: ..."                             â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Run Whisper AI! (Lines 421-423)                    â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  state.full(params, &audio_data)?;                           â”‚
â”‚                                                               â”‚
â”‚  ğŸš€ THIS IS WHERE THE MAGIC HAPPENS!                        â”‚
â”‚                                                               â”‚
â”‚  What happens inside (whisper-rs library):                   â”‚
â”‚  1. Compute Mel Spectrogram (audio â†’ visual representation)  â”‚
â”‚  2. Run through Encoder (understands audio features)         â”‚
â”‚  3. Run through Decoder (generates text tokens)              â”‚
â”‚  4. Beam search / Sampling (pick best words)                 â”‚
â”‚                                                               â”‚
â”‚  Time: 100-500ms on GPU, 1-3 seconds on CPU                  â”‚
â”‚                                                               â”‚
â”‚  Analogy: Oracle's Prophecy                                   â”‚
â”‚  Give the AI audio, it speaks back text!                     â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Extract Text (Lines 426-432)                       â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let num_segments = state.full_n_segments();                 â”‚
â”‚  let mut transcript = String::new();                         â”‚
â”‚                                                               â”‚
â”‚  for i in 0..num_segments {                                  â”‚
â”‚      if let Some(segment) = state.get_segment(i) {           â”‚
â”‚          transcript.push_str(&segment.to_string());          â”‚
â”‚      }                                                        â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  What's a segment?                                            â”‚
â”‚  âœ Whisper breaks text into pieces (usually sentences)       â”‚
â”‚  âœ Each segment has text + timestamp                         â”‚
â”‚  âœ We concatenate them all together                          â”‚
â”‚                                                               â”‚
â”‚  Example:                                                     â”‚
â”‚  Segment 0: "Hello"                                           â”‚
â”‚  Segment 1: " there"                                          â”‚
â”‚  Segment 2: ", how are you?"                                 â”‚
â”‚  Combined: "Hello there, how are you?"                       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 6: Update Context Memory (Lines 438-443)              â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  if !final_text.is_empty() {                                 â”‚
â”‚      if !self.last_transcript.is_empty() {                   â”‚
â”‚          self.last_transcript.push(' ');                     â”‚
â”‚      }                                                        â”‚
â”‚      self.last_transcript.push_str(&final_text);             â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  Save this text for next chunk!                              â”‚
â”‚  This accumulated text becomes the "initial_prompt"          â”‚
â”‚                                                               â”‚
â”‚  Example Timeline:                                            â”‚
â”‚  Chunk 1: "Hello" â†’ last_transcript = "Hello"               â”‚
â”‚  Chunk 2: "there" â†’ last_transcript = "Hello there"         â”‚
â”‚  Chunk 3: "friend" â†’ last_transcript = "Hello there friend" â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 7: Return Text (Line 457)                             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Ok(final_text)                                               â”‚
â”‚                                                               â”‚
â”‚  Text travels back through the call stack...                 â”‚
â”‚  âœ transcribe_chunk() returns                               â”‚
â”‚  âœ Back to recording.rs                                      â”‚
â”‚  âœ Emit to frontend!                                         â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OUTPUT: "Hello there, how are you?"
```

**Visual Architecture of Whisper Model:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WHISPER MODEL                        â”‚
â”‚                (Inside whisper-rs library)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  INPUT: audio_data [96,000 samples @ 16kHz]            â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ MEL SPECTROGRAM COMPUTATION                      â”‚ â”‚
â”‚  â”‚ Convert audio wave â†’ visual representation       â”‚ â”‚
â”‚  â”‚ Like a piano roll or heat map                    â”‚ â”‚
â”‚  â”‚ Output: [80 mel bins Ã— time frames]              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ENCODER (Transformer Layers)                     â”‚ â”‚
â”‚  â”‚ Processes the mel spectrogram                    â”‚ â”‚
â”‚  â”‚ Extracts audio features                          â”‚ â”‚
â”‚  â”‚ Outputs: Hidden states (compressed understanding)â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ DECODER (Transformer Layers)                     â”‚ â”‚
â”‚  â”‚ Generates text token by token                    â”‚ â”‚
â”‚  â”‚ Uses encoder output + previous tokens            â”‚ â”‚
â”‚  â”‚ Initial prompt provides context!                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ SAMPLING / BEAM SEARCH                           â”‚ â”‚
â”‚  â”‚ Pick the best words from probability dist.       â”‚ â”‚
â”‚  â”‚ "Greedy" = Always pick most likely word          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                                               â”‚
â”‚         â–¼                                               â”‚
â”‚  OUTPUT: "Hello there, how are you?"                   â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ¦œ How is Audio Sent to Parakeet?

Parakeet is **streaming-only** - no final pass needed!

#### ğŸ“ Location: `src-tauri/src/commands/recording.rs` (Lines 140-182)

```rust
} else {  // Parakeet path
    buffer.extend(samples);
    
    let parakeet_chunk_size = (sample_rate as f32 * 1.12) as usize;
    
    while buffer.len() >= parakeet_chunk_size {
        let chunk = buffer.drain(..parakeet_chunk_size).collect();
        
        parakeet_manager.transcribe_chunk(&chunk, sample_rate)?;
    }
}
```

**Breaking It Down:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REAL-TIME TRANSCRIPTION (Parakeet Path)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  STEP 1: Accumulate audio (same as Whisper)                  â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  buffer = [] (empty)                                          â”‚
â”‚  Every 10ms: buffer.extend(new_samples)                      â”‚
â”‚                                                               â”‚
â”‚  BUT! Chunk size is different:                               â”‚
â”‚  parakeet_chunk_size = sample_rate * 1.12                    â”‚
â”‚                      = 48000 * 1.12                          â”‚
â”‚                      = 53,760 samples                         â”‚
â”‚                      = ~1.12 seconds of audio                 â”‚
â”‚                                                               â”‚
â”‚  Why 1.12 seconds?                                            â”‚
â”‚  âœ Parakeet is FASTER than Whisper                          â”‚
â”‚  âœ Can process smaller chunks quickly                        â”‚
â”‚  âœ More responsive (updates more frequently)                 â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Extract chunk (same as Whisper)                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let chunk = buffer.drain(..parakeet_chunk_size).collect();  â”‚
â”‚                                                               â”‚
â”‚  chunk = [53,760 samples] @ 48kHz = 1.12 seconds             â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: NO VAD CHECK!                                       â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Parakeet path SKIPS voice activity detection!               â”‚
â”‚                                                               â”‚
â”‚  Why?                                                         â”‚
â”‚  â”œâ”€ Parakeet is very fast (can handle all audio)            â”‚
â”‚  â”œâ”€ Better continuity (no gaps from skipping silence)        â”‚
â”‚  â””â”€ Streaming models need consistent input                   â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Transcribe with Parakeet                            â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  parakeet_manager.transcribe_chunk(&chunk, sample_rate)?;    â”‚
â”‚                                                               â”‚
â”‚  ğŸ“ src-tauri/src/parakeet.rs (Line 528)                     â”‚
â”‚                                                               â”‚
â”‚  (We'll detail this next!)                                    â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Accumulate in Session Transcript                    â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  let mut session = session_transcript.lock().unwrap();       â”‚
â”‚  if !session.is_empty() {                                    â”‚
â”‚      session.push(' ');  // Add space                        â”‚
â”‚  }                                                            â”‚
â”‚  session.push_str(transcript.trim());                        â”‚
â”‚                                                               â”‚
â”‚  Why? Parakeet outputs INCREMENTAL text                      â”‚
â”‚  Each chunk adds to the full transcript                      â”‚
â”‚                                                               â”‚
â”‚  Example:                                                     â”‚
â”‚  Chunk 1: "Hello" â†’ session = "Hello"                       â”‚
â”‚  Chunk 2: "there" â†’ session = "Hello there"                 â”‚
â”‚  Chunk 3: "friend" â†’ session = "Hello there friend"         â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Comparison: Whisper vs Parakeet Chunking**

```
WHISPER (6 second chunks):

Time: 0â”€â”€â”€â”€â”€6â”€â”€â”€â”€â”€12â”€â”€â”€â”€18â”€â”€â”€â”€24 seconds
      â”‚â•â•â•â•â•â•â•â”‚â•â•â•â•â•â•â•â”‚â•â•â•â•â•â•â•â”‚â•â•â•â•â•â•â•â”‚
      Chunk 1  Chunk 2  Chunk 3  Chunk 4
      
      Less frequent updates, but more accurate


PARAKEET (1.12 second chunks):

Time: 0â”€â”€1.12â”€â”€2.24â”€â”€3.36â”€â”€4.48â”€â”€5.60 seconds
      â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚â•â•â”‚
      C1 C2 C3 C4 C5 C6 C7 C8 C9 C10
      
      Very frequent updates, streaming feel!
```

---

### ğŸ”¬ How is Audio Fed into Parakeet Model?

#### ğŸ“ Location: `src-tauri/src/parakeet.rs` (Lines 528-613)

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],
    sample_rate: u32,
) -> Result<String, String>
```

**Complete Process:**

```
INPUT: chunk = [53,760 samples at 48kHz]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Resample to 16kHz (Lines 534-567)                  â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Same as Whisper! Parakeet also needs 16kHz.                 â”‚
â”‚                                                               â”‚
â”‚  Before: 53,760 samples @ 48kHz = 1.12 seconds               â”‚
â”‚  After:  17,920 samples @ 16kHz = 1.12 seconds               â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Match with correct model type (Lines 569-609)      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Parakeet has 4 different model architectures:               â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ 1. NEMOTRON (Streaming RNN-T)                 â”‚         â”‚
â”‚  â”‚    âœ Best for real-time                        â”‚         â”‚
â”‚  â”‚    âœ Has internal state (memory)               â”‚         â”‚
â”‚  â”‚    âœ Process in tiny 560ms chunks              â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ 2. CTC (Connectionist Temporal Classification) â”‚         â”‚
â”‚  â”‚    âœ Fast offline processing                   â”‚         â”‚
â”‚  â”‚    âœ No state (stateless)                      â”‚         â”‚
â”‚  â”‚    âœ Process whole chunk at once               â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ 3. EOU (End of Utterance)                      â”‚         â”‚
â”‚  â”‚    âœ Detects sentence boundaries               â”‚         â”‚
â”‚  â”‚    âœ Process in 160ms micro-chunks             â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ 4. TDT (Token-and-Duration Transducer)         â”‚         â”‚
â”‚  â”‚    âœ Includes timing information               â”‚         â”‚
â”‚  â”‚    âœ Process whole chunk                       â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                               â”‚
â”‚  match model {                                                â”‚
â”‚      LoadedModel::Nemotron(m) => { ... }                     â”‚
â”‚      LoadedModel::Ctc(m) => { ... }                          â”‚
â”‚      LoadedModel::Eou(m) => { ... }                          â”‚
â”‚      LoadedModel::Tdt(m) => { ... }                          â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PATH A: NEMOTRON (Most common for streaming)               â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  Lines 571-582                                                â”‚
â”‚                                                               â”‚
â”‚  LoadedModel::Nemotron(m) => {                               â”‚
â”‚      let mut transcript = String::new();                     â”‚
â”‚      const CHUNK_SIZE: usize = 8960; // 560ms @ 16kHz        â”‚
â”‚                                                               â”‚
â”‚      for chunk in audio.chunks(CHUNK_SIZE) {                 â”‚
â”‚          let mut chunk_vec = chunk.to_vec();                 â”‚
â”‚          if chunk_vec.len() < CHUNK_SIZE {                   â”‚
â”‚              chunk_vec.resize(CHUNK_SIZE, 0.0); // Pad!      â”‚
â”‚          }                                                    â”‚
â”‚          transcript.push_str(                                 â”‚
â”‚              &m.transcribe_chunk(&chunk_vec)?                â”‚
â”‚          );                                                   â”‚
â”‚      }                                                        â”‚
â”‚      Ok(transcript)                                           â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  What's happening:                                            â”‚
â”‚  1. Break 1.12s audio into even SMALLER pieces (560ms)      â”‚
â”‚  2. Nemotron processes each 560ms chunk                      â”‚
â”‚  3. Concatenate results                                       â”‚
â”‚                                                               â”‚
â”‚  Why so small?                                                â”‚
â”‚  âœ Nemotron is an RNN-T (Recurrent Neural Network)          â”‚
â”‚  âœ Maintains hidden state across chunks                      â”‚
â”‚  âœ Very responsive (updates every 560ms!)                    â”‚
â”‚                                                               â”‚
â”‚  Visual:                                                      â”‚
â”‚  1.12s audio:                                                 â”‚
â”‚  [â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]                                   â”‚
â”‚  [â•â•â•â•â•â•â•â•][â•â•â•â•â•â•â•â•]                                        â”‚
â”‚   560ms    560ms                                              â”‚
â”‚   Chunk1   Chunk2                                             â”‚
â”‚     â”‚        â”‚                                                â”‚
â”‚     â–¼        â–¼                                                â”‚
â”‚  "Hello"  " there"                                            â”‚
â”‚                                                               â”‚
â”‚  Combined: "Hello there"                                      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INSIDE Nemotron Model (parakeet-rs library)                â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                  â”‚
â”‚                                                               â”‚
â”‚  m.transcribe_chunk(&chunk)                                   â”‚
â”‚                                                               â”‚
â”‚  Architecture:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ INPUT: [8960 samples] @ 16kHz = 560ms          â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ ENCODER (ONNX model: encoder.onnx)             â”‚         â”‚
â”‚  â”‚ Processes audio features                        â”‚         â”‚
â”‚  â”‚ Outputs: Encoded representations                â”‚         â”‚
â”‚  â”‚ Uses: Recurrent layers (LSTM/GRU)               â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ DECODER + JOINT NETWORK                         â”‚         â”‚
â”‚  â”‚ (ONNX model: decoder_joint.onnx)                â”‚         â”‚
â”‚  â”‚                                                  â”‚         â”‚
â”‚  â”‚ Loop:                                            â”‚         â”‚
â”‚  â”‚   1. Predict next token                         â”‚         â”‚
â”‚  â”‚   2. Update internal state                      â”‚         â”‚
â”‚  â”‚   3. Repeat until end-of-utterance              â”‚         â”‚
â”‚  â”‚                                                  â”‚         â”‚
â”‚  â”‚ Internal State = "Memory" of previous words     â”‚         â”‚
â”‚  â”‚ This is WHY we can call .reset() to clear it!   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ TOKENIZER (tokenizer.model - SentencePiece)    â”‚         â”‚
â”‚  â”‚ Token IDs â†’ Text                                â”‚         â”‚
â”‚  â”‚ Example: [123, 456, 789] â†’ "Hello"              â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                                                     â”‚
â”‚         â–¼                                                     â”‚
â”‚  OUTPUT: "Hello"                                              â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OUTPUT: "Hello there" (or whatever was said)
```

**Key Difference: Nemotron has STATE!**

```
NEMOTRON (Stateful):

Chunk 1: "Hello" â”
                 â”œâ”€â–º Internal State Updated
Chunk 2: " there"â”‚   (Remembers "Hello")
                 â”‚
                 â””â”€â–º Better context across chunks!


CTC/TDT/EOU (Stateless):

Chunk 1: "Hello"  â†’ Process â†’ Output
                     â†“
                  Forget everything
                     â†“
Chunk 2: "there"  â†’ Process â†’ Output

Each chunk is independent!
```

---

### ğŸ“¤ How is Text Outputted?

Text gets back to the UI through **Tauri Events**!

#### ğŸ“ Location: `src-tauri/src/commands/recording.rs` (Lines 121-128 for Whisper, 163-170 for Parakeet)

```rust
// After transcription finishes:
app_clone.emit(
    "transcription-chunk",
    TranscriptionChunk {
        text: transcript,
        processing_time_ms: elapsed,
        method: "Whisper".to_string(),
    },
)?;
```

**Complete Flow:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RUST BACKEND (Transcriber Thread)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  1. AI finishes transcription                                â”‚
â”‚     transcript = "Hello there"                               â”‚
â”‚                                                               â”‚
â”‚  2. Create event payload                                     â”‚
â”‚     TranscriptionChunk {                                     â”‚
â”‚         text: "Hello there",                                 â”‚
â”‚         processing_time_ms: 250,                             â”‚
â”‚         method: "Whisper",                                   â”‚
â”‚     }                                                         â”‚
â”‚                                                               â”‚
â”‚  3. Emit event to frontend                                   â”‚
â”‚     app_handle.emit("transcription-chunk", payload)?;        â”‚
â”‚                                                               â”‚
â”‚     What's emit()?                                            â”‚
â”‚     âœ Tauri's event system                                  â”‚
â”‚     âœ Broadcasts a message to ALL listeners                 â”‚
â”‚     âœ Like shouting in a room                               â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ (Event travels through Tauri bridge...)
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FRONTEND (React) - Event Listener                          â”‚
â”‚  ğŸ“ src/App.tsx (somewhere in useEffect)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  useEffect(() => {                                            â”‚
â”‚      const unlisten = listen(                                â”‚
â”‚          "transcription-chunk",                              â”‚
â”‚          (event) => {                                         â”‚
â”‚              const chunk = event.payload;                    â”‚
â”‚              setLiveTranscript(prev => prev + chunk.text);   â”‚
â”‚          }                                                    â”‚
â”‚      );                                                       â”‚
â”‚      return () => unlisten();                                â”‚
â”‚  }, []);                                                      â”‚
â”‚                                                               â”‚
â”‚  What happens:                                                â”‚
â”‚  1. listen() registers an event handler                      â”‚
â”‚  2. When "transcription-chunk" event arrives...              â”‚
â”‚  3. Callback function runs                                   â”‚
â”‚  4. Updates React state (setLiveTranscript)                  â”‚
â”‚  5. React re-renders UI with new text!                       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  UI UPDATE                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  ğŸ“± TAURSCRIBE UI                              â”‚         â”‚
â”‚  â”‚                                                 â”‚         â”‚
â”‚  â”‚  ğŸ”´ Recording...                                â”‚         â”‚
â”‚  â”‚                                                 â”‚         â”‚
â”‚  â”‚  Transcript:                                    â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚         â”‚
â”‚  â”‚  â”‚ Hello there                               â”‚ â”‚         â”‚
â”‚  â”‚  â”‚                                           â”‚ â”‚         â”‚
â”‚  â”‚  â”‚ â–ˆ (cursor blinks)                        â”‚ â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚         â”‚
â”‚  â”‚                                                 â”‚         â”‚
â”‚  â”‚  Processing: 250ms | Method: Whisper           â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                               â”‚
â”‚  USER SEES THE TEXT APPEAR IN REAL-TIME! âœ¨                  â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ¬ Complete Visual Flow: Start to Finish

Here's the ENTIRE journey from button click to seeing text:

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    THE COMPLETE JOURNEY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ‘¤ USER
 â”‚ Clicks [ğŸ¤ Start Recording]
 â”‚
 â–¼
ğŸ“± FRONTEND (src/App.tsx:168)
 â”‚ await invoke("start_recording")
 â”‚
 â–¼
ğŸŒ‰ TAURI IPC BRIDGE
 â”‚ Serializes call â†’ Sends to Rust
 â”‚
 â–¼
ğŸ¦€ RUST BACKEND (src-tauri/src/commands/recording.rs:13)
 â”‚ start_recording() function begins
 â”‚
 â”œâ”€â–º STEP 1: Setup microphone (cpal library)
 â”œâ”€â–º STEP 2: Create WAV file
 â”œâ”€â–º STEP 3: Clear AI context
 â”œâ”€â–º STEP 4: Create channels (file_tx/rx, whisper_tx/rx)
 â”œâ”€â–º STEP 5: Spawn File Saver Thread ğŸ’¾
 â”œâ”€â–º STEP 6: Spawn Transcriber Thread ğŸ§ 
 â””â”€â–º STEP 7: Start microphone stream â–¶ï¸
     â”‚
     â”‚ Microphone now captures audio every 10ms!
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         PARALLEL EXECUTION (3 threads)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Thread 1: ğŸ¤ MICROPHONE CALLBACK                      â”‚
â”‚  â”‚ Every 10ms:                                         â”‚
â”‚  â”‚   1. Get 480 samples from mic                       â”‚
â”‚  â”‚   2. Send to file_tx                                â”‚
â”‚  â”‚   3. Convert stereo â†’ mono                          â”‚
â”‚  â”‚   4. Send to whisper_tx                             â”‚
â”‚  â”‚                                                      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â””â”€â”€â”¤ file_tx channel  â”œâ”€â”€â”¤ whisper_tx chan  â”œâ”€â”€â”     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚              â”‚                       â”‚           â”‚     â”‚
â”‚              â–¼                       â–¼           â”‚     â”‚
â”‚  Thread 2: ğŸ’¾ FILE SAVER    Thread 3: ğŸ§  TRANSCRIBER  â”‚
â”‚  â”‚ Receives audio        â”‚ Receives audio             â”‚
â”‚  â”‚ Writes to disk        â”‚ Accumulates in buffer      â”‚
â”‚  â”‚ Creates WAV file      â”‚ When buffer full:          â”‚
â”‚  â”‚                       â”‚                             â”‚
â”‚  â”‚                       â”œâ”€â–º (If Whisper):            â”‚
â”‚  â”‚                       â”‚   - Check VAD (is speech?) â”‚
â”‚  â”‚                       â”‚   - If yes: transcribe     â”‚
â”‚  â”‚                       â”‚   - Wait 6 seconds         â”‚
â”‚  â”‚                       â”‚                             â”‚
â”‚  â”‚                       â””â”€â–º (If Parakeet):           â”‚
â”‚  â”‚                           - Transcribe (no VAD)    â”‚
â”‚  â”‚                           - Wait 1.12 seconds      â”‚
â”‚  â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   AI TRANSCRIPTION    â”‚
                   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                   â”‚                       â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                           â”‚                        â”‚
   â–¼ WHISPER                   â–¼ PARAKEET               â”‚
   â”‚                           â”‚                        â”‚
   â”œâ”€ Resample â†’ 16kHz         â”œâ”€ Resample â†’ 16kHz     â”‚
   â”œâ”€ Create state             â”œâ”€ Match model type     â”‚
   â”œâ”€ Set parameters           â”‚  (Nemotron/CTC/etc)   â”‚
   â”œâ”€ Set context prompt       â”œâ”€ Break into chunks    â”‚
   â”œâ”€ Run model (GPU/CPU)      â”œâ”€ Run ONNX inference   â”‚
   â”œâ”€ Extract segments         â”œâ”€ Decode tokens        â”‚
   â”œâ”€ Update context           â””â”€ Return text          â”‚
   â””â”€ Return text                                       â”‚
        â”‚                           â”‚                   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
                        â”‚                               â”‚
                        â–¼                               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
        â”‚  EMIT EVENT TO FRONTEND       â”‚              â”‚
        â”‚  "transcription-chunk"        â”‚              â”‚
        â”‚  { text, time, method }       â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
                        â”‚                               â”‚
                        â–¼                               â”‚
        ğŸŒ‰ TAURI EVENT BRIDGE                           â”‚
                        â”‚                               â”‚
                        â–¼                               â”‚
        ğŸ“± FRONTEND EVENT LISTENER                      â”‚
        â”‚ listen("transcription-chunk", ...)            â”‚
        â”‚                                                â”‚
        â”œâ”€â–º Receive event payload                       â”‚
        â”œâ”€â–º Update React state                          â”‚
        â”‚   setLiveTranscript(prev => prev + text)      â”‚
        â””â”€â–º React re-renders                            â”‚
                        â”‚                               â”‚
                        â–¼                               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
        â”‚   ğŸ‘€ USER SEES TEXT!           â”‚              â”‚
        â”‚                                â”‚              â”‚
        â”‚   "Hello there"                â”‚              â”‚
        â”‚   "How are you doing?"         â”‚              â”‚
        â”‚   "This is amazing!"           â”‚              â”‚
        â”‚                                â”‚              â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
                                                        â”‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      STOP RECORDING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ‘¤ USER
 â”‚ Clicks [â¹ï¸ Stop Recording]
 â”‚
 â–¼
ğŸ“± FRONTEND
 â”‚ await invoke("stop_recording")
 â”‚
 â–¼
ğŸ¦€ RUST BACKEND (src-tauri/src/commands/recording.rs:276)
 â”‚ stop_recording() function
 â”‚
 â”œâ”€â–º Drop stream (stops microphone)
 â”œâ”€â–º Drop channels (closes pipes)
 â”œâ”€â–º Wait 500ms (let threads finish)
 â”‚
 â”œâ”€â–º (If Whisper): FINAL HIGH-QUALITY PASS
 â”‚   â”‚
 â”‚   â”œâ”€â–º Load full WAV file from disk
 â”‚   â”œâ”€â–º Run VAD to find speech segments
 â”‚   â”œâ”€â–º Extract only speech parts
 â”‚   â”œâ”€â–º Transcribe with Whisper (8 threads!)
 â”‚   â””â”€â–º Return final transcript
 â”‚
 â””â”€â–º (If Parakeet): Use accumulated session
     â””â”€â–º Return session_transcript (already complete!)
         â”‚
         â–¼
     ğŸ“± FRONTEND
         â”‚ Receives final transcript
         â”‚ Displays in UI
         â”‚
         â–¼
     ğŸ‘€ USER SEES FINAL POLISHED TRANSCRIPT! âœ¨
```

---

### ğŸ“ Key Takeaways for Beginners

#### 1. **Threads & Parallelism**

Think of threads like workers in a restaurant:
- Worker 1 (Mic): Takes orders constantly
- Worker 2 (File): Writes down every order
- Worker 3 (AI): Translates orders for the chef

All working at the SAME TIME!

#### 2. **Channels (Pipes)**

Channels are like conveyor belts:
- `send()` = Put item on belt
- `recv()` = Take item off belt
- Data flows from one thread to another safely!

#### 3. **Buffering**

We collect audio in a "buffer" (basket) until we have enough:
- Too small: Waste time processing tiny pieces
- Too big: User waits forever for results
- Just right: 6 seconds for Whisper, 1.12s for Parakeet

#### 4. **Sample Rates**

Audio frequency (like video frame rate):
- 48kHz = 48,000 samples per second (high quality)
- 16kHz = 16,000 samples per second (AI standard)
- Resampling = Converting between rates

#### 5. **Stereo vs Mono**

- Stereo = 2 channels (Left + Right ears)
- Mono = 1 channel (averaged)
- AI models need mono!

#### 6. **Events**

Rust â†’ Frontend communication:
- `emit()` = Shout a message
- `listen()` = Ear listening for messages
- Real-time updates without polling!

---

### ğŸ“ Summary Table: Where Everything Happens

| Task | File | Function | Line |
|------|------|----------|------|
| **Start button click** | `src/App.tsx` | Button onClick | ~168 |
| **Start recording command** | `src-tauri/src/commands/recording.rs` | `start_recording()` | 13-272 |
| **Setup microphone** | â†‘ Same | â†‘ Same | 17-23 |
| **Create channels** | â†‘ Same | â†‘ Same | 54-55 |
| **File saver thread** | â†‘ Same | â†‘ Same | 62-72 |
| **Transcriber thread** | â†‘ Same | â†‘ Same | 82-235 |
| **Audio callback** | â†‘ Same | â†‘ Same | 243-254 |
| **Whisper real-time path** | â†‘ Same | Transcriber thread | 94-139 |
| **Parakeet real-time path** | â†‘ Same | Transcriber thread | 140-182 |
| **VAD check** | `src-tauri/src/vad.rs` | `is_speech()` | 78-98 |
| **Whisper transcription** | `src-tauri/src/whisper.rs` | `transcribe_chunk()` | 345-458 |
| **Whisper model inference** | â†‘ Same (whisper-rs lib) | `state.full()` | 421-423 |
| **Parakeet transcription** | `src-tauri/src/parakeet.rs` | `transcribe_chunk()` | 528-613 |
| **Nemotron inference** | â†‘ Same (parakeet-rs lib) | `m.transcribe_chunk()` | 579 |
| **Emit event to frontend** | `src-tauri/src/commands/recording.rs` | `app_clone.emit()` | 121-128 |
| **Stop recording command** | â†‘ Same | `stop_recording()` | 276-344 |
| **Whisper final pass** | â†‘ Same | â†‘ Same | 306-326 |
| **Load audio file** | `src-tauri/src/whisper.rs` | `load_audio()` | 707-779 |
| **Final transcription** | â†‘ Same | `transcribe_audio_data()` | 647-703 |

---

### ğŸ‰ You Now Understand the Complete Audio Pipeline!

From clicking a button to seeing text appear on screen, you now know:

âœ… Where every piece of code lives  
âœ… How audio flows through the system  
âœ… How Whisper processes audio (chunks + final pass)  
âœ… How Parakeet streams audio (smaller chunks)  
âœ… How text gets back to the UI  
âœ… Why we use threads, channels, and buffers  
âœ… The difference between real-time and final transcription  

**You're ready to modify, debug, and extend the audio system!** ğŸš€

---

Done! âœ…

---

## ğŸš€ Major Update: Grammar Correction with Gemma LLM (Commits f54196f â†’ b0aeb9d)

### ğŸ“‹ What Changed?

Between commit `f54196f` (old) and `b0aeb9d` (latest), we added **AI-powered grammar correction** to Taurscribe! Now after you transcribe your voice, you can click a button to automatically fix grammar mistakes using a local Large Language Model (LLM).

**Think of it like**: Adding a professional editor to your restaurant who instantly polishes your transcript!

---

### ğŸ¯ Overview of Changes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BEFORE (f54196f)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ¤ Microphone â†’ ğŸ§  Whisper/Parakeet â†’ ğŸ“ Raw Transcript        â”‚
â”‚                                                                  â”‚
â”‚  That's it! No grammar correction.                              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                              â¬‡ï¸  ADDED  â¬‡ï¸

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AFTER (b0aeb9d)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ¤ Microphone â†’ ğŸ§  Whisper/Parakeet â†’ ğŸ“ Raw Transcript        â”‚
â”‚                                          â”‚                       â”‚
â”‚                                          â–¼                       â”‚
â”‚                                    âœ¨ Click Button!             â”‚
â”‚                                          â”‚                       â”‚
â”‚                                          â–¼                       â”‚
â”‚                              ğŸª„ Gemma LLM (Grammar Fixer)       â”‚
â”‚                                          â”‚                       â”‚
â”‚                                          â–¼                       â”‚
â”‚                                 ğŸ“ Polished Transcript âœ…        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“Š File Changes Summary

| File | Status | Purpose |
|------|--------|---------|
| `src-tauri/src/llm.rs` | âœ… NEW | Core LLM engine using Candle framework |
| `src-tauri/src/commands/llm.rs` | âœ… NEW | Command handlers for frontend-backend communication |
| `src-tauri/src/state.rs` | ğŸ”„ MODIFIED | Added LLM storage to global state |
| `src-tauri/src/lib.rs` | ğŸ”„ MODIFIED | Registered new LLM commands |
| `src-tauri/src/commands/mod.rs` | ğŸ”„ MODIFIED | Exported LLM commands |
| `src-tauri/Cargo.toml` | ğŸ”„ MODIFIED | Added Candle ML framework dependencies |
| `src-tauri/.cargo/config.toml` | ğŸ”„ MODIFIED | Fixed linking issues for Windows |
| `src/App.tsx` | ğŸ”„ MODIFIED | Added "Correct Grammar" button |
| `src/App.css` | ğŸ”„ MODIFIED | Styled the correction button |

---

### ğŸ—ï¸ The Complete Architecture Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         TAURSCRIBE WITH LLM                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ğŸ‘¤ USER
     â”‚
     â”‚ 1ï¸âƒ£ Speaks into microphone
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ğŸ¤ MICROPHONE      â”‚
â”‚   (cpal library)     â”‚
â”‚   Captures audio     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 2ï¸âƒ£ Raw audio data (PCM samples)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ§  ASR ENGINE       â”‚
â”‚  Whisper/Parakeet    â”‚
â”‚  Converts to text    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 3ï¸âƒ£ Raw transcript (may have errors)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ğŸ“º FRONTEND (React)                     â”‚
â”‚                                                      â”‚
â”‚  Shows: "i went too the stor yesterday"             â”‚
â”‚                                                      â”‚
â”‚         [ âœ¨ Correct Grammar ]  â† 4ï¸âƒ£ User clicks   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 5ï¸âƒ£ invoke("correct_text", { text: "..." })
     â”‚    (Tauri bridge sends request to Rust backend)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ğŸ¦€ RUST BACKEND (commands/llm.rs)           â”‚
â”‚                                                      â”‚
â”‚  correct_text() function receives request           â”‚
â”‚  "Someone wants to fix this text!"                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 6ï¸âƒ£ Access global state
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            ğŸ§  GLOBAL STATE (state.rs)               â”‚
â”‚                                                      â”‚
â”‚  pub llm: Arc<Mutex<Option<LLMEngine>>>             â”‚
â”‚           â””â”€ Thread-safe box holding LLM           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 7ï¸âƒ£ Lock mutex, get LLM engine
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ğŸª„ LLM ENGINE (llm.rs)                    â”‚
â”‚                                                      â”‚
â”‚  Powered by: Candle + Gemma 3 Model                â”‚
â”‚  Model: GRMR-V3-G1B-Q4_K_M.gguf (1 billion params) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 8ï¸âƒ£ Format prompt for grammar correction
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Formatted Prompt:                                   â”‚
â”‚                                                      â”‚
â”‚  <bos>text                                           â”‚
â”‚  i went too the stor yesterday                      â”‚
â”‚  corrected                                           â”‚
â”‚                                                      â”‚
â”‚  (Model learns to complete this pattern)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 9ï¸âƒ£ Tokenize (text â†’ numbers)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Token IDs: [1, 1234, 5678, 9012, ...]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ ğŸ”Ÿ Run through neural network
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ğŸ§® GEMMA MODEL INFERENCE                    â”‚
â”‚                                                      â”‚
â”‚  Input Tensor â†’ Forward Pass â†’ Logits (predictions) â”‚
â”‚                                                      â”‚
â”‚  [Billions of mathematical operations happen here!] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 1ï¸âƒ£1ï¸âƒ£ Sample next token (with temperature)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Next Token ID: 3456                                 â”‚
â”‚  Decode: "I went to the store yesterday"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 1ï¸âƒ£2ï¸âƒ£ Return corrected text
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ğŸ“º FRONTEND (React)                     â”‚
â”‚                                                      â”‚
â”‚  Updates display:                                    â”‚
â”‚  "I went to the store yesterday" âœ…                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ†• NEW FILE: `src-tauri/src/llm.rs`

This is the **heart of the grammar correction system**. It's like the master chef who specializes in making dishes (text) perfect!

#### ğŸ§© Structure Overview

```rust
pub struct LLMEngine {
    model: model::ModelWeights,      // The "brain" - Gemma neural network
    tokenizer: Tokenizer,             // Translator (text â†” numbers)
    device: Device,                   // Where to compute (GPU/CPU)
    logits_processor: LogitsProcessor // Decision maker (sampling)
}
```

**Analogy**: Think of `LLMEngine` as a **magic translation machine**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ğŸª„ THE GRAMMAR CORRECTION MACHINE          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ“– tokenizer        (Dictionary)                   â”‚
â”‚     "Converts words to numbers and back"            â”‚
â”‚     - "hello" becomes [1234]                        â”‚
â”‚     - [5678] becomes "world"                        â”‚
â”‚                                                      â”‚
â”‚  ğŸ§  model            (The Brain)                    â”‚
â”‚     "1 billion parameters (memories/patterns)"      â”‚
â”‚     - Learned from millions of text examples        â”‚
â”‚     - Knows grammar rules implicitly                â”‚
â”‚                                                      â”‚
â”‚  ğŸ’» device           (The Workstation)              â”‚
â”‚     "Where the work happens"                        â”‚
â”‚     - GPU (Graphics Card) = Fast! âš¡                â”‚
â”‚     - CPU (Regular Processor) = Slower ğŸ¢           â”‚
â”‚                                                      â”‚
â”‚  ğŸ² logits_processor (The Decision Maker)           â”‚
â”‚     "Picks the best word from possibilities"        â”‚
â”‚     - Temperature 0.7 = Some creativity             â”‚
â”‚     - Top-P 0.95 = Focus on best options           â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ğŸ”¨ Function: `LLMEngine::new()` - Building the Machine

This function **loads** the LLM into memory. It's like assembling a complex machine before using it.

```rust
pub fn new() -> Result<Self> {
    // 1. Define where the model files live
    let base_path = PathBuf::from(
        r"c:\Users\abdul\OneDrive\Desktop\Taurscribe\taurscribe-runtime\models\GRMR-V3-G1B-GGUF",
    );
    let model_path = base_path.join("GRMR-V3-G1B-Q4_K_M.gguf");
    let tokenizer_path = base_path.join("tokenizer.json");
    
    // 2. Check if files exist (safety check)
    if !model_path.exists() {
        return Err(Error::msg("Model file not found!"));
    }
    
    // 3. Select device (try GPU first, fallback to CPU)
    let device = Device::new_cuda(0).unwrap_or(Device::Cpu);
    
    // 4. Load tokenizer (the translator)
    let tokenizer = Tokenizer::from_file(&tokenizer_path)?;
    
    // 5. Load model weights (the brain)
    let mut file = std::fs::File::open(&model_path)?;
    let content = gguf_file::Content::read(&mut file)?;
    let model = model::ModelWeights::from_gguf(content, &mut file, &device)?;
    
    // 6. Create the decision maker
    let logits_processor = LogitsProcessor::new(1337, Some(0.7), Some(0.95));
    
    Ok(Self { model, tokenizer, device, logits_processor })
}
```

**Step-by-Step Analogy**: Building a Coffee Machine â˜•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BUILDING THE GRAMMAR CORRECTION MACHINE               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Step 1: Find the blueprint (model file path)          â”‚
â”‚  ğŸ“‚ "Where are the instructions?"                      â”‚
â”‚  âœ Check c:\...\GRMR-V3-G1B-Q4_K_M.gguf               â”‚
â”‚                                                         â”‚
â”‚  Step 2: Verify files exist                            â”‚
â”‚  ğŸ” "Do we have everything we need?"                   â”‚
â”‚  âœ Yes? Continue. No? Error!                           â”‚
â”‚                                                         â”‚
â”‚  Step 3: Choose where to work                          â”‚
â”‚  ğŸ’» "Do we have a fast GPU?"                           â”‚
â”‚  âœ Try CUDA (NVIDIA GPU): Success? Use it! âš¡          â”‚
â”‚  âœ No GPU available? Use CPU instead ğŸ¢                â”‚
â”‚                                                         â”‚
â”‚  Step 4: Load the dictionary                           â”‚
â”‚  ğŸ“– "Load tokenizer.json"                              â”‚
â”‚  âœ Now we can translate words â†” numbers                â”‚
â”‚                                                         â”‚
â”‚  Step 5: Load the brain                                â”‚
â”‚  ğŸ§  "Open the 1GB model file and load into memory"     â”‚
â”‚  âœ This takes 2-3 seconds                              â”‚
â”‚  âœ Contains 1 billion learned patterns!                â”‚
â”‚                                                         â”‚
â”‚  Step 6: Prepare the decision maker                    â”‚
â”‚  ğŸ² "Set up sampling rules"                            â”‚
â”‚  âœ Seed: 1337 (for reproducibility)                    â”‚
â”‚  âœ Temperature: 0.7 (controlled creativity)            â”‚
â”‚  âœ Top-P: 0.95 (focus on best options)                â”‚
â”‚                                                         â”‚
â”‚  âœ… Machine ready! Return it to the caller             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Rust Concepts**:

1. **`Result<Self>`**: This function can succeed (return `Ok(LLMEngine)`) or fail (return `Err(Error)`).
   - Think: "This might not work, so we need a backup plan."

2. **`?` operator**: The magic error handler!
   - If something fails, immediately return the error to the caller.
   - Example: `let tokenizer = Tokenizer::from_file(&path)?;`
   - If `from_file` fails, the `?` says "stop here and return the error."

3. **`unwrap_or`**: The fallback operator
   - `Device::new_cuda(0).unwrap_or(Device::Cpu)`
   - Try CUDA first. If it fails, use CPU instead.

---

#### âš¡ Function: `LLMEngine::run()` - The Magic Happens

This function takes messy text and returns corrected text!

```rust
pub fn run(&mut self, prompt: &str) -> Result<String> {
    // 1. Format the prompt using a special template
    let formatted_prompt = format!("<bos>text\n{}\ncorrected\n", prompt.trim());
    
    // 2. Convert text to token IDs (numbers)
    let tokens = self.tokenizer
        .encode(formatted_prompt, true)?
        .get_ids()
        .to_vec();
    
    // 3. Create a tensor (multidimensional array) for the model
    let input = Tensor::new(tokens.as_slice(), &self.device)?;
    
    // 4. Run the model! (The magic neural network computation)
    let logits = self.model.forward(&input, 0)?;
    
    // 5. Get the predictions for the next token
    let (seq_len, _vocab_size) = logits.dims2()?;
    let last_logits = logits.get(seq_len - 1)?;
    
    // 6. Sample the next token (pick the best one)
    let next_token = self.logits_processor.sample(&last_logits)?;
    
    // 7. Convert token ID back to text
    let decoded = self.tokenizer.decode(&[next_token], true)?;
    
    Ok(decoded)
}
```

**Analogy**: The Grammar Correction Assembly Line ğŸ­

```
INPUT: "i went too the stor yesterday"
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: Format Prompt (Add Magic Instructions)         â”‚
â”‚                                                         â”‚
â”‚  Before: "i went too the stor yesterday"               â”‚
â”‚  After:  "<bos>text                                    â”‚
â”‚          i went too the stor yesterday                 â”‚
â”‚          corrected                                     â”‚
â”‚          "                                             â”‚
â”‚                                                         â”‚
â”‚  Why? The model was trained to complete this pattern!  â”‚
â”‚  It knows: "Oh, I need to fix this text now"          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: Tokenize (Text â†’ Numbers)                     â”‚
â”‚                                                         â”‚
â”‚  "<bos>" â†’ [1]                                         â”‚
â”‚  "text"  â†’ [1234]                                      â”‚
â”‚  "i"     â†’ [5678]                                      â”‚
â”‚  "went"  â†’ [9012]                                      â”‚
â”‚  "too"   â†’ [3456]                                      â”‚
â”‚  ...                                                    â”‚
â”‚                                                         â”‚
â”‚  Result: [1, 1234, 5678, 9012, 3456, ...]              â”‚
â”‚                                                         â”‚
â”‚  Why numbers? Computers can't understand words         â”‚
â”‚  directly. They need numbers to do math!               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: Create Tensor (Organize the Numbers)          â”‚
â”‚                                                         â”‚
â”‚  Tensor = Fancy word for "array of numbers"           â”‚
â”‚                                                         â”‚
â”‚  Shape: [sequence_length]                              â”‚
â”‚  Example: [1, 1234, 5678, 9012, 3456, 7890, ...]       â”‚
â”‚                                                         â”‚
â”‚  Device: GPU or CPU                                    â”‚
â”‚  (Moves data to the right place for computation)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 4: Model Forward Pass (THE MAGIC! âœ¨)            â”‚
â”‚                                                         â”‚
â”‚  self.model.forward(&input, 0)                         â”‚
â”‚                                                         â”‚
â”‚  What happens inside:                                  â”‚
â”‚  1. Embeddings: Each token â†’ 576 numbers               â”‚
â”‚  2. Self-Attention (Ã—30 layers):                       â”‚
â”‚     - "Which words relate to each other?"              â”‚
â”‚     - "too" looks at "went" for context                â”‚
â”‚  3. Feed-Forward Networks:                             â”‚
â”‚     - Transform representations                        â”‚
â”‚     - 576 â†’ 1536 â†’ 576 dimensions                      â”‚
â”‚  4. Output: Predictions for EVERY position             â”‚
â”‚                                                         â”‚
â”‚  Result: "logits" = Raw predictions                    â”‚
â”‚  Shape: [sequence_length, 49152]                       â”‚
â”‚          â””â”€ 49,152 possible tokens in vocabulary      â”‚
â”‚                                                         â”‚
â”‚  ğŸ”¥ This is where 1 BILLION PARAMETERS work!          â”‚
â”‚     (Billions of multiply-add operations)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 5: Extract Last Token's Predictions              â”‚
â”‚                                                         â”‚
â”‚  logits shape: [10, 49152]                             â”‚
â”‚  (10 tokens in, 49152 possible outputs each)           â”‚
â”‚                                                         â”‚
â”‚  We want: logits[9] (the LAST position)                â”‚
â”‚  Shape: [49152]                                         â”‚
â”‚                                                         â”‚
â”‚  This represents: "What should come next?"             â”‚
â”‚                                                         â”‚
â”‚  Example values:                                        â”‚
â”‚  - Token 3456 ("I"): probability 0.85 â­               â”‚
â”‚  - Token 7890 ("i"): probability 0.05                  â”‚
â”‚  - Token 1111 ("We"): probability 0.02                 â”‚
â”‚  - ... 49,149 other possibilities                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 6: Sample Next Token (Make a Decision)           â”‚
â”‚                                                         â”‚
â”‚  self.logits_processor.sample(&last_logits)            â”‚
â”‚                                                         â”‚
â”‚  What it does:                                          â”‚
â”‚  1. Apply temperature (0.7):                           â”‚
â”‚     - Makes the distribution more/less uniform         â”‚
â”‚     - Lower = more confident, higher = more random     â”‚
â”‚                                                         â”‚
â”‚  2. Apply Top-P (0.95):                                â”‚
â”‚     - Only consider top 95% probability mass           â”‚
â”‚     - Ignores unlikely options                         â”‚
â”‚                                                         â”‚
â”‚  3. Sample randomly from remaining options:            â”‚
â”‚     - Usually picks the most likely token              â”‚
â”‚     - But has a small chance to pick others            â”‚
â”‚                                                         â”‚
â”‚  Selected: Token 3456 ("I")                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 7: Decode Token â†’ Text                           â”‚
â”‚                                                         â”‚
â”‚  self.tokenizer.decode(&[3456], true)                  â”‚
â”‚                                                         â”‚
â”‚  Looks up token 3456 in dictionary:                    â”‚
â”‚  3456 â†’ "I"                                            â”‚
â”‚                                                         â”‚
â”‚  Result: "I"                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
OUTPUT: "I"

NOTE: This simplified version only generates ONE token!
For full sentence correction, you'd loop and generate
more tokens until you hit a stop token.
```

**Important Rust Concepts**:

1. **`&mut self`**: The function can modify the `LLMEngine` instance
   - The model's internal state might change during inference

2. **`&str`**: Borrowed string (no ownership transfer)
   - We just read the prompt, we don't need to own it

3. **`.trim()`**: Removes whitespace from start/end of string

4. **`Tensor`**: A multi-dimensional array (from Candle library)
   - Think: Excel spreadsheet, but with more dimensions!

---

### ğŸ†• NEW FILE: `src-tauri/src/commands/llm.rs`

This file contains **4 command functions** that connect the frontend (React) to the backend (Rust LLM engine).

**Analogy**: These are the **waiters** who take orders from customers and bring them to the chef!

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               COMMAND FUNCTIONS (Waiters)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. init_llm()           - "Load the chef!"            â”‚
â”‚  2. check_llm_status()   - "Is the chef ready?"        â”‚
â”‚  3. run_llm_inference()  - "Chef, make this!"          â”‚
â”‚  4. correct_text()       - "Fix grammar please!"       â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ğŸ”¨ Command 1: `init_llm()` - Start the Engine

```rust
#[tauri::command]
pub async fn init_llm(state: State<'_, AudioState>) -> Result<String, String> {
    println!("[COMMAND] init_llm requested");
    
    // Check if already loaded
    {
        let llm_guard = state.llm.lock().unwrap();
        if llm_guard.is_some() {
            return Ok("LLM already initialized".to_string());
        }
    }
    
    // Load in a blocking task (heavy operation)
    let result = tauri::async_runtime::spawn_blocking(move || LLMEngine::new())
        .await
        .map_err(|e| format!("JoinError: {}", e))?;
    
    match result {
        Ok(engine) => {
            let mut llm_guard = state.llm.lock().unwrap();
            *llm_guard = Some(engine);
            println!("[SUCCESS] Gemma LLM initialized!");
            Ok("Gemma LLM initialized successfully".to_string())
        }
        Err(e) => {
            eprintln!("[ERROR] Failed to load LLM: {}", e);
            Err(format!("Failed to load LLM: {}", e))
        }
    }
}
```

**What's Happening**: The Restaurant Analogy ğŸ½ï¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Customer asks "Can I get the special chef?"   â”‚
â”‚          (Frontend calls init_llm())                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Check if chef is already working              â”‚
â”‚                                                         â”‚
â”‚  {                                                      â”‚
â”‚      let llm_guard = state.llm.lock().unwrap();        â”‚
â”‚      if llm_guard.is_some() { return "Already here"; } â”‚
â”‚  }                                                      â”‚
â”‚                                                         â”‚
â”‚  Why the curly braces {}?                              â”‚
â”‚  - Creates a temporary scope                           â”‚
â”‚  - Lock is released when scope ends                    â”‚
â”‚  - Other threads can use `state.llm` after this        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Load the chef (heavy operation!)              â”‚
â”‚                                                         â”‚
â”‚  spawn_blocking(move || LLMEngine::new())              â”‚
â”‚                                                         â”‚
â”‚  Why blocking?                                         â”‚
â”‚  - Loading takes 2-3 seconds                           â”‚
â”‚  - Would freeze the app if done on main thread         â”‚
â”‚  - spawn_blocking runs it on a separate thread         â”‚
â”‚                                                         â”‚
â”‚  Analogy: Send someone to pick up the chef while       â”‚
â”‚           customers continue ordering food              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Wait for loading to finish                    â”‚
â”‚                                                         â”‚
â”‚  .await - "Wait for the chef to arrive"                â”‚
â”‚                                                         â”‚
â”‚  Meanwhile, other tasks can run! (Async magic âœ¨)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Check result                                  â”‚
â”‚                                                         â”‚
â”‚  match result {                                         â”‚
â”‚      Ok(engine) => {                                    â”‚
â”‚          // Chef arrived! Store him in the kitchen     â”‚
â”‚          let mut llm_guard = state.llm.lock().unwrap();â”‚
â”‚          *llm_guard = Some(engine);                    â”‚
â”‚          return Ok("Ready!");                           â”‚
â”‚      }                                                  â”‚
â”‚      Err(e) => {                                        â”‚
â”‚          // Chef couldn't come, explain why            â”‚
â”‚          return Err(format!("Failed: {}", e));         â”‚
â”‚      }                                                  â”‚
â”‚  }                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Rust Concepts**:

1. **`#[tauri::command]`**: Magic annotation that makes this function callable from JavaScript!

2. **`async`**: This function can wait without blocking
   - Like a waiter who can serve other tables while waiting for food

3. **`State<'_, AudioState>`**: Access to global app state
   - `'_` is a lifetime (compiler figures it out automatically)
   - Think: "Give me access to the shared kitchen"

4. **`lock().unwrap()`**: Thread-safe access pattern
   - `lock()`: "Wait until nobody else is using this"
   - `unwrap()`: "I'm confident this will work, panic if it doesn't"

5. **`spawn_blocking`**: Run heavy work on a separate thread
   - Prevents blocking the async runtime

6. **`*llm_guard = Some(engine)`**: Dereference and assign
   - `llm_guard` is a MutexGuard (smart pointer)
   - `*` dereferences it to access the inner value
   - `Some(engine)` wraps the engine in an Option

---

#### ğŸ”¨ Command 2: `check_llm_status()` - Is the Chef Ready?

```rust
#[tauri::command]
pub fn check_llm_status(state: State<'_, AudioState>) -> bool {
    let llm_guard = state.llm.lock().unwrap();
    llm_guard.is_some()
}
```

**Simple!** Just checks if the LLM is loaded.

```
Frontend: "Is the chef here?"
Backend:  *Looks in kitchen*
          llm is Some(engine) â†’ "Yes!" â†’ return true
          llm is None         â†’ "Nope!" â†’ return false
```

**Rust Concepts**:

- **`is_some()`**: Checks if an `Option` contains a value
  - `Option::Some(x)` â†’ `true`
  - `Option::None` â†’ `false`

---

#### ğŸ”¨ Command 3: `correct_text()` - Fix My Grammar!

This is the **main function** users interact with!

```rust
#[tauri::command]
pub async fn correct_text(
    state: State<'_, AudioState>,
    text: String
) -> Result<String, String> {
    println!("[LLM] correct_text request received. Input length: {}", text.len());
    
    let llm_handle = state.llm.clone();
    let prompt = text.clone();
    
    let output = tauri::async_runtime::spawn_blocking(move || {
        let mut llm_guard = llm_handle.lock().unwrap();
        if let Some(engine) = llm_guard.as_mut() {
            println!("[LLM] Running inference on text: '{}'", prompt.trim());
            engine.run(&prompt).map_err(|e| e.to_string())
        } else {
            eprintln!("[LLM] Error: Engine not initialized");
            Err("LLM not initialized. Please load Gemma first.".to_string())
        }
    })
    .await
    .map_err(|e| format!("Join Error: {}", e))??;
    
    println!("[LLM] Inference finished. Output length: {}", output.len());
    Ok(output)
}
```

**The Complete Journey**: ğŸš€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ‘¤ USER: Clicks "âœ¨ Correct Grammar" button           â”‚
â”‚     Text: "i went too the stor yesterday"              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“º FRONTEND (React/TypeScript):                       â”‚
â”‚                                                         â”‚
â”‚  const corrected = await invoke("correct_text", {      â”‚
â”‚      text: "i went too the stor yesterday"             â”‚
â”‚  });                                                    â”‚
â”‚                                                         â”‚
â”‚  Sends request across Tauri bridge...                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¦€ BACKEND: correct_text() receives request           â”‚
â”‚                                                         â”‚
â”‚  Parameters:                                            â”‚
â”‚  - state: Access to global app state                   â”‚
â”‚  - text: "i went too the stor yesterday"               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 1: Clone handles for thread safety               â”‚
â”‚                                                         â”‚
â”‚  let llm_handle = state.llm.clone();                   â”‚
â”‚  let prompt = text.clone();                            â”‚
â”‚                                                         â”‚
â”‚  Why clone?                                             â”‚
â”‚  - spawn_blocking moves values into new thread         â”‚
â”‚  - Arc::clone() is cheap (just copies a pointer)       â”‚
â”‚  - String::clone() copies text (needed for move)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 2: Run inference on background thread            â”‚
â”‚                                                         â”‚
â”‚  spawn_blocking(move || {                              â”‚
â”‚      // This code runs on a separate thread!           â”‚
â”‚      let mut llm_guard = llm_handle.lock().unwrap();   â”‚
â”‚      if let Some(engine) = llm_guard.as_mut() {        â”‚
â”‚          engine.run(&prompt)                           â”‚
â”‚      } else {                                           â”‚
â”‚          Err("LLM not initialized")                    â”‚
â”‚      }                                                  â”‚
â”‚  })                                                     â”‚
â”‚                                                         â”‚
â”‚  Why background thread?                                 â”‚
â”‚  - LLM inference takes 50-200ms                        â”‚
â”‚  - Would block async runtime otherwise                 â”‚
â”‚  - App stays responsive during inference               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 3: Lock and access LLM engine                    â”‚
â”‚                                                         â”‚
â”‚  let mut llm_guard = llm_handle.lock().unwrap();       â”‚
â”‚                                                         â”‚
â”‚  What happens:                                          â”‚
â”‚  1. Acquire mutex lock (wait if someone else using)    â”‚
â”‚  2. Get mutable access to Option<LLMEngine>            â”‚
â”‚  3. Now we can modify the engine (it's stateful)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 4: Check if engine exists                        â”‚
â”‚                                                         â”‚
â”‚  if let Some(engine) = llm_guard.as_mut() {            â”‚
â”‚                                                         â”‚
â”‚  "as_mut()" = Get mutable reference to inner value     â”‚
â”‚                                                         â”‚
â”‚  Option<LLMEngine>                                     â”‚
â”‚       â”‚                                                 â”‚
â”‚       â”œâ”€ Some(engine) â†’ Got it! Use it âœ…              â”‚
â”‚       â””â”€ None â†’ Not loaded! Error âŒ                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 5: Run the LLM! ğŸš€                               â”‚
â”‚                                                         â”‚
â”‚  engine.run(&prompt)                                    â”‚
â”‚                                                         â”‚
â”‚  This calls LLMEngine::run() we saw earlier!           â”‚
â”‚  - Format prompt                                        â”‚
â”‚  - Tokenize                                             â”‚
â”‚  - Run neural network                                  â”‚
â”‚  - Sample token                                         â”‚
â”‚  - Decode                                               â”‚
â”‚                                                         â”‚
â”‚  Result: "I went to the store yesterday"               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 6: Wait for thread to finish                     â”‚
â”‚                                                         â”‚
â”‚  .await                                                 â”‚
â”‚                                                         â”‚
â”‚  The spawn_blocking task completes                     â”‚
â”‚  Returns: Result<Result<String, String>, JoinError>    â”‚
â”‚            â””â”€ Inner result from engine.run()           â”‚
â”‚            â””â”€ Outer result from thread join            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 7: Handle errors with ?? (double question mark!) â”‚
â”‚                                                         â”‚
â”‚  .map_err(|e| format!("Join Error: {}", e))??          â”‚
â”‚                                                         â”‚
â”‚  First ?  - Handle JoinError (if thread panicked)      â”‚
â”‚  Second ? - Handle engine.run() error (if LLM failed)  â”‚
â”‚                                                         â”‚
â”‚  If both succeed: unwrap the inner Result<String>      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  STEP 8: Return corrected text                         â”‚
â”‚                                                         â”‚
â”‚  Ok("I went to the store yesterday")                   â”‚
â”‚                                                         â”‚
â”‚  This travels back through Tauri bridge...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“º FRONTEND: Receives response                        â”‚
â”‚                                                         â”‚
â”‚  setLiveTranscript(corrected);                         â”‚
â”‚  toast.success("Grammar corrected!");                  â”‚
â”‚                                                         â”‚
â”‚  User sees: "I went to the store yesterday" âœ…         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Rust Concepts**:

1. **`if let Some(engine) = llm_guard.as_mut()`**: Pattern matching!
   - If the Option contains a value, extract it
   - Otherwise, skip this block

2. **`??` (double question mark)**: Error propagation twice
   - First `?`: Convert JoinError to String and return if error
   - Second `?`: Convert inference error and return if error
   - Only reached if both succeed!

3. **`move ||`**: Closure that takes ownership
   - `move` transfers ownership into the closure
   - Necessary because closure runs on different thread

---

### ğŸ”„ MODIFIED FILE: `src-tauri/src/state.rs`

We added **one field** to the global state:

```rust
pub struct AudioState {
    // ... existing fields ...
    
    // NEW! The Gemma LLM engine (optional, loaded on demand)
    pub llm: Arc<Mutex<Option<crate::llm::LLMEngine>>>,
}
```

**Breaking It Down**: The Type Onion ğŸ§…

```
Arc<Mutex<Option<LLMEngine>>>
â”‚   â”‚     â”‚      â”‚
â”‚   â”‚     â”‚      â””â”€ LLMEngine = The actual machine
â”‚   â”‚     â”‚
â”‚   â”‚     â””â”€ Option<...> = Might be loaded, might not
â”‚   â”‚                      Some(engine) or None
â”‚   â”‚
â”‚   â””â”€ Mutex<...> = Thread-safe lock
â”‚                    Only one thread at a time can access
â”‚
â””â”€ Arc<...> = Atomic Reference Counter
              Multiple parts of app can share ownership
              Last one to drop cleans up
```

**Analogy**: The Shared Chef ğŸ‘¨â€ğŸ³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¢ RESTAURANT WITH SHARED CHEF                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Arc = Shared Ownership                                â”‚
â”‚  "Multiple departments can access the chef"            â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Kitchen  â”‚    â”‚ Counter  â”‚    â”‚ Drive-Thruâ”‚        â”‚
â”‚  â”‚ Staff    â”‚    â”‚ Staff    â”‚    â”‚ Staff     â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚               â”‚               â”‚               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                       â”‚                                â”‚
â”‚                       â–¼                                â”‚
â”‚            Arc<Mutex<Option<Chef>>>                    â”‚
â”‚                                                         â”‚
â”‚  Mutex = One at a Time Lock                            â”‚
â”‚  "Chef can only help one person at a time"             â”‚
â”‚  - Kitchen locks: Chef helps prepare food              â”‚
â”‚  - Counter locks: Chef answers menu questions          â”‚
â”‚  - Others wait their turn                              â”‚
â”‚                                                         â”‚
â”‚  Option = Maybe There, Maybe Not                       â”‚
â”‚  - Some(Chef) = Chef is here! ğŸ‘¨â€ğŸ³                    â”‚
â”‚  - None = Chef hasn't arrived yet / went home          â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Usage Example**:

```rust
// Get access to LLM
let llm_guard = state.llm.lock().unwrap();
//      â”‚              â”‚      â””â”€ "Panic if lock poisoned"
//      â”‚              â””â”€ "Wait and acquire lock"
//      â””â”€ MutexGuard<Option<LLMEngine>>

// Check if loaded
if llm_guard.is_some() {
    println!("LLM is ready!");
}

// Get mutable access
let mut llm_guard = state.llm.lock().unwrap();
if let Some(engine) = llm_guard.as_mut() {
    engine.run("fix this text");
}
```

---

### ğŸ“¦ MODIFIED FILE: `src-tauri/Cargo.toml`

We added **new dependencies** for machine learning:

```toml
# Candle ML Framework
candle-core = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
candle-nn = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
candle-transformers = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
tokenizers = "0.21.0"
hf-hub = "0.4"
anyhow = "1.0"
```

**What are these?**

| Dependency | Purpose | Analogy |
|------------|---------|---------|
| `candle-core` | Core tensor operations, GPU support | The workshop with tools |
| `candle-nn` | Neural network building blocks | Pre-made machine parts |
| `candle-transformers` | Transformer model implementations (Gemma, etc.) | Specialized machinery blueprints |
| `tokenizers` | Text â†” Token conversion | The translator dictionary |
| `hf-hub` | Download models from Hugging Face | The model store/library |
| `anyhow` | Better error handling | The error message system |

**Why Candle?**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MACHINE LEARNING FRAMEWORKS IN RUST                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  ğŸ”¥ PyTorch (Python)         â†’ ğŸ¦€ Candle (Rust)       â”‚
â”‚  ğŸ§  TensorFlow (Python)      â†’ ğŸ¦€ Candle (Rust)       â”‚
â”‚                                                         â”‚
â”‚  Why Candle?                                            â”‚
â”‚  âœ… Pure Rust (no Python needed!)                     â”‚
â”‚  âœ… Fast compilation                                   â”‚
â”‚  âœ… Great for desktop apps                            â”‚
â”‚  âœ… CUDA and CPU support                              â”‚
â”‚  âœ… Quantized models (smaller, faster)                â”‚
â”‚  âœ… Made by Hugging Face (trusted ML company)         â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### âš™ï¸ MODIFIED FILE: `src-tauri/.cargo/config.toml`

Added compile flags to fix linking issues:

```toml
[target.x86_64-pc-windows-msvc]
rustflags = [
    "-L",
    "C:/Users/abdul/OneDrive/Desktop/Taurscribe/taurscribe-runtime/bin",
    "-C",
    "link-arg=/NODEFAULTLIB:LIBCMT",  # â† NEW!
]

[env]
# ... existing vars ...
CFLAGS = "/MD"       # â† NEW!
CXXFLAGS = "/MD"     # â† NEW!
```

**What does this do?**

```
Problem: Windows C++ libraries conflict (LIBCMT vs MSVCRT)
         Like trying to use two different translation dictionaries
         at the same time - they contradict each other!

Solution: Tell the linker:
  1. /NODEFAULTLIB:LIBCMT = "Don't use the default static library"
  2. /MD flag = "Use the dynamic runtime library instead"

Result: âœ… Clean compilation, no linker errors!
```

**Analogy**: Choosing the Right Power Adapter

```
âŒ Before:
   [Your App] â†’ [LIBCMT] âš¡
                        â†˜
                         âŒ CONFLICT!
                        â†—
   [Candle]   â†’ [MSVCRT] âš¡

âœ… After:
   [Your App] â†’ [MSVCRT] âš¡
                        â†˜
                         âœ… SAME SOURCE!
                        â†—
   [Candle]   â†’ [MSVCRT] âš¡
```

---

### ğŸ¨ MODIFIED FILE: `src/App.tsx` (Frontend)

Added a **"Correct Grammar" button** that appears after transcription:

```tsx
{!isRecording && liveTranscript && (
  <div className="correction-container">
    <button
      onClick={async () => {
        setIsCorrecting(true);
        toast.loading("Correcting grammar...");
        try {
          const corrected = await invoke("correct_text", { text: liveTranscript });
          setLiveTranscript(corrected as string);
          toast.success("Grammar corrected!");
        } catch (e) {
          toast.error("Correction failed: " + e);
        } finally {
          setIsCorrecting(false);
        }
      }}
      disabled={isCorrecting}
      className="btn btn-correct"
    >
      {isCorrecting ? "ğŸª„ Correcting..." : "âœ¨ Correct Grammar"}
    </button>
  </div>
)}
```

**Breaking It Down**:

```tsx
// 1. Show button only when conditions are met:
!isRecording          // Not currently recording
&& liveTranscript     // Have some transcribed text

// 2. Button click handler (async function):
onClick={async () => {
    // Show loading state
    setIsCorrecting(true);
    toast.loading("Correcting grammar...");
    
    try {
        // Call Rust backend via Tauri
        const corrected = await invoke("correct_text", {
            text: liveTranscript
        });
        
        // Update UI with corrected text
        setLiveTranscript(corrected as string);
        toast.success("Grammar corrected!");
        
    } catch (e) {
        // Handle errors gracefully
        toast.error("Correction failed: " + e);
        
    } finally {
        // Always clean up loading state
        setIsCorrecting(false);
    }
}}
```

**Flow Diagram**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  USER INTERFACE                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  ğŸ“ Transcript:                                        â”‚
â”‚  "i went too the stor yesterday"                       â”‚
â”‚                                                         â”‚
â”‚  [ âœ¨ Correct Grammar ]  â† User clicks                â”‚
â”‚                                                         â”‚
â”‚  â†“ Button becomes: "ğŸª„ Correcting..."                 â”‚
â”‚  â†“ Show toast: "Correcting grammar..."                â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ invoke("correct_text", { text: "..." })
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸŒ‰ TAURI BRIDGE (Frontend â†” Backend)                 â”‚
â”‚                                                         â”‚
â”‚  Serializes request to JSON, sends to Rust             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¦€ RUST BACKEND                                       â”‚
â”‚                                                         â”‚
â”‚  correct_text() runs                                    â”‚
â”‚  â†’ Formats prompt                                       â”‚
â”‚  â†’ Runs LLM inference                                  â”‚
â”‚  â†’ Returns: "I went to the store yesterday"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸŒ‰ TAURI BRIDGE (Returns result)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  USER INTERFACE (Updated!)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  ğŸ“ Transcript:                                        â”‚
â”‚  "I went to the store yesterday" âœ…                    â”‚
â”‚                                                         â”‚
â”‚  [ âœ¨ Correct Grammar ]                                â”‚
â”‚                                                         â”‚
â”‚  âœ… Toast: "Grammar corrected!"                       â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ’… MODIFIED FILE: `src/App.css`

Added beautiful styling for the correction button:

```css
.correction-container {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: flex-end;
}

.btn-correct {
  background: linear-gradient(135deg, #7c3aed 0%, #a78bfa 100%);
  color: white;
  box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
  min-width: 180px;
  font-size: 0.9rem;
  padding: 10px 20px;
}

.btn-correct:not(:disabled):hover {
  box-shadow: 0 6px 20px rgba(124, 58, 237, 0.5);
  background: linear-gradient(135deg, #8b5cf6 0%, #c4b5fd 100%);
}
```

**Visual Preview**:

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“ Transcript                                    â•‘
â•‘  "i went too the stor yesterday"                  â•‘
â•‘  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â•‘
â•‘                                                   â•‘
â•‘                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘                    â”‚  âœ¨ Correct Grammar   â”‚    â•‘
â•‘                    â”‚  (Purple gradient ğŸ’œ) â”‚    â•‘
â•‘                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

### ğŸ§  How It All Works Together: The Complete Picture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAURSCRIBE ECOSYSTEM                           â”‚
â”‚                    With Grammar Correction                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 1: RECORDING & TRANSCRIPTION                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  1. User speaks â†’ Microphone captures audio                      â”‚
â”‚  2. Audio sent to Whisper/Parakeet ASR engine                    â”‚
â”‚  3. ASR converts speech to text                                  â”‚
â”‚  4. Raw transcript displayed: "i went too the stor yesterday"    â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 2: GRAMMAR CORRECTION (NEW!)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  5. User clicks "âœ¨ Correct Grammar"                            â”‚
â”‚  6. Frontend invokes: correct_text({ text: "..." })              â”‚
â”‚  7. Request travels through Tauri IPC bridge                     â”‚
â”‚  8. Rust backend receives request                                â”‚
â”‚  9. Locks LLM mutex, gets engine                                 â”‚
â”‚  10. Formats prompt: "<bos>text\n...\ncorrected\n"               â”‚
â”‚  11. Tokenizer converts text â†’ token IDs                         â”‚
â”‚  12. Creates tensor on GPU/CPU                                   â”‚
â”‚  13. Runs Gemma model forward pass (1B parameters!)              â”‚
â”‚  14. Samples next token using temperature + top-p                â”‚
â”‚  15. Decodes token ID â†’ text                                     â”‚
â”‚  16. Returns corrected text to frontend                          â”‚
â”‚  17. UI updates: "I went to the store yesterday" âœ…             â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“ Key Learning Points for Rust Beginners

#### 1ï¸âƒ£ **The Type System is Your Friend**

Rust's complex types might look scary, but they prevent bugs!

```rust
Arc<Mutex<Option<LLMEngine>>>
```

Each layer has a purpose:
- `Option` = Handles "might not exist"
- `Mutex` = Prevents data races
- `Arc` = Enables safe sharing

#### 2ï¸âƒ£ **Ownership & Borrowing**

```rust
// Borrowing (read-only)
fn read_text(text: &str) { ... }

// Mutable borrowing (can modify)
fn fix_text(text: &mut String) { ... }

// Taking ownership (transfer)
fn consume_text(text: String) { ... }
```

#### 3ï¸âƒ£ **Error Handling with Result**

```rust
fn might_fail() -> Result<String, String> {
    if everything_ok {
        Ok("Success!".to_string())
    } else {
        Err("Something went wrong".to_string())
    }
}

// Using it:
match might_fail() {
    Ok(value) => println!("Got: {}", value),
    Err(e) => eprintln!("Error: {}", e),
}

// Or use ? for quick propagation:
let value = might_fail()?;  // Returns error automatically if failed
```

#### 4ï¸âƒ£ **Async/Await for Non-Blocking Code**

```rust
async fn load_heavy_data() -> Result<Data> {
    // This might take seconds, but won't block other tasks!
    let data = download_from_internet().await?;
    Ok(data)
}
```

#### 5ï¸âƒ£ **Lifetimes (The `'_` Thing)**

```rust
State<'_, AudioState>
//    â””â”€ "This reference lives for some duration"
//       Compiler figures it out automatically!
```

---

### ğŸ“Š Performance Characteristics

| Metric | Value | Notes |
|--------|-------|-------|
| **Model Size** | ~1 GB (quantized) | Q4_K_M quantization |
| **Load Time** | 2-3 seconds | First initialization |
| **Inference Time (GPU)** | 50-200ms | Depends on input length |
| **Inference Time (CPU)** | 500-2000ms | Much slower without GPU |
| **Memory Usage** | ~2 GB RAM | Includes model + runtime |
| **Thread Safety** | âœ… Yes | Mutex-protected |
| **Concurrent Users** | 1 at a time | Mutex serializes access |

---

### ğŸ”® Future Improvements & Possibilities

#### 1. **Multi-Turn Generation**
Currently generates only one token. Could loop to generate full sentences:

```rust
pub fn run(&mut self, prompt: &str) -> Result<String> {
    let mut tokens = vec![...];  // Initial tokens
    
    for _ in 0..MAX_TOKENS {
        let logits = self.model.forward(&input, position)?;
        let next_token = self.logits_processor.sample(&last_logits)?;
        
        if next_token == EOS_TOKEN { break; }  // Stop at end
        
        tokens.push(next_token);
    }
    
    self.tokenizer.decode(&tokens, true)
}
```

#### 2. **Streaming Output**
Show words as they generate (like ChatGPT):

```rust
// Send tokens one-by-one to frontend
app_handle.emit_all("llm_token", TokenEvent { token: word })?;
```

#### 3. **Model Swapping**
Let users choose different models:
- Small (135M params) - Fast
- Medium (360M params) - Balanced
- Large (1.7B params) - Best quality

#### 4. **Context Awareness**
Use previous transcripts for better corrections:

```rust
let prompt = format!(
    "Previous: {}\nCurrent: {}\nCorrected:",
    previous_context,
    current_text
);
```

#### 5. **Batch Processing**
Correct multiple transcripts at once for efficiency.

---

### ğŸ› Common Issues & Solutions

#### Issue 1: "Model file not found"

```
Error: Model file not found at: c:\...\GRMR-V3-G1B-Q4_K_M.gguf
```

**Solution**: Download the model and place it in the correct directory:
```
taurscribe-runtime/
  models/
    GRMR-V3-G1B-GGUF/
      GRMR-V3-G1B-Q4_K_M.gguf
      tokenizer.json
```

#### Issue 2: "CUDA not available"

```
[LLM] Using device: Cpu
```

**This is OK!** The app automatically falls back to CPU. It will be slower but still work.

To enable GPU:
1. Install CUDA Toolkit (NVIDIA only)
2. Rebuild the app
3. Check with `nvidia-smi` that your GPU is recognized

#### Issue 3: "Linking error: LIBCMT conflict"

```
error: duplicate symbol found in LIBCMT and MSVCRT
```

**Solution**: Already fixed in `.cargo/config.toml`!
```toml
rustflags = ["-C", "link-arg=/NODEFAULTLIB:LIBCMT"]
```

#### Issue 4: Inference is very slow

**Possible causes**:
1. Using CPU instead of GPU (50x slower)
2. Model is too large
3. Input text is very long

**Solutions**:
- Check if GPU is enabled: Look for "Using device: Cuda(0)"
- Try a smaller model (Q4_K_M is already quantized)
- Limit input text length to 512 tokens

---

### ğŸ“š Dependencies Deep Dive

#### **Candle Framework**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CANDLE ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                   â”‚
â”‚  candle-core:                                    â”‚
â”‚  â”œâ”€ Tensor operations (add, multiply, etc.)      â”‚
â”‚  â”œâ”€ Device management (CPU, CUDA, Metal)         â”‚
â”‚  â”œâ”€ Automatic differentiation (for training)     â”‚
â”‚  â””â”€ GGUF file loading (quantized models)         â”‚
â”‚                                                   â”‚
â”‚  candle-nn:                                      â”‚
â”‚  â”œâ”€ Neural network layers (Linear, Conv, etc.)   â”‚
â”‚  â”œâ”€ Activation functions (ReLU, GELU, etc.)      â”‚
â”‚  â””â”€ Normalization layers (LayerNorm, etc.)       â”‚
â”‚                                                   â”‚
â”‚  candle-transformers:                            â”‚
â”‚  â”œâ”€ Pre-built model architectures                â”‚
â”‚  â”‚   â”œâ”€ Gemma (Google)                           â”‚
â”‚  â”‚   â”œâ”€ LLaMA (Meta)                             â”‚
â”‚  â”‚   â”œâ”€ Mistral, Phi, etc.                       â”‚
â”‚  â”œâ”€ Tokenization utilities                       â”‚
â”‚  â””â”€ Generation helpers (sampling, etc.)          â”‚
â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Key External Libraries**

| Library | Purpose | Used For |
|---------|---------|----------|
| `tokenizers` | Hugging Face tokenizer library | Convert text â†” token IDs |
| `hf-hub` | Download models from Hugging Face | Model distribution |
| `anyhow` | Ergonomic error handling | Better error messages |

---

### ğŸ¯ Summary: What We Added

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BEFORE: Speech-to-text transcription                  â”‚
â”‚                                                         â”‚
â”‚  ğŸ¤ â†’ ğŸ§  Whisper/Parakeet â†’ ğŸ“ Raw Text               â”‚
â”‚                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AFTER: Speech-to-text + AI grammar correction!        â”‚
â”‚                                                         â”‚
â”‚  ğŸ¤ â†’ ğŸ§  Whisper/Parakeet â†’ ğŸ“ Raw Text               â”‚
â”‚                                  â†“                      â”‚
â”‚                             [âœ¨ Button]                â”‚
â”‚                                  â†“                      â”‚
â”‚                      ğŸª„ Gemma LLM (1B params)          â”‚
â”‚                                  â†“                      â”‚
â”‚                          ğŸ“ Perfect Text âœ…            â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Files Created**:
- âœ… `src-tauri/src/llm.rs` (LLM engine)
- âœ… `src-tauri/src/commands/llm.rs` (Command handlers)

**Files Modified**:
- ğŸ”„ `src-tauri/src/state.rs` (Added LLM to global state)
- ğŸ”„ `src-tauri/src/lib.rs` (Registered commands)
- ğŸ”„ `src-tauri/Cargo.toml` (Added Candle dependencies)
- ğŸ”„ `src-tauri/.cargo/config.toml` (Fixed linking)
- ğŸ”„ `src/App.tsx` (Added correction button)
- ğŸ”„ `src/App.css` (Styled the button)

**Total Lines Added**: ~2,700 lines
- Rust code: ~200 lines
- Dependencies (Cargo.lock): ~800 lines
- Documentation (ARCHITECTURE.md): ~1,670 lines
- Frontend: ~30 lines

---

### ğŸ“ Recommended Learning Path

If you're new to Rust and want to understand this code better:

1. **Learn Rust Basics** (1-2 weeks)
   - Variables and types
   - Functions and ownership
   - Structs and enums
   - Error handling with Result

2. **Learn Async Rust** (1 week)
   - async/await syntax
   - Tokio/async-runtime basics
   - spawn_blocking vs spawn

3. **Learn Concurrency** (1 week)
   - Arc and Mutex
   - Thread safety
   - Channels

4. **Machine Learning Basics** (Optional)
   - What are tensors?
   - How do neural networks work?
   - What is quantization?

**Resources**:
- ğŸ“– [The Rust Book](https://doc.rust-lang.org/book/)
- ğŸ“– [Async Book](https://rust-lang.github.io/async-book/)
- ğŸ“– [Candle Examples](https://github.com/huggingface/candle/tree/main/candle-examples)

---

### ğŸ† Congratulations!

You now understand how Taurscribe added AI-powered grammar correction! You learned about:

- âœ… Rust async programming
- âœ… Machine learning inference
- âœ… Thread-safe state management
- âœ… Frontend-backend communication
- âœ… Error handling patterns
- âœ… The Candle ML framework
- âœ… Neural network basics

Keep exploring and building amazing things! ğŸš€

---

## ğŸ“š Complete Rust File Reference (Detailed)

This section provides **in-depth, line-by-line documentation** for every Rust file in the Taurscribe codebase. Each file is explained with:
- Complete struct/enum definitions with field explanations
- Every function with step-by-step breakdowns
- Where types and values come from (imports vs local definitions)
- Visual flow diagrams
- Rust concepts explained

---

### ğŸ“ File Structure Overview

```
src-tauri/
â”œâ”€â”€ build.rs                 # Build-time configuration (CUDA paths, macOS targets)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # Entry point - calls lib::run()
â”‚   â”œâ”€â”€ lib.rs               # App orchestrator - initializes everything
â”‚   â”œâ”€â”€ state.rs             # Global application state (AudioState)
â”‚   â”œâ”€â”€ types.rs             # Shared type definitions (enums, structs)
â”‚   â”œâ”€â”€ utils.rs             # Helper functions (clean_transcript, get_recordings_dir)
â”‚   â”œâ”€â”€ audio.rs             # Audio stream wrappers (SendStream, RecordingHandle)
â”‚   â”œâ”€â”€ whisper.rs           # Whisper AI engine manager (781 lines)
â”‚   â”œâ”€â”€ parakeet.rs          # Parakeet/Nemotron ASR manager (615 lines)
â”‚   â”œâ”€â”€ vad.rs               # Voice Activity Detection (215 lines)
â”‚   â”œâ”€â”€ llm.rs               # Gemma LLM for grammar correction (98 lines)
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ mod.rs           # Module re-exports
â”‚   â”‚   â”œâ”€â”€ recording.rs     # start_recording, stop_recording commands
â”‚   â”‚   â”œâ”€â”€ transcription.rs # list_sample_files, benchmark_test commands
â”‚   â”‚   â”œâ”€â”€ models.rs        # list_models, switch_model commands
â”‚   â”‚   â”œâ”€â”€ settings.rs      # get_backend_info, set_active_engine commands
â”‚   â”‚   â”œâ”€â”€ llm.rs           # init_llm, correct_text commands
â”‚   â”‚   â””â”€â”€ misc.rs          # greet (test command)
â”‚   â”œâ”€â”€ hotkeys/
â”‚   â”‚   â”œâ”€â”€ mod.rs           # Module re-exports
â”‚   â”‚   â””â”€â”€ listener.rs      # Global hotkey listener (Ctrl+Win)
â”‚   â””â”€â”€ tray/
â”‚       â”œâ”€â”€ mod.rs           # Module re-exports
â”‚       â””â”€â”€ icons.rs         # System tray setup and icon management
```

---

## ğŸ”´ `src-tauri/src/main.rs` (7 lines)

**Purpose**: The absolute entry point of the Rust application.

### Complete File

```rust
// Line 1-2: Prevent Windows from opening a console window in release builds
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// Line 4-6: Main function - calls the library's run() function
fn main() {
    taurscribe_lib::run()
}
```

### Line-by-Line Explanation

#### Line 1-2: Compiler Attribute
```rust
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
```

| Component | Meaning |
|-----------|---------|
| `#![]` | Inner attribute - applies to entire file/crate |
| `cfg_attr(condition, attribute)` | Conditionally apply an attribute |
| `not(debug_assertions)` | True when building in release mode |
| `windows_subsystem = "windows"` | Don't show console window on Windows |

**Why**: In release mode, the app runs as a GUI-only application without a console window.

#### Lines 4-6: Main Function
```rust
fn main() {
    taurscribe_lib::run()
}
```

| Component | Meaning |
|-----------|---------|
| `fn main()` | Standard Rust entry point |
| `taurscribe_lib` | The library crate name (from `Cargo.toml` â†’ `name = "taurscribe_lib"`) |
| `::run()` | Calls the `run()` function exported from `lib.rs` |

### Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Operating System                        â”‚
â”‚      â”‚                                   â”‚
â”‚      â”‚ Executes binary                   â”‚
â”‚      â–¼                                   â”‚
â”‚  main.rs::main()                         â”‚
â”‚      â”‚                                   â”‚
â”‚      â”‚ Calls                             â”‚
â”‚      â–¼                                   â”‚
â”‚  lib.rs::run()                           â”‚
â”‚      â”‚                                   â”‚
â”‚      â”‚ Initializes everything            â”‚
â”‚      â”‚ Starts Tauri app                  â”‚
â”‚      â–¼                                   â”‚
â”‚  [App Running]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŸ¢ `src-tauri/src/lib.rs` (119 lines)

**Purpose**: The main orchestrator that initializes all AI engines and starts the Tauri application.

### Imports & Module Declarations (Lines 1-18)

```rust
// Lines 1-12: Declare submodules
mod audio;      // Audio stream handling
mod commands;   // Tauri command handlers
mod hotkeys;    // Global hotkey listener
mod llm;        // Gemma LLM engine
mod parakeet;   // Parakeet ASR engine
mod state;      // Global state struct
mod tray;       // System tray management
mod types;      // Shared type definitions
mod utils;      // Helper functions
mod vad;        // Voice Activity Detection
mod whisper;    // Whisper AI engine

// Lines 14-18: Import specific items from our modules
use parakeet::ParakeetManager;
use state::AudioState;
use vad::VADManager;
use whisper::WhisperManager;
```

### The `run()` Function (Lines 20-118)

This is the main entry point called from `main.rs`.

#### Step 1: Initialize Whisper AI (Lines 24-47)

```rust
// Line 24-26: Create a new WhisperManager (not loaded yet)
println!("[INFO] Initializing Whisper transcription engine...");
let whisper = WhisperManager::new();

// Lines 28-37: Load model in a separate thread with large stack
let (whisper, init_result) = std::thread::Builder::new()
    .stack_size(8 * 1024 * 1024) // 8 MiB stack (needed for large models)
    .spawn(move || {
        let mut whisper = whisper;           // Take ownership
        let res = whisper.initialize(None);  // Load default model
        (whisper, res)                       // Return both
    })
    .expect("Failed to spawn whisper init thread")
    .join()                                  // Wait for thread to finish
    .expect("Whisper init thread panicked");

// Lines 39-47: Handle initialization result
match init_result {
    Ok(backend_msg) => {
        println!("[SUCCESS] {}", backend_msg);  // e.g., "Backend: CUDA"
    }
    Err(e) => {
        eprintln!("[ERROR] Failed to initialize Whisper: {}", e);
        eprintln!("   Transcription will be disabled.");
    }
}
```

**Why separate thread?**: Loading AI models requires large stack space (8MB vs default 2MB) to avoid stack overflow.

#### Step 2: Initialize VAD (Lines 49-55)

```rust
println!("[INFO] Initializing Voice Activity Detection...");
let vad = VADManager::new().unwrap_or_else(|e| {
    eprintln!("[ERROR] Failed to initialize VAD: {}", e);
    panic!("VAD initialization failed");  // VAD is required
});
println!("[SUCCESS] VAD initialized successfully");
```

#### Step 3: Initialize Parakeet (Lines 57-68)

```rust
println!("[INFO] Initializing Parakeet ASR manager...");
let mut parakeet = ParakeetManager::new();

// Try to load Nemotron model first, then fallback to any available
println!("[INFO] Attempting to auto-load Parakeet model...");
match parakeet.initialize(Some("nemotron:nemotron")) {
    Ok(msg) => println!("[SUCCESS] {}", msg),
    Err(_) => match parakeet.initialize(None) {  // Fallback
        Ok(msg) => println!("[SUCCESS] Fallback load: {}", msg),
        Err(e) => eprintln!("[WARN] No Parakeet models loaded: {}", e),
    },
}
```

#### Step 4: Build Tauri App (Lines 70-118)

```rust
tauri::Builder::default()
    // Register plugins
    .plugin(tauri_plugin_opener::init())      // Open URLs/files
    .plugin(tauri_plugin_store::Builder::default().build())  // Settings storage
    
    // Register global state
    .manage(AudioState::new(whisper, parakeet, vad))
    
    // Setup callback (runs once after window is created)
    .setup(|app| {
        tray::setup_tray(app)?;               // Create system tray
        
        // Start hotkey listener in background
        let app_handle = app.handle().clone();
        std::thread::spawn(move || {
            hotkeys::start_hotkey_listener(app_handle);
        });
        
        println!("[INFO] Global hotkey listener started (Ctrl+Win to record)");
        Ok(())
    })
    
    // Window close handler (minimize to tray instead)
    .on_window_event(|window, event| {
        if let tauri::WindowEvent::CloseRequested { api, .. } = event {
            let _ = window.hide();            // Hide window
            api.prevent_close();              // Don't actually close
            println!("[INFO] Window minimized to tray");
        }
    })
    
    // Register all Tauri commands (callable from frontend)
    .invoke_handler(tauri::generate_handler![
        commands::greet,
        commands::start_recording,
        commands::stop_recording,
        // ... 15 more commands
    ])
    
    // Run the app!
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
```

### Complete Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        lib.rs::run()                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  STEP 1: Initialize Whisper                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ WhisperManager::new()                     â”‚                   â”‚
â”‚  â”‚      â†“                                    â”‚                   â”‚
â”‚  â”‚ spawn thread (8MB stack)                  â”‚                   â”‚
â”‚  â”‚      â†“                                    â”‚                   â”‚
â”‚  â”‚ whisper.initialize(None)                  â”‚                   â”‚
â”‚  â”‚      â†“                                    â”‚                   â”‚
â”‚  â”‚ Load ggml-tiny.en-q5_1.bin               â”‚                   â”‚
â”‚  â”‚      â†“                                    â”‚                   â”‚
â”‚  â”‚ GPU warmup                                â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â†“                                           â”‚
â”‚  STEP 2: Initialize VAD                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ VADManager::new()                         â”‚                   â”‚
â”‚  â”‚ â†’ Energy-based speech detection           â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â†“                                           â”‚
â”‚  STEP 3: Initialize Parakeet                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ ParakeetManager::new()                    â”‚                   â”‚
â”‚  â”‚      â†“                                    â”‚                   â”‚
â”‚  â”‚ parakeet.initialize("nemotron:nemotron") â”‚                   â”‚
â”‚  â”‚ â†’ Try CUDA â†’ Try DirectML â†’ Fallback CPU â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â†“                                           â”‚
â”‚  STEP 4: Build Tauri App                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ Register plugins                          â”‚                   â”‚
â”‚  â”‚ Register state (AudioState)               â”‚                   â”‚
â”‚  â”‚ Setup tray + hotkey listener              â”‚                   â”‚
â”‚  â”‚ Register 19 commands                      â”‚                   â”‚
â”‚  â”‚ Start event loop                          â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŸ£ `src-tauri/src/state.rs` (55 lines)

**Purpose**: Defines the global application state that persists throughout the app's lifetime.

### Imports (Lines 1-6)

```rust
use crate::audio::RecordingHandle;      // From audio.rs
use crate::parakeet::ParakeetManager;   // From parakeet.rs
use crate::types::{ASREngine, AppState}; // From types.rs
use crate::vad::VADManager;             // From vad.rs
use crate::whisper::WhisperManager;     // From whisper.rs
use std::sync::{Arc, Mutex};            // Thread-safe wrappers
```

### The `AudioState` Struct (Lines 8-38)

```rust
pub struct AudioState {
    // Field 1: Active recording (None if not recording)
    pub recording_handle: Mutex<Option<RecordingHandle>>,
    
    // Field 2: Whisper AI engine (shared across threads)
    pub whisper: Arc<Mutex<WhisperManager>>,
    
    // Field 3: Parakeet AI engine (shared across threads)
    pub parakeet: Arc<Mutex<ParakeetManager>>,
    
    // Field 4: Voice Activity Detector (shared)
    pub vad: Arc<Mutex<VADManager>>,
    
    // Field 5: Path to last recorded WAV file
    pub last_recording_path: Mutex<Option<String>>,
    
    // Field 6: Current app state (Ready/Recording/Processing)
    pub current_app_state: Mutex<AppState>,
    
    // Field 7: Which ASR engine is active (Whisper or Parakeet)
    pub active_engine: Mutex<ASREngine>,
    
    // Field 8: Accumulated transcript during recording
    pub session_transcript: Arc<Mutex<String>>,
    
    // Field 9: Optional LLM engine (loaded on demand)
    pub llm: Arc<Mutex<Option<crate::llm::LLMEngine>>>,
}
```

### Field Details Table

| Field | Type | Initial Value | Purpose |
|-------|------|---------------|---------|
| `recording_handle` | `Mutex<Option<RecordingHandle>>` | `None` | Holds mic stream when recording |
| `whisper` | `Arc<Mutex<WhisperManager>>` | Initialized | Whisper AI engine |
| `parakeet` | `Arc<Mutex<ParakeetManager>>` | Initialized | Parakeet ASR engine |
| `vad` | `Arc<Mutex<VADManager>>` | Initialized | Voice Activity Detection |
| `last_recording_path` | `Mutex<Option<String>>` | `None` | Path to saved WAV file |
| `current_app_state` | `Mutex<AppState>` | `Ready` | Tray icon state |
| `active_engine` | `Mutex<ASREngine>` | `Whisper` | Selected transcription engine |
| `session_transcript` | `Arc<Mutex<String>>` | Empty string | Live transcript accumulator |
| `llm` | `Arc<Mutex<Option<LLMEngine>>>` | `None` | Gemma LLM (lazy loaded) |

### Why `Arc<Mutex<T>>`?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Arc<Mutex<T>> Explained                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Arc (Atomic Reference Counting):                           â”‚
â”‚  â”œâ”€ Allows MULTIPLE owners of the same data                 â”‚
â”‚  â”œâ”€ Reference count is thread-safe (atomic operations)      â”‚
â”‚  â””â”€ Data is deallocated when count reaches 0                â”‚
â”‚                                                              â”‚
â”‚  Mutex (Mutual Exclusion):                                  â”‚
â”‚  â”œâ”€ Only ONE thread can access data at a time               â”‚
â”‚  â”œâ”€ .lock() waits if another thread has the lock            â”‚
â”‚  â””â”€ .unwrap() panics if lock is poisoned (rare)             â”‚
â”‚                                                              â”‚
â”‚  Combined:                                                   â”‚
â”‚  â”œâ”€ Multiple threads can SHARE ownership (Arc)              â”‚
â”‚  â””â”€ But only ONE can ACCESS at a time (Mutex)               â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Constructor (Lines 40-54)

```rust
impl AudioState {
    pub fn new(whisper: WhisperManager, parakeet: ParakeetManager, vad: VADManager) -> Self {
        Self {
            recording_handle: Mutex::new(None),
            whisper: Arc::new(Mutex::new(whisper)),
            parakeet: Arc::new(Mutex::new(parakeet)),
            vad: Arc::new(Mutex::new(vad)),
            last_recording_path: Mutex::new(None),
            current_app_state: Mutex::new(AppState::Ready),
            active_engine: Mutex::new(ASREngine::Whisper),
            session_transcript: Arc::new(Mutex::new(String::new())),
            llm: Arc::new(Mutex::new(None)),
        }
    }
}
```

---

## ğŸŸ¡ `src-tauri/src/types.rs` (31 lines)

**Purpose**: Shared type definitions used across multiple files.

### Complete File with Explanations

```rust
/// AppState - Represents the current state of the application
/// Used to determine tray icon color
#[derive(Debug, Clone, Copy, PartialEq)]  // Derive common traits
pub enum AppState {
    Ready,      // ğŸŸ¢ Green - Waiting for user input
    Recording,  // ğŸ”´ Red - Microphone is active
    Processing, // ğŸŸ¡ Yellow - Transcribing audio
}

/// ASREngine - The two speech recognition engines available
#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum ASREngine {
    Whisper,   // OpenAI Whisper (via whisper.cpp)
    Parakeet,  // NVIDIA Parakeet (via onnxruntime)
}

/// TranscriptionChunk - Payload sent to frontend during live transcription
#[derive(Debug, Clone, serde::Serialize)]
pub struct TranscriptionChunk {
    pub text: String,           // The transcribed text
    pub processing_time_ms: u32, // How long it took (milliseconds)
    pub method: String,         // "Whisper" or "Parakeet"
}

/// SampleFile - Information about a test audio file
#[derive(serde::Serialize)]
pub struct SampleFile {
    pub name: String,  // Filename, e.g., "test.wav"
    pub path: String,  // Full path on disk
}
```

### Derive Macros Explained

| Macro | Purpose |
|-------|---------|
| `Debug` | Allows `println!("{:?}", value)` |
| `Clone` | Allows `.clone()` to copy the value |
| `Copy` | Allows implicit copying (small types only) |
| `PartialEq` | Allows `==` and `!=` comparisons |
| `serde::Serialize` | Allows conversion to JSON (for frontend) |
| `serde::Deserialize` | Allows conversion from JSON |

---

## ğŸŸ  `src-tauri/src/utils.rs` (47 lines)

**Purpose**: Helper utility functions used across the application.

### Function 1: `clean_transcript()` (Lines 1-31)

**Purpose**: Post-processes raw ASR output to fix common formatting issues.

```rust
pub fn clean_transcript(text: &str) -> String {
    let mut cleaned = text.trim().to_string();

    // Fix 1: Remove space before punctuation
    cleaned = cleaned.replace(" ,", ",");   // "hello , world" â†’ "hello, world"
    cleaned = cleaned.replace(" .", ".");   // "hello ." â†’ "hello."
    cleaned = cleaned.replace(" ?", "?");
    cleaned = cleaned.replace(" !", "!");
    cleaned = cleaned.replace(" %", "%");   // "50 %" â†’ "50%"

    // Fix 2: Remove double spaces
    while cleaned.contains("  ") {
        cleaned = cleaned.replace("  ", " ");
    }

    // Fix 3: Capitalize first letter
    if let Some(first) = cleaned.chars().next() {
        if first.is_lowercase() {
            let mut c = cleaned.chars();
            cleaned = match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            };
        }
    }

    cleaned
}
```

### Function 2: `get_recordings_dir()` (Lines 33-46)

**Purpose**: Returns the path to save recordings, creating it if needed.

```rust
pub fn get_recordings_dir() -> Result<std::path::PathBuf, String> {
    // Get OS-specific AppData folder
    // Windows: C:\Users\Name\AppData\Local
    // macOS: ~/Library/Application Support
    // Linux: ~/.local/share
    let app_data = dirs::data_local_dir()
        .ok_or("Could not find AppData directory")?;

    // Create: AppData/Taurscribe/temp
    let recordings_dir = app_data.join("Taurscribe").join("temp");

    // Create folder if it doesn't exist
    std::fs::create_dir_all(&recordings_dir)
        .map_err(|e| format!("Failed to create recordings directory: {}", e))?;

    Ok(recordings_dir)
}
```

### Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  get_recordings_dir() Flow                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Windows:                                                   â”‚
â”‚  C:\Users\abdul\AppData\Local                              â”‚
â”‚           â”‚                                                 â”‚
â”‚           â””â”€â–º Taurscribe                                   â”‚
â”‚                   â”‚                                         â”‚
â”‚                   â””â”€â–º temp                                 â”‚
â”‚                         â”‚                                   â”‚
â”‚                         â””â”€â–º recording_1706850000.wav       â”‚
â”‚                                                             â”‚
â”‚  macOS:                                                     â”‚
â”‚  ~/Library/Application Support                             â”‚
â”‚           â”‚                                                 â”‚
â”‚           â””â”€â–º Taurscribe/temp/                             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”µ `src-tauri/src/audio.rs` (17 lines)

**Purpose**: Wrapper types for thread-safe audio stream handling.

### Complete File

```rust
use crossbeam_channel::Sender;

/// SendStream - Wrapper to make cpal::Stream thread-safe
/// By default, audio streams can't be moved between threads
/// We implement Send + Sync manually to enable this
#[allow(dead_code)]
pub struct SendStream(pub cpal::Stream);

// UNSAFE: We promise to only drop this, never access across threads
unsafe impl Send for SendStream {}  // Can be moved to another thread
unsafe impl Sync for SendStream {}  // Can be shared between threads

/// RecordingHandle - Holds all resources needed during active recording
pub struct RecordingHandle {
    pub stream: SendStream,           // The mic connection (keeps recording alive)
    pub file_tx: Sender<Vec<f32>>,    // Channel to file writer thread
    pub whisper_tx: Sender<Vec<f32>>, // Channel to AI transcription thread
}
```

### Why `unsafe impl Send/Sync`?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Thread Safety in Rust                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  By default, cpal::Stream is NOT thread-safe because:       â”‚
â”‚  - It contains raw pointers to audio hardware               â”‚
â”‚  - The compiler can't verify safety automatically           â”‚
â”‚                                                             â”‚
â”‚  We manually implement Send + Sync because:                 â”‚
â”‚  - We ONLY drop the stream (never read/write)               â”‚
â”‚  - Dropping is always safe from any thread                  â”‚
â”‚  - We control all access to this wrapper                    â”‚
â”‚                                                             â”‚
â”‚  âš ï¸ WARNING: This is unsafe! Only do this if you're 100%   â”‚
â”‚     sure about the safety guarantees.                       â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How RecordingHandle Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Recording Architecture                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚  Microphone â”‚ â”€â”€â”€â”€â”€â”€â–º Audio samples (f32[])              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚                          â”‚
â”‚                                  â”‚                          â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                    â”‚                           â”‚            â”‚
â”‚                    â–¼                           â–¼            â”‚
â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚             â”‚ file_tx  â”‚                â”‚whisper_txâ”‚        â”‚
â”‚             â”‚ (Channel)â”‚                â”‚ (Channel)â”‚        â”‚
â”‚             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                  â”‚                           â”‚              â”‚
â”‚                  â–¼                           â–¼              â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚         â”‚ File Writer    â”‚          â”‚ AI Transcriber â”‚      â”‚
â”‚         â”‚ Thread         â”‚          â”‚ Thread         â”‚      â”‚
â”‚         â”‚                â”‚          â”‚                â”‚      â”‚
â”‚         â”‚ Saves to .wav  â”‚          â”‚ Whisper/       â”‚      â”‚
â”‚         â”‚                â”‚          â”‚ Parakeet AI    â”‚      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”· `src-tauri/src/whisper.rs` (781 lines)

**Purpose**: Complete Whisper AI transcription engine manager.

### Imports (Lines 1-8)

```rust
use rubato::{
    Resampler, SincFixedIn, SincInterpolationParameters, 
    SincInterpolationType, WindowFunction,
};  // Audio resampling library
use std::ffi::c_void;      // C interop (raw pointers)
use std::os::raw::c_char;  // C interop (strings)
use whisper_rs::{
    set_log_callback, FullParams, SamplingStrategy, 
    WhisperContext, WhisperContextParameters,
};  // Whisper AI library bindings
```

### Enum: `GpuBackend` (Lines 13-31)

```rust
#[derive(Debug, Clone)]
pub enum GpuBackend {
    Cuda,   // NVIDIA GPUs - fastest
    Vulkan, // AMD/Intel/Other GPUs
    Cpu,    // Processor - slowest fallback
}

impl std::fmt::Display for GpuBackend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GpuBackend::Cuda => write!(f, "CUDA"),
            GpuBackend::Vulkan => write!(f, "Vulkan"),
            GpuBackend::Cpu => write!(f, "CPU"),
        }
    }
}
```

### Struct: `ModelInfo` (Lines 33-41)

```rust
#[derive(Debug, Clone, serde::Serialize)]
pub struct ModelInfo {
    pub id: String,           // "tiny.en-q5_1"
    pub display_name: String, // "Tiny English (Q5_1)"
    pub file_name: String,    // "ggml-tiny.en-q5_1.bin"
    pub size_mb: f32,         // 75.5
}
```

### Struct: `WhisperManager` (Lines 43-50)

```rust
pub struct WhisperManager {
    context: Option<WhisperContext>,  // AI model (None if not loaded)
    last_transcript: String,          // Accumulated context for coherence
    backend: GpuBackend,              // Current hardware (CPU/CUDA/Vulkan)
    current_model: Option<String>,    // "tiny.en-q5_1"
    resampler: Option<(u32, usize, Box<SincFixedIn<f32>>)>,  // Cached resampler
}
```

### Field Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WhisperManager Field Lifecycle                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Field           â”‚ new()         â”‚ initialize()    â”‚ transcribe()â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  context         â”‚ None          â”‚ Some(ctx)       â”‚ Read        â”‚
â”‚  last_transcript â”‚ ""            â”‚ (unchanged)     â”‚ Appended    â”‚
â”‚  backend         â”‚ Cpu           â”‚ Cuda/Vulkan/Cpu â”‚ Read        â”‚
â”‚  current_model   â”‚ None          â”‚ Some("model")   â”‚ Read        â”‚
â”‚  resampler       â”‚ None          â”‚ (unchanged)     â”‚ Created*    â”‚
â”‚                                                                  â”‚
â”‚  * Resampler is lazily created on first transcribe_chunk call   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Method: `new()` (Lines 65-75)

```rust
pub fn new() -> Self {
    Self {
        context: None,                  // No AI loaded
        last_transcript: String::new(), // Empty context
        backend: GpuBackend::Cpu,       // Assume CPU
        current_model: None,            // No model
        resampler: None,                // Create when needed
    }
}
```

### Method: `get_models_dir()` (Lines 77-108)

**Purpose**: Finds the directory containing Whisper model files.

```rust
fn get_models_dir() -> Result<std::path::PathBuf, String> {
    // Check these paths in order
    let possible_paths = [
        "taurscribe-runtime/models",        // From project root
        "../taurscribe-runtime/models",     // One level up
        "../../taurscribe-runtime/models",  // Two levels up
    ];

    for path in possible_paths {
        // Try to convert to absolute path
        if let Ok(canonical) = std::fs::canonicalize(path) {
            if canonical.is_dir() {
                // Verify it's the right folder
                if let Ok(entries) = std::fs::read_dir(&canonical) {
                    for entry in entries.flatten() {
                        if let Some(name) = entry.file_name().to_str() {
                            // Look for ggml-*.bin files
                            if name.starts_with("ggml-") && name.ends_with(".bin") {
                                return Ok(canonical);  // Found!
                            }
                        }
                    }
                }
            }
        }
    }

    Err("Could not find models directory containing ggml models".to_string())
}
```

### Method: `initialize()` (Lines 225-277)

**Purpose**: Load a Whisper model from disk into memory (and GPU).

```rust
pub fn initialize(&mut self, model_id: Option<&str>) -> Result<String, String> {
    // Step 1: Silence C++ logs
    unsafe { set_log_callback(None, std::ptr::null_mut()); }

    // Step 2: Find models directory
    let models_dir = Self::get_models_dir()?;

    // Step 3: Determine which model to load
    let target_model = model_id.unwrap_or("tiny.en-q5_1");
    let file_name = format!("ggml-{}.bin", target_model);
    let absolute_path = models_dir.join(&file_name);

    // Step 4: Verify file exists
    if !absolute_path.exists() {
        return Err(format!("Model file not found: {}", absolute_path.display()));
    }

    // Step 5: Try GPU first, fallback to CPU
    let (ctx, backend) = self
        .try_gpu(&absolute_path)
        .or_else(|_| self.try_cpu(&absolute_path))?;

    // Step 6: Save loaded state
    self.context = Some(ctx);
    self.backend = backend.clone();
    self.current_model = Some(target_model.to_string());

    // Step 7: GPU warm-up (first inference is slow)
    let warmup_audio = vec![0.0_f32; 16000];  // 1 second of silence
    self.transcribe_chunk(&warmup_audio, 16000).ok();

    Ok(format!("Backend: {}", backend))
}
```

### Method: `transcribe_chunk()` (Lines 343-458)

**Purpose**: Real-time transcription of audio chunks (6 seconds).

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],        // Audio data
    input_sample_rate: u32, // e.g., 48000 Hz
) -> Result<String, String> {
    // Get loaded model context
    let ctx = self.context.as_mut()
        .ok_or("Whisper context not initialized")?;

    // STEP 1: Resample to 16kHz if needed
    let audio_data = if input_sample_rate != 16000 {
        // Create/reuse resampler
        // ... resampling logic ...
    } else {
        samples.to_vec()
    };

    // STEP 2: Create transcription state
    let mut state = ctx.create_state()?;

    // STEP 3: Configure parameters
    let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
    params.set_n_threads(4);         // CPU threads
    params.set_translate(false);     // Don't translate
    params.set_language(Some("en")); // English
    params.set_print_special(false); // No <SOT> tokens

    // STEP 4: Context prompting (coherence)
    if !self.last_transcript.is_empty() {
        params.set_initial_prompt(&self.last_transcript);
    }

    // STEP 5: Run inference
    state.full(params, &audio_data)?;

    // STEP 6: Extract text
    let num_segments = state.full_n_segments();
    let mut transcript = String::new();
    for i in 0..num_segments {
        if let Some(segment) = state.get_segment(i) {
            transcript.push_str(&segment.to_string());
        }
    }

    // STEP 7: Update context for next chunk
    let final_text = transcript.trim().to_string();
    if !final_text.is_empty() {
        if !self.last_transcript.is_empty() {
            self.last_transcript.push(' ');
        }
        self.last_transcript.push_str(&final_text);
    }

    Ok(final_text)
}
```

### Transcription Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  transcribe_chunk() Flow                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Input: 6 seconds of audio @ 48kHz (288,000 samples)            â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ STEP 1: Resample                     â”‚                        â”‚
â”‚  â”‚ 48kHz â†’ 16kHz                        â”‚                        â”‚
â”‚  â”‚ 288,000 â†’ 96,000 samples             â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ STEP 2: Configure Params             â”‚                        â”‚
â”‚  â”‚ - Greedy sampling                    â”‚                        â”‚
â”‚  â”‚ - 4 CPU threads                      â”‚                        â”‚
â”‚  â”‚ - English language                   â”‚                        â”‚
â”‚  â”‚ - Context prompt (previous text)     â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ STEP 3: Run Whisper AI               â”‚                        â”‚
â”‚  â”‚ state.full(params, audio)            â”‚                        â”‚
â”‚  â”‚ â†’ GPU matrix operations              â”‚                        â”‚
â”‚  â”‚ â†’ ~100-500ms per chunk               â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ STEP 4: Extract Text                 â”‚                        â”‚
â”‚  â”‚ Loop through segments                â”‚                        â”‚
â”‚  â”‚ Concatenate into string              â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  Output: "Hello world this is a test"                           â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ STEP 5: Update Context               â”‚                        â”‚
â”‚  â”‚ last_transcript += " " + output      â”‚                        â”‚
â”‚  â”‚ (Used as prompt for next chunk)      â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŸ© `src-tauri/src/parakeet.rs` (615 lines)

**Purpose**: NVIDIA Parakeet/Nemotron ASR engine manager.

### Key Differences from Whisper

| Aspect | Whisper | Parakeet |
|--------|---------|----------|
| Model Format | `.bin` (GGML) | `.onnx` (ONNX Runtime) |
| Streaming | 6-second chunks | 560ms chunks |
| GPU Backend | CUDA/Vulkan | CUDA/DirectML |
| Latency | ~200ms | ~50ms |
| Model Types | Single | Nemotron, CTC, EOU, TDT |

### Struct: `ParakeetManager` (Lines 52-57)

```rust
pub struct ParakeetManager {
    model: Option<LoadedModel>,  // Loaded AI model
    model_name: Option<String>,  // "nemotron:nemotron"
    backend: GpuBackend,         // Cuda/DirectML/Cpu
    resampler: Option<(u32, usize, Box<SincFixedIn<f32>>)>,
}
```

### Enum: `LoadedModel` (Lines 35-40)

```rust
enum LoadedModel {
    Nemotron(Nemotron),     // Streaming-optimized
    Ctc(Parakeet),          // CTC decoder
    Eou(ParakeetEOU),       // End-of-utterance detection
    Tdt(ParakeetTDT),       // Token-based decoding
}
```

### Method: `transcribe_chunk()` (Lines 528-613)

**Purpose**: Transcribe small audio chunks in real-time.

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],
    sample_rate: u32,
) -> Result<String, String> {
    // Step 1: Resample to 16kHz
    let audio = if sample_rate != 16000 {
        // ... resampling logic ...
    } else {
        samples.to_vec()
    };

    // Step 2: Transcribe based on model type
    if let Some(model) = &mut self.model {
        match model {
            LoadedModel::Nemotron(m) => {
                // Process in 560ms chunks (8960 samples)
                let mut transcript = String::new();
                const CHUNK_SIZE: usize = 8960;
                for chunk in audio.chunks(CHUNK_SIZE) {
                    transcript.push_str(&m.transcribe_chunk(chunk)?);
                }
                Ok(transcript)
            }
            LoadedModel::Ctc(m) => {
                // Full chunk processing
                let result = m.transcribe_samples(audio, 16000, 1, None)?;
                Ok(result.text)
            }
            // ... other model types ...
        }
    } else {
        Err("No model loaded".to_string())
    }
}
```

---

## ğŸŸ¨ `src-tauri/src/vad.rs` (215 lines)

**Purpose**: Voice Activity Detection - distinguishes speech from silence.

### Struct: `VADManager` (Lines 8-10)

```rust
pub struct VADManager {
    threshold: f32,  // Volume level that counts as speech (0.005)
}
```

### Method: `is_speech()` (Lines 78-98)

**Purpose**: Determine if an audio chunk contains speech.

```rust
pub fn is_speech(&mut self, audio: &[f32]) -> Result<f32, String> {
    // Calculate RMS (Root Mean Square) energy
    let sum_squares: f32 = audio.iter().map(|&x| x * x).sum();
    let rms = (sum_squares / audio.len() as f32).sqrt();

    // Convert to probability (0.0 = silence, 1.0 = speech)
    let prob = if rms < self.threshold {
        0.0  // Too quiet
    } else if rms > self.threshold * 5.0 {
        1.0  // Very loud
    } else {
        // Linear interpolation
        ((rms - self.threshold) / (self.threshold * 4.0)).min(1.0)
    };

    Ok(prob)
}
```

### VAD Algorithm Visualization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Energy-Based VAD Algorithm                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Audio Signal:                                                   â”‚
â”‚  ~~~~~~~~~~~~~~~_______________~~~~~~~~~~~~~~~_____             â”‚
â”‚   ^^ speech ^^    ^^ silence ^^   ^^ speech ^^  ^^silent^^      â”‚
â”‚                                                                  â”‚
â”‚  RMS Energy:                                                     â”‚
â”‚      0.05          0.001           0.04        0.002             â”‚
â”‚                                                                  â”‚
â”‚  Threshold = 0.005                                              â”‚
â”‚                                                                  â”‚
â”‚  Result:                                                         â”‚
â”‚      SPEECH        SILENCE         SPEECH      SILENCE          â”‚
â”‚      (1.0)         (0.0)           (1.0)       (0.0)            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Method: `get_speech_timestamps()` (Lines 100-213)

**Purpose**: Find exactly when speech occurs in a full recording.

**Returns**: `Vec<(start_seconds, end_seconds)>`

**Example**: `[(0.5, 3.2), (5.0, 8.7)]` means speech from 0.5-3.2s and 5.0-8.7s

---

## ğŸŸ« `src-tauri/src/llm.rs` (98 lines)

**Purpose**: Gemma LLM engine for grammar correction.

### Struct: `LLMEngine` (Lines 12-17)

```rust
pub struct LLMEngine {
    model: model::ModelWeights,      // Neural network weights
    tokenizer: Tokenizer,            // Text â†” Token IDs
    device: Device,                  // CPU or CUDA
    logits_processor: LogitsProcessor, // Sampling (temperature, top-p)
}
```

### Method: `new()` (Lines 19-63)

```rust
pub fn new() -> Result<Self> {
    // Hardcoded model path
    let base_path = PathBuf::from(
        r"c:\Users\abdul\OneDrive\Desktop\Taurscribe\taurscribe-runtime\models\GRMR-V3-G1B-GGUF",
    );
    let model_path = base_path.join("GRMR-V3-G1B-Q4_K_M.gguf");
    let tokenizer_path = base_path.join("tokenizer.json");

    // Select device (try CUDA first)
    let device = Device::new_cuda(0).unwrap_or(Device::Cpu);

    // Load tokenizer
    let tokenizer = Tokenizer::from_file(&tokenizer_path)?;

    // Load model (GGUF format)
    let mut file = std::fs::File::open(&model_path)?;
    let content = gguf_file::Content::read(&mut file)?;
    let model = model::ModelWeights::from_gguf(content, &mut file, &device)?;

    // Initialize sampler
    let logits_processor = LogitsProcessor::new(1337, Some(0.7), Some(0.95));

    Ok(Self { model, tokenizer, device, logits_processor })
}
```

### Method: `run()` (Lines 65-96)

```rust
pub fn run(&mut self, prompt: &str) -> Result<String> {
    // Format prompt for grammar correction
    let formatted_prompt = format!("<bos>text\n{}\ncorrected\n", prompt.trim());

    // Tokenize
    let tokens = self.tokenizer.encode(formatted_prompt, true)?.get_ids().to_vec();
    let input = Tensor::new(tokens.as_slice(), &self.device)?;

    // Run model
    let logits = self.model.forward(&input, 0)?;

    // Sample next token
    let last_logits = logits.get(logits.dims2()?.0 - 1)?;
    let next_token = self.logits_processor.sample(&last_logits)?;

    // Decode
    let decoded = self.tokenizer.decode(&[next_token], true)?;

    Ok(decoded)
}
```

---

## ğŸ”¶ `src-tauri/src/commands/` Directory

### `mod.rs` (14 lines)

**Purpose**: Re-exports all command modules.

```rust
mod llm;
mod misc;
mod models;
mod recording;
mod settings;
mod transcription;

pub use llm::*;
pub use misc::*;
pub use models::*;
pub use recording::*;
pub use settings::*;
pub use transcription::*;
```

---

### `recording.rs` (345 lines)

**Purpose**: Start and stop recording commands.

#### Command: `start_recording()` (Lines 10-272)

**Purpose**: Initialize microphone, create threads, start recording.

**Flow**:
1. Get default microphone device
2. Create WAV file path
3. Clear AI context (fresh start)
4. Create communication channels (crossbeam)
5. Spawn file writer thread
6. Spawn AI transcription thread
7. Start microphone stream
8. Store recording handle

#### Command: `stop_recording()` (Lines 274-344)

**Purpose**: Stop recording, run final transcription, cleanup.

**Flow**:
1. Take recording handle (stops mic)
2. Wait for threads to finish
3. For Parakeet: Return accumulated transcript
4. For Whisper: Run VAD â†’ High-quality final pass
5. Clean transcript and return

---

### `transcription.rs` (224 lines)

**Purpose**: Sample file listing and benchmarking.

#### Command: `list_sample_files()` (Lines 6-67)

Returns available WAV files for testing.

#### Command: `benchmark_test()` (Lines 69-223)

Compares Whisper vs Parakeet performance on a sample file.

---

### `models.rs` (61 lines)

**Purpose**: Model listing and switching.

#### Commands:
- `list_models()` - List Whisper models
- `get_current_model()` - Get active Whisper model
- `switch_model()` - Switch Whisper model
- `list_parakeet_models()` - List Parakeet models
- `init_parakeet()` - Load Parakeet model
- `get_parakeet_status()` - Get Parakeet status

---

### `settings.rs` (56 lines)

**Purpose**: Backend info and engine selection.

#### Commands:
- `get_backend_info()` - Returns "CUDA", "Vulkan", or "CPU"
- `set_active_engine()` - Switch between Whisper/Parakeet
- `get_active_engine()` - Get currently active engine
- `set_tray_state()` - Update tray icon color

---

### `llm.rs` (98 lines)

**Purpose**: LLM initialization and inference.

#### Commands:
- `init_llm()` - Load Gemma model (async, blocking task)
- `run_llm_inference()` - Run raw inference
- `check_llm_status()` - Check if LLM is loaded
- `correct_text()` - Grammar correction (main function)

---

### `misc.rs` (6 lines)

**Purpose**: Test command.

```rust
#[tauri::command]
pub fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}
```

---

## ğŸ”· `src-tauri/src/hotkeys/` Directory

### `mod.rs` (3 lines)

```rust
mod listener;
pub use listener::start_hotkey_listener;
```

### `listener.rs` (75 lines)

**Purpose**: Global hotkey listener for Ctrl+Win.

```rust
pub fn start_hotkey_listener(app_handle: AppHandle) {
    // Atomic flags for key states
    let ctrl_held = Arc::new(AtomicBool::new(false));
    let meta_held = Arc::new(AtomicBool::new(false));
    let recording_active = Arc::new(AtomicBool::new(false));

    let callback = move |event: Event| {
        match event.event_type {
            EventType::KeyPress(key) => {
                match key {
                    Key::ControlLeft | Key::ControlRight => {
                        ctrl_held.store(true, Ordering::SeqCst);
                    }
                    Key::MetaLeft | Key::MetaRight => {
                        meta_held.store(true, Ordering::SeqCst);
                    }
                    _ => {}
                }

                // Both pressed? Start recording!
                if ctrl_held.load(...) && meta_held.load(...) && !recording_active.load(...) {
                    recording_active.store(true, ...);
                    app_handle.emit("hotkey-start-recording", ());
                }
            }
            EventType::KeyRelease(key) => {
                // Update flags and stop recording if released
                // ...
            }
            _ => {}
        }
    };

    // Blocks forever, listening to all keyboard events
    listen(callback).ok();
}
```

---

## ğŸŸª `src-tauri/src/tray/` Directory

### `mod.rs` (3 lines)

```rust
mod icons;
pub use icons::{setup_tray, update_tray_icon};
```

### `icons.rs` (93 lines)

**Purpose**: System tray icon management.

#### Macros (Lines 7-21)

```rust
macro_rules! tray_icon_green {
    () => { tauri::include_image!("icons/emoji-green_circle.ico") };
}
macro_rules! tray_icon_red {
    () => { tauri::include_image!("icons/emoji-red_circle.ico") };
}
macro_rules! tray_icon_yellow {
    () => { tauri::include_image!("icons/emoji-yellow_circle.ico") };
}
```

#### Function: `update_tray_icon()` (Lines 23-50)

```rust
pub fn update_tray_icon(app: &AppHandle, state: AppState) -> Result<(), String> {
    let icon = match state {
        AppState::Ready => tray_icon_green!(),
        AppState::Recording => tray_icon_red!(),
        AppState::Processing => tray_icon_yellow!(),
    };

    let tooltip = match state {
        AppState::Ready => "Taurscribe - Ready",
        AppState::Recording => "Taurscribe - Recording...",
        AppState::Processing => "Taurscribe - Processing...",
    };

    if let Some(tray) = app.tray_by_id("main-tray") {
        tray.set_icon(Some(icon))?;
        tray.set_tooltip(Some(tooltip))?;
    }

    Ok(())
}
```

#### Function: `setup_tray()` (Lines 53-92)

Creates the system tray with menu items (Show, Exit).

---

## ğŸŸ¤ `src-tauri/build.rs` (74 lines)

**Purpose**: Build-time configuration script.

### What It Does:

1. **Standard Tauri build**: `tauri_build::build()`

2. **macOS deployment target**: Sets `MACOSX_DEPLOYMENT_TARGET=13.4` for ONNX Runtime compatibility

3. **Windows ARM64 Clang**: Forces Clang compiler for whisper.cpp

4. **CUDA library paths**: Adds CUDA library search paths for Windows linker

```rust
fn main() {
    tauri_build::build();

    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=13.4");
    }

    #[cfg(windows)]
    {
        // Find CUDA libraries for linking
        if let Ok(cuda_path) = std::env::var("CUDA_PATH") {
            let lib_path = PathBuf::from(cuda_path).join("lib").join("x64");
            if lib_path.exists() {
                println!("cargo:rustc-link-search=native={}", lib_path.display());
            }
        }
    }
}
```

---

## ğŸ“Š Complete Module Dependency Graph

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      DEPENDENCY GRAPH                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  main.rs                                                         â”‚
â”‚      â”‚                                                           â”‚
â”‚      â””â”€â”€â–º lib.rs (orchestrator)                                 â”‚
â”‚               â”‚                                                  â”‚
â”‚               â”œâ”€â”€â–º state.rs (AudioState)                        â”‚
â”‚               â”‚       â”‚                                          â”‚
â”‚               â”‚       â”œâ”€â”€â–º audio.rs (RecordingHandle)           â”‚
â”‚               â”‚       â”œâ”€â”€â–º types.rs (enums)                     â”‚
â”‚               â”‚       â”œâ”€â”€â–º whisper.rs                           â”‚
â”‚               â”‚       â”œâ”€â”€â–º parakeet.rs                          â”‚
â”‚               â”‚       â”œâ”€â”€â–º vad.rs                               â”‚
â”‚               â”‚       â””â”€â”€â–º llm.rs                               â”‚
â”‚               â”‚                                                  â”‚
â”‚               â”œâ”€â”€â–º commands/ (all commands)                     â”‚
â”‚               â”‚       â”œâ”€â”€â–º recording.rs â†’ state, audio, utils   â”‚
â”‚               â”‚       â”œâ”€â”€â–º transcription.rs â†’ state             â”‚
â”‚               â”‚       â”œâ”€â”€â–º models.rs â†’ whisper, parakeet        â”‚
â”‚               â”‚       â”œâ”€â”€â–º settings.rs â†’ state, tray            â”‚
â”‚               â”‚       â”œâ”€â”€â–º llm.rs â†’ llm engine                  â”‚
â”‚               â”‚       â””â”€â”€â–º misc.rs (standalone)                 â”‚
â”‚               â”‚                                                  â”‚
â”‚               â”œâ”€â”€â–º hotkeys/                                     â”‚
â”‚               â”‚       â””â”€â”€â–º listener.rs (rdev events)            â”‚
â”‚               â”‚                                                  â”‚
â”‚               â””â”€â”€â–º tray/                                        â”‚
â”‚                       â””â”€â”€â–º icons.rs â†’ types (AppState)          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”¬ Complete Function Reference (Every Function Explained)

This section documents **every single function** in every `.rs` file with line-by-line explanations.

---

### ğŸ“„ `whisper.rs` - All 15 Functions

#### Function 1: `GpuBackend::fmt()` (Lines 23-30)
**Purpose**: Implement Display trait for pretty-printing GPU backend names.

```rust
impl std::fmt::Display for GpuBackend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GpuBackend::Cuda => write!(f, "CUDA"),      // "Cuda" â†’ "CUDA"
            GpuBackend::Vulkan => write!(f, "Vulkan"),  // "Vulkan" â†’ "Vulkan"
            GpuBackend::Cpu => write!(f, "CPU"),        // "Cpu" â†’ "CPU"
        }
    }
}
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `&self` | `&GpuBackend` | The enum variant to format |
| `f` | `&mut Formatter` | The output buffer to write to |
| **Returns** | `std::fmt::Result` | `Ok(())` on success |

---

#### Function 2: `null_log_callback()` (Lines 55-63)
**Purpose**: Suppress noisy C++ logs from whisper.cpp library.

```rust
#[cfg(target_os = "macos")]
unsafe extern "C" fn null_log_callback(
    _level: u32,           // Log level (ignored)
    _text: *const c_char,  // Log message (ignored)
    _user_data: *mut c_void // User context (ignored)
) {
    // Do nothing - suppress all logs
}
```

| Attribute | Meaning |
|-----------|---------|
| `#[cfg(target_os = "macos")]` | Only compile for macOS |
| `unsafe` | Manual memory management |
| `extern "C"` | C calling convention |

---

#### Function 3: `WhisperManager::new()` (Lines 67-75)
**Purpose**: Constructor - creates a new uninitialized WhisperManager.

```rust
pub fn new() -> Self {
    Self {
        context: None,                  // No model loaded yet
        last_transcript: String::new(), // Empty context buffer
        backend: GpuBackend::Cpu,       // Assume CPU (updated on init)
        current_model: None,            // No model name
        resampler: None,                // Created lazily
    }
}
```

| Field | Initial Value | Later Value |
|-------|---------------|-------------|
| `context` | `None` | `Some(WhisperContext)` after `initialize()` |
| `last_transcript` | `""` | Accumulated text during session |
| `backend` | `Cpu` | Detected backend after `initialize()` |
| `current_model` | `None` | Model ID after `initialize()` |
| `resampler` | `None` | Created in `transcribe_chunk()` |

---

#### Function 4: `WhisperManager::get_models_dir()` (Lines 78-108)
**Purpose**: Find the directory containing Whisper model files.

```rust
fn get_models_dir() -> Result<std::path::PathBuf, String> {
    let possible_paths = [
        "taurscribe-runtime/models",
        "../taurscribe-runtime/models",
        "../../taurscribe-runtime/models",
    ];

    for path in possible_paths {
        if let Ok(canonical) = std::fs::canonicalize(path) {
            if canonical.is_dir() {
                if let Ok(entries) = std::fs::read_dir(&canonical) {
                    for entry in entries.flatten() {
                        if let Some(name) = entry.file_name().to_str() {
                            if name.starts_with("ggml-") && name.ends_with(".bin") {
                                return Ok(canonical);
                            }
                        }
                    }
                }
            }
        }
    }

    Err("Could not find models directory containing ggml models".to_string())
}
```

**Step-by-step flow**:
1. Define 3 possible relative paths to check
2. For each path:
   - Try to canonicalize (convert to absolute path)
   - Check if it's a directory
   - Look for files matching `ggml-*.bin`
   - Return immediately if found
3. Return error if all paths failed

---

#### Function 5: `WhisperManager::list_available_models()` (Lines 110-161)
**Purpose**: Scan the models directory and return metadata for all Whisper models.

```rust
pub fn list_available_models() -> Result<Vec<ModelInfo>, String> {
    let models_dir = Self::get_models_dir()?;
    let mut models = Vec::new();

    let entries = std::fs::read_dir(&models_dir)
        .map_err(|e| format!("Failed to read models directory: {}", e))?;

    for entry in entries {
        let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
        let path = entry.path();

        if path.is_file() {
            if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                // Filter: ggml-*.bin, NOT silero (VAD model)
                if file_name.starts_with("ggml-")
                    && file_name.ends_with(".bin")
                    && !file_name.contains("silero")
                {
                    let size_bytes = path.metadata().map(|m| m.len()).unwrap_or(0);
                    let size_mb = size_bytes as f32 / (1024.0 * 1024.0);

                    let id = file_name
                        .trim_start_matches("ggml-")
                        .trim_end_matches(".bin")
                        .to_string();

                    let display_name = Self::format_model_name(&id);

                    models.push(ModelInfo { id, display_name, file_name: file_name.to_string(), size_mb });
                }
            }
        }
    }

    models.sort_by(|a, b| a.size_mb.partial_cmp(&b.size_mb).unwrap());
    Ok(models)
}
```

**Returns**: `Vec<ModelInfo>` sorted by file size (smallest first)

**Example output**:
```rust
[
    ModelInfo { id: "tiny.en-q5_1", display_name: "Tiny English (Q5_1)", size_mb: 42.3 },
    ModelInfo { id: "base.en-q5_1", display_name: "Base English (Q5_1)", size_mb: 78.5 },
    ModelInfo { id: "small.en-q5_1", display_name: "Small English (Q5_1)", size_mb: 245.0 },
]
```

---

#### Function 6: `WhisperManager::format_model_name()` (Lines 163-206)
**Purpose**: Convert cryptic model IDs to human-readable names.

```rust
fn format_model_name(id: &str) -> String {
    let mut name = String::new();

    // Part 1: Size
    if id.contains("tiny") { name.push_str("Tiny"); }
    else if id.contains("base") { name.push_str("Base"); }
    else if id.contains("small") { name.push_str("Small"); }
    else if id.contains("medium") { name.push_str("Medium"); }
    else if id.contains("large-v3-turbo") { name.push_str("Large V3 Turbo"); }
    else if id.contains("large-v3") { name.push_str("Large V3"); }
    else if id.contains("large") { name.push_str("Large"); }

    // Part 2: Language
    if id.contains(".en") { name.push_str(" English"); }
    else { name.push_str(" Multilingual"); }

    // Part 3: Quantization
    if id.contains("q5_0") { name.push_str(" (Q5_0)"); }
    else if id.contains("q5_1") { name.push_str(" (Q5_1)"); }
    else if id.contains("q8_0") { name.push_str(" (Q8_0)"); }

    if name.is_empty() { return id.to_string(); }
    name
}
```

**Examples**:
| Input ID | Output Name |
|----------|-------------|
| `"tiny.en-q5_1"` | `"Tiny English (Q5_1)"` |
| `"large-v3-turbo-q8_0"` | `"Large V3 Turbo (Q8_0)"` |
| `"medium"` | `"Medium Multilingual"` |

---

#### Function 7: `WhisperManager::get_current_model()` (Lines 208-211)
**Purpose**: Return the currently loaded model ID.

```rust
pub fn get_current_model(&self) -> Option<&String> {
    self.current_model.as_ref()  // Convert Option<String> to Option<&String>
}
```

---

#### Function 8: `WhisperManager::get_backend()` (Lines 213-216)
**Purpose**: Return the current GPU backend.

```rust
pub fn get_backend(&self) -> &GpuBackend {
    &self.backend  // Return reference to avoid copying
}
```

---

#### Function 9: `WhisperManager::clear_context()` (Lines 218-223)
**Purpose**: Reset the accumulated transcript (used when starting new recording).

```rust
pub fn clear_context(&mut self) {
    self.last_transcript.clear();  // Empty the string
    println!("[INFO] Context cleared - starting fresh");
}
```

---

#### Function 10: `WhisperManager::initialize()` (Lines 225-277)
**Purpose**: Load a Whisper model from disk into memory and GPU.

```rust
pub fn initialize(&mut self, model_id: Option<&str>) -> Result<String, String> {
    // Step 1: Disable C++ logs
    unsafe { set_log_callback(None, std::ptr::null_mut()); }

    // Step 2: Find models directory
    let models_dir = Self::get_models_dir()?;

    // Step 3: Determine target model
    let target_model = model_id.unwrap_or("tiny.en-q5_1");  // Default
    let file_name = format!("ggml-{}.bin", target_model);
    let absolute_path = models_dir.join(&file_name);

    // Step 4: Verify file exists
    if !absolute_path.exists() {
        return Err(format!("Model file not found: {}", absolute_path.display()));
    }

    // Step 5: Try GPU, fallback to CPU
    let (ctx, backend) = self
        .try_gpu(&absolute_path)
        .or_else(|_| self.try_cpu(&absolute_path))?;

    // Step 6: Store loaded state
    self.context = Some(ctx);
    self.backend = backend.clone();
    self.current_model = Some(target_model.to_string());

    // Step 7: GPU warmup (first inference is always slow)
    let warmup_audio = vec![0.0_f32; 16000];  // 1 second of silence
    self.transcribe_chunk(&warmup_audio, 16000).ok();  // Ignore errors

    Ok(format!("Backend: {}", backend))
}
```

**Flow diagram**:
```
initialize("small.en-q5_1")
         â”‚
         â–¼
   Find models directory
         â”‚
         â–¼
   Build path: "models/ggml-small.en-q5_1.bin"
         â”‚
         â–¼
   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
   â”‚ try_gpu() â”‚
   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ Success â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                              â”‚
         â”‚ Failure                           â”‚
         â–¼                                   â”‚
   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                             â”‚
   â”‚ try_cpu() â”‚                             â”‚
   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                             â”‚
         â”‚                                   â”‚
         â–¼                                   â–¼
   Store context, backend, model_name
         â”‚
         â–¼
   GPU warmup (transcribe silence)
         â”‚
         â–¼
   Return "Backend: CUDA"
```

---

#### Function 11: `WhisperManager::try_gpu()` (Lines 279-303)
**Purpose**: Attempt to load model with GPU acceleration.

```rust
fn try_gpu(&self, model_path: &std::path::Path) -> Result<(WhisperContext, GpuBackend), String> {
    println!("[GPU] Attempting GPU acceleration...");

    let mut params = WhisperContextParameters::default();
    params.use_gpu(true);  // Enable GPU

    match WhisperContext::new_with_params(model_path.to_str().unwrap(), params) {
        Ok(ctx) => {
            let backend = self.detect_gpu_backend();  // CUDA or Vulkan?
            println!("[SUCCESS] âœ“ GPU acceleration enabled ({})", backend);
            Ok((ctx, backend))
        }
        Err(e) => {
            println!("[GPU] âœ— GPU failed: {:?}", e);
            Err(format!("GPU failed: {:?}", e))
        }
    }
}
```

---

#### Function 12: `WhisperManager::detect_gpu_backend()` (Lines 305-314)
**Purpose**: Determine if CUDA or Vulkan is being used.

```rust
fn detect_gpu_backend(&self) -> GpuBackend {
    if self.is_cuda_available() {
        return GpuBackend::Cuda;  // NVIDIA detected
    }
    GpuBackend::Vulkan  // Fallback assumption
}
```

---

#### Function 13: `WhisperManager::is_cuda_available()` (Lines 316-322)
**Purpose**: Check if NVIDIA CUDA drivers are installed.

```rust
fn is_cuda_available(&self) -> bool {
    std::process::Command::new("nvidia-smi")  // Run nvidia-smi command
        .output()
        .map(|output| output.status.success())  // Check if it succeeded
        .unwrap_or(false)  // False if command not found
}
```

---

#### Function 14: `WhisperManager::try_cpu()` (Lines 324-341)
**Purpose**: Fallback to CPU-only inference.

```rust
fn try_cpu(&self, model_path: &std::path::Path) -> Result<(WhisperContext, GpuBackend), String> {
    println!("[GPU] Falling back to CPU...");

    let params = WhisperContextParameters::default();  // No GPU flag

    match WhisperContext::new_with_params(model_path.to_str().unwrap(), params) {
        Ok(ctx) => {
            println!("[SUCCESS] âœ“ CPU backend loaded");
            Ok((ctx, GpuBackend::Cpu))
        }
        Err(e) => Err(format!("Failed to load model: {:?}", e)),
    }
}
```

---

#### Function 15: `WhisperManager::transcribe_chunk()` (Lines 343-458)
**Purpose**: Real-time transcription of audio chunks (~6 seconds).

```rust
pub fn transcribe_chunk(
    &mut self,
    samples: &[f32],        // Raw audio samples
    input_sample_rate: u32, // e.g., 48000
) -> Result<String, String> {
    // STEP 1: Get model context
    let ctx = self.context.as_mut()
        .ok_or("Whisper context not initialized")?;

    // STEP 2: Resample to 16kHz if needed
    let audio_data = if input_sample_rate != 16000 {
        // Check if resampler needs recreation
        let needs_new = match &self.resampler {
            Some((rate, size, _)) => *rate != input_sample_rate || *size != samples.len(),
            None => true,
        };

        if needs_new {
            // Create new resampler with sinc interpolation
            let params = SincInterpolationParameters {
                sinc_len: 256,
                f_cutoff: 0.95,
                interpolation: SincInterpolationType::Linear,
                window: WindowFunction::BlackmanHarris2,
                oversampling_factor: 128,
            };
            let resampler = SincFixedIn::<f32>::new(
                16000_f64 / input_sample_rate as f64,  // Ratio
                2.0,                                    // Max ratio
                params,
                samples.len(),                          // Input size
                1,                                      // Channels
            ).map_err(|e| format!("Failed to create resampler: {:?}", e))?;
            self.resampler = Some((input_sample_rate, samples.len(), Box::new(resampler)));
        }

        // Run resampling
        let (_, _, resampler) = self.resampler.as_mut().unwrap();
        let waves_in = vec![samples.to_vec()];
        let waves_out = resampler.process(&waves_in, None)
            .map_err(|e| format!("Resampling failed: {:?}", e))?;
        waves_out[0].clone()
    } else {
        samples.to_vec()
    };

    // STEP 3: Create transcription state
    let mut state = ctx.create_state()
        .map_err(|e| format!("Failed to create state: {:?}", e))?;

    // STEP 4: Configure parameters
    let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
    params.set_n_threads(4);          // CPU threads
    params.set_translate(false);      // Don't translate
    params.set_language(Some("en"));  // English
    params.set_print_special(false);  // No special tokens
    params.set_print_progress(false); // No progress
    params.set_print_realtime(false);
    params.set_print_timestamps(false);

    // STEP 5: Add context from previous chunks
    if !self.last_transcript.is_empty() {
        params.set_initial_prompt(&self.last_transcript);
    }

    let start = std::time::Instant::now();

    // STEP 6: Run inference
    state.full(params, &audio_data)
        .map_err(|e| format!("Transcription failed: {:?}", e))?;

    // STEP 7: Extract text segments
    let num_segments = state.full_n_segments();
    let mut transcript = String::new();
    for i in 0..num_segments {
        if let Some(segment) = state.get_segment(i) {
            transcript.push_str(&segment.to_string());
        }
    }

    let final_text = transcript.trim().to_string();

    // STEP 8: Update context for next chunk
    if !final_text.is_empty() {
        if !self.last_transcript.is_empty() {
            self.last_transcript.push(' ');
        }
        self.last_transcript.push_str(&final_text);
    }

    // STEP 9: Log performance
    let duration = start.elapsed();
    let audio_duration_sec = audio_data.len() as f32 / 16000.0;
    let speedup = audio_duration_sec / duration.as_secs_f32();
    println!("[PERF] Processed {:.2}s audio in {:.0}ms | Speed: {:.1}x",
        audio_duration_sec, duration.as_millis(), speedup);

    Ok(final_text)
}
```

**Performance example**:
```
Input: 6 seconds of audio @ 48kHz (288,000 samples)
Step 1: Resample 48kHz â†’ 16kHz (96,000 samples)
Step 2: Configure Whisper params
Step 3: Run inference (~200ms on GPU)
Step 4: Extract text
Output: "Hello, this is a test of the transcription system."
Speed: 30x realtime (6s audio in 200ms)
```

---

#### Function 16: `WhisperManager::transcribe_file()` (Lines 460-643)
**Purpose**: High-quality batch transcription of entire WAV file.

**6 Steps with timing**:
1. **File I/O** (~10ms): Read WAV file into memory
2. **Stereoâ†’Mono** (~5ms): Average left/right channels
3. **Resample** (~50ms): Convert to 16kHz
4. **State Setup** (~1ms): Create Whisper state
5. **AI Inference** (~500ms): Run Whisper
6. **Extract Text** (~1ms): Get transcript segments

```rust
pub fn transcribe_file(&mut self, file_path: &str) -> Result<String, String> {
    // ... (565 lines of detailed processing)
    // Returns: "Full transcript of the audio file"
}
```

---

#### Function 17: `WhisperManager::transcribe_audio_data()` (Lines 645-703)
**Purpose**: Transcribe pre-loaded audio data (used after VAD filtering).

```rust
pub fn transcribe_audio_data(&mut self, audio_data: &[f32]) -> Result<String, String> {
    // Same as transcribe_file but skips file loading
    // Used when audio is already in memory (after VAD filtering)
}
```

---

#### Function 18: `WhisperManager::load_audio()` (Lines 705-779)
**Purpose**: Load and preprocess a WAV file for VAD/Whisper.

```rust
pub fn load_audio(&self, file_path: &str) -> Result<Vec<f32>, String> {
    // 1. Open WAV file
    // 2. Read samples (i16 or f32)
    // 3. Convert stereo to mono
    // 4. Resample to 16kHz
    // Returns: Vec<f32> at 16kHz mono
}
```

---

### ğŸ“„ `parakeet.rs` - All 25 Functions

#### Function 1: `GpuBackend::fmt()` (Lines 15-23)
Same pattern as Whisper - formats "Cuda" â†’ "CUDA", "DirectML" â†’ "DirectML".

---

#### Function 2: `ParakeetManager::new()` (Lines 60-68)
**Purpose**: Constructor - creates uninitialized manager.

```rust
pub fn new() -> Self {
    ParakeetManager {
        model: None,           // No model loaded
        model_name: None,      // No model ID
        backend: GpuBackend::Cpu,  // Assume CPU
        resampler: None,       // Created lazily
    }
}
```

---

#### Function 3: `ParakeetManager::get_models_dir()` (Lines 70-97)
Similar to Whisper but also checks executable location as fallback.

---

#### Function 4: `ParakeetManager::list_available_models()` (Lines 99-166)
**Purpose**: Scan for Parakeet models by detecting ONNX files.

**Detection logic**:
| Files Present | Model Type |
|---------------|------------|
| `encoder.onnx` + `decoder_joint.onnx` + `tokenizer.model` | Nemotron |
| `encoder.onnx` + `decoder_joint.onnx` + `tokenizer.json` | EOU |
| `encoder.onnx` + `decoder.onnx` + `joint.onnx` | TDT |
| `model.onnx` + `tokenizer.json` | CTC |

---

#### Function 5: `ParakeetManager::estimate_model_size()` (Lines 168-181)
**Purpose**: Calculate total size of model directory in MB.

```rust
fn estimate_model_size(path: &PathBuf) -> f64 {
    let mut total_size = 0u64;
    if let Ok(entries) = std::fs::read_dir(path) {
        for entry in entries.flatten() {
            if let Ok(metadata) = entry.metadata() {
                if metadata.is_file() {
                    total_size += metadata.len();
                }
            }
        }
    }
    total_size as f64 / (1024.0 * 1024.0)  // Convert to MB
}
```

---

#### Function 6: `ParakeetManager::get_status()` (Lines 183-198)
**Purpose**: Return current engine status for frontend.

```rust
pub fn get_status(&self) -> ParakeetStatus {
    ParakeetStatus {
        loaded: self.model.is_some(),
        model_id: self.model_name.clone(),
        model_type: self.model.as_ref().map(|m| match m {
            LoadedModel::Nemotron(_) => "Nemotron",
            LoadedModel::Ctc(_) => "CTC",
            LoadedModel::Eou(_) => "EOU",
            LoadedModel::Tdt(_) => "TDT",
        }.to_string()),
        backend: self.backend.to_string(),
    }
}
```

---

#### Function 7: `ParakeetManager::initialize()` (Lines 200-261)
**Purpose**: Load a Parakeet model based on type.

```rust
pub fn initialize(&mut self, model_id: Option<&str>) -> Result<String, String> {
    // 1. Get available models
    let available = Self::list_available_models()?;
    
    // 2. Select target model
    let target_id = model_id.unwrap_or(&available[0].id);
    let info = available.iter().find(|m| m.id == target_id)?;
    
    // 3. Parse model path from ID (e.g., "nemotron:nemotron" â†’ "nemotron")
    let subpath = target_id.split_once(':').map(|(_, p)| p).unwrap_or(target_id);
    let model_path = models_dir.join(subpath);
    
    // 4. Initialize based on type
    let (model, backend) = match info.model_type.as_str() {
        "Nemotron" => { let (m, b) = Self::init_nemotron(&model_path)?; (LoadedModel::Nemotron(m), b) }
        "CTC" => { let (m, b) = Self::init_ctc(&model_path)?; (LoadedModel::Ctc(m), b) }
        "EOU" => { let (m, b) = Self::init_eou(&model_path)?; (LoadedModel::Eou(m), b) }
        "TDT" => { let (m, b) = Self::init_tdt(&model_path)?; (LoadedModel::Tdt(m), b) }
        _ => return Err("Unknown model type"),
    };
    
    // 5. Store state
    self.model = Some(model);
    self.model_name = Some(target_id.to_string());
    self.backend = backend;
    
    Ok(format!("Loaded {} ({})", info.display_name, backend))
}
```

---

#### Functions 8-11: `init_nemotron()`, `init_ctc()`, `init_eou()`, `init_tdt()` (Lines 263-471)
**Purpose**: Initialize each model type with GPU fallback chain.

**Pattern** (same for all):
```rust
fn init_X(path: &PathBuf) -> Result<(ModelType, GpuBackend), String> {
    #[cfg(target_os = "macos")]
    { return Ok((Self::try_cpu_X(path)?, GpuBackend::Cpu)); }
    
    #[cfg(not(target_os = "macos"))]
    {
        // Try CUDA first
        if let Ok(m) = Self::try_gpu_X(path) {
            return Ok((m, GpuBackend::Cuda));
        }
        // Try DirectML (Windows only)
        if let Ok(m) = Self::try_directml_X(path) {
            return Ok((m, GpuBackend::DirectML));
        }
        // Fallback to CPU
        Ok((Self::try_cpu_X(path)?, GpuBackend::Cpu))
    }
}
```

---

#### Functions 12-23: GPU/CPU Loaders (Lines 317-509)
12 functions for loading each model type with each backend:

| Function | Model | Backend |
|----------|-------|---------|
| `try_gpu_nemotron()` | Nemotron | CUDA |
| `try_directml_nemotron()` | Nemotron | DirectML |
| `try_cpu_nemotron()` | Nemotron | CPU |
| `try_gpu_ctc()` | CTC | CUDA |
| `try_directml_ctc()` | CTC | DirectML |
| `try_cpu_ctc()` | CTC | CPU |
| `try_gpu_eou()` | EOU | CUDA |
| `try_directml_eou()` | EOU | DirectML |
| `try_cpu_eou()` | EOU | CPU |
| `try_gpu_tdt()` | TDT | CUDA |
| `try_directml_tdt()` | TDT | DirectML |
| `try_cpu_tdt()` | TDT | CPU |

---

#### Function 24: `ParakeetManager::clear_context()` (Lines 513-525)
**Purpose**: Reset model state for new recording.

```rust
pub fn clear_context(&mut self) {
    if let Some(model) = &mut self.model {
        match model {
            LoadedModel::Nemotron(m) => m.reset(),  // Reset streaming state
            _ => {}  // Other models don't need reset
        }
    }
}
```

---

#### Function 25: `ParakeetManager::transcribe_chunk()` (Lines 527-613)
**Purpose**: Real-time transcription with model-specific handling.

```rust
pub fn transcribe_chunk(&mut self, samples: &[f32], sample_rate: u32) -> Result<String, String> {
    // 1. Resample to 16kHz if needed
    let audio = if sample_rate != 16000 { /* resample */ } else { samples.to_vec() };
    
    // 2. Transcribe based on model type
    match model {
        LoadedModel::Nemotron(m) => {
            // Process in 560ms chunks (streaming)
            const CHUNK_SIZE: usize = 8960;  // 560ms at 16kHz
            for chunk in audio.chunks(CHUNK_SIZE) {
                transcript.push_str(&m.transcribe_chunk(&chunk)?);
            }
        }
        LoadedModel::Ctc(m) => {
            // Single batch call
            let result = m.transcribe_samples(audio, 16000, 1, Some(TimestampMode::Words))?;
            Ok(result.text)
        }
        LoadedModel::Eou(m) => {
            // 160ms chunks
            const CHUNK_SIZE: usize = 2560;
            for chunk in audio.chunks(CHUNK_SIZE) {
                full_text.push_str(&m.transcribe(&chunk, false)?);
            }
        }
        LoadedModel::Tdt(m) => {
            // Single batch call with sentence timestamps
            let result = m.transcribe_samples(audio, 16000, 1, Some(TimestampMode::Sentences))?;
            Ok(result.text)
        }
    }
}
```

---

### ğŸ“„ `vad.rs` - All 4 Functions

#### Function 1: `VADManager::new()` (Lines 12-45)
**Purpose**: Constructor with model detection.

```rust
pub fn new() -> Result<Self, String> {
    // Look for Silero VAD model (for future use)
    if let Ok(models_dir) = Self::get_models_dir() {
        let vad_model_path = models_dir.join("silero_vad.onnx");
        if vad_model_path.exists() {
            println!("[VAD] Found Silero VAD model");
        } else {
            println!("[VAD] Silero model not found (using energy-based VAD)");
        }
    }
    
    // Currently using simple energy-based VAD
    Ok(Self { threshold: 0.005 })
}
```

---

#### Function 2: `VADManager::get_models_dir()` (Lines 47-72)
Same pattern as other modules - check 3 relative paths.

---

#### Function 3: `VADManager::is_speech()` (Lines 74-98)
**Purpose**: Determine if audio chunk contains speech.

```rust
pub fn is_speech(&mut self, audio: &[f32]) -> Result<f32, String> {
    // Calculate RMS energy
    let sum_squares: f32 = audio.iter().map(|&x| x * x).sum();
    let rms = (sum_squares / audio.len() as f32).sqrt();

    // Convert to probability
    let prob = if rms < self.threshold {
        0.0  // Definitely silence
    } else if rms > self.threshold * 5.0 {
        1.0  // Definitely speech
    } else {
        // Linear interpolation between threshold and 5*threshold
        ((rms - self.threshold) / (self.threshold * 4.0)).min(1.0)
    };

    Ok(prob)
}
```

**Visualization**:
```
RMS Energy:  0.001   0.005   0.010   0.015   0.020   0.025
             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
Probability:   0.0    0.0    0.25    0.50    0.75    1.0
                      â”‚                               â”‚
                 threshold                      5x threshold
```

---

#### Function 4: `VADManager::get_speech_timestamps()` (Lines 100-213)
**Purpose**: Find speech segments in full audio file.

```rust
pub fn get_speech_timestamps(
    &mut self,
    audio: &[f32],
    padding_ms: usize,  // Extra time around speech (500ms typical)
) -> Result<Vec<(f32, f32)>, String> {
    const FRAME_SIZE: usize = 512;  // ~32ms at 16kHz
    const MIN_SPEECH_FRAMES: usize = 5;  // ~150ms minimum speech
    
    // State machine
    let mut segments = Vec::new();
    let mut speech_start: Option<usize> = None;
    let mut consecutive_speech_frames = 0;
    let mut silence_frames = 0;
    
    for (i, chunk) in audio.chunks(FRAME_SIZE).enumerate() {
        let is_speech = self.is_speech(chunk)? > 0.5;
        
        match (is_speech, speech_start) {
            (true, None) => {
                // Speech started
                speech_start = Some(i);
                consecutive_speech_frames = 1;
            }
            (true, Some(_)) => {
                // Speech continuing
                consecutive_speech_frames += 1;
                silence_frames = 0;
            }
            (false, Some(_)) => {
                // Potential speech end
                silence_frames += 1;
                if silence_frames > padding_frames {
                    if consecutive_speech_frames >= MIN_SPEECH_FRAMES {
                        // Valid segment - save it
                        let start_time = (speech_start.unwrap() * FRAME_SIZE) as f32 / 16000.0;
                        let end_time = (i * FRAME_SIZE) as f32 / 16000.0;
                        segments.push((start_time, end_time));
                    }
                    speech_start = None;
                }
            }
            (false, None) => {
                // Still silence - do nothing
            }
        }
    }
    
    // Merge overlapping segments
    let merged = merge_segments(segments);
    Ok(merged)
}
```

**Example output**:
```rust
// Input: 30 seconds of audio with speech at 2-5s and 10-15s
get_speech_timestamps(audio, 500) 
// Returns: [(1.5, 5.5), (9.5, 15.5)]  // With 500ms padding
```

---

### ğŸ“„ `llm.rs` - All 2 Functions

#### Function 1: `LLMEngine::new()` (Lines 19-63)
**Purpose**: Load Gemma LLM for grammar correction.

```rust
pub fn new() -> Result<Self> {
    // Hardcoded model path
    let base_path = PathBuf::from(
        r"c:\Users\abdul\OneDrive\Desktop\Taurscribe\taurscribe-runtime\models\GRMR-V3-G1B-GGUF"
    );
    let model_path = base_path.join("GRMR-V3-G1B-Q4_K_M.gguf");
    let tokenizer_path = base_path.join("tokenizer.json");
    
    // Try CUDA, fallback to CPU
    let device = Device::new_cuda(0).unwrap_or(Device::Cpu);
    
    // Load tokenizer
    let tokenizer = Tokenizer::from_file(&tokenizer_path)?;
    
    // Load model weights (GGUF format)
    let mut file = std::fs::File::open(&model_path)?;
    let content = gguf_file::Content::read(&mut file)?;
    let model = model::ModelWeights::from_gguf(content, &mut file, &device)?;
    
    // Configure sampling (temperature=0.7, top_p=0.95)
    let logits_processor = LogitsProcessor::new(1337, Some(0.7), Some(0.95));
    
    Ok(Self { model, tokenizer, device, logits_processor })
}
```

---

#### Function 2: `LLMEngine::run()` (Lines 65-96)
**Purpose**: Run grammar correction inference.

```rust
pub fn run(&mut self, prompt: &str) -> Result<String> {
    // Format prompt for grammar model
    let formatted_prompt = format!("<bos>text\n{}\ncorrected\n", prompt.trim());
    
    // Tokenize
    let tokens = self.tokenizer.encode(formatted_prompt, true)?.get_ids().to_vec();
    let input = Tensor::new(tokens.as_slice(), &self.device)?;
    
    // Forward pass
    let logits = self.model.forward(&input, 0)?;
    
    // Get last token's logits
    let (_seq_len, _vocab_size) = logits.dims2()?;
    let last_logits = logits.get(_seq_len - 1)?;
    
    // Sample next token
    let next_token = self.logits_processor.sample(&last_logits)?;
    
    // Decode
    let decoded = self.tokenizer.decode(&[next_token], true)?;
    
    Ok(decoded)
}
```

---

### ğŸ“„ `commands/recording.rs` - All 2 Functions

#### Function 1: `start_recording()` (Lines 12-272)
**Purpose**: Initialize microphone, create threads, start recording.

**Complete flow** (10 steps):

```rust
#[tauri::command]
pub fn start_recording(app_handle: AppHandle, state: State<AudioState>) -> Result<String, String> {
    // STEP 1: Get microphone
    let host = cpal::default_host();
    let device = host.default_input_device().ok_or("No input device")?;
    let config: cpal::StreamConfig = device.default_input_config()?.into();

    // STEP 2: Prepare output file path
    let recordings_dir = get_recordings_dir()?;  // AppData/Taurscribe/temp
    let filename = format!("recording_{}.wav", chrono::Utc::now().timestamp());
    let path = recordings_dir.join(&filename);

    // STEP 3: Clear AI context
    let active_engine = *state.active_engine.lock().unwrap();
    if active_engine == ASREngine::Whisper {
        state.whisper.lock().unwrap().clear_context();
    } else {
        state.parakeet.lock().unwrap().clear_context();
    }

    // STEP 4: Store recording path and clear transcript
    *state.last_recording_path.lock().unwrap() = Some(path.to_string_lossy().into_owned());
    state.session_transcript.lock().unwrap().clear();

    // STEP 5: Create WAV writer
    let spec = hound::WavSpec {
        channels: config.channels,
        sample_rate: config.sample_rate.0,
        bits_per_sample: 32,
        sample_format: hound::SampleFormat::Float,
    };
    let writer = hound::WavWriter::create(&path, spec)?;

    // STEP 6: Create communication channels
    let (file_tx, file_rx) = unbounded::<Vec<f32>>();
    let (whisper_tx, whisper_rx) = unbounded::<Vec<f32>>();

    // STEP 7: Spawn file writer thread
    std::thread::spawn(move || {
        let mut writer = writer;
        while let Ok(samples) = file_rx.recv() {
            for sample in samples {
                writer.write_sample(sample).ok();
            }
        }
        writer.finalize().ok();
    });

    // STEP 8: Spawn transcription thread
    let whisper = state.whisper.clone();
    let parakeet = state.parakeet.clone();
    let vad = state.vad.clone();
    let app_clone = app_handle.clone();
    
    std::thread::spawn(move || {
        let mut buffer = Vec::new();
        let chunk_size = (sample_rate * 6) as usize;  // 6 seconds
        
        while let Ok(samples) = whisper_rx.recv() {
            buffer.extend(samples);
            
            if active_engine == ASREngine::Whisper {
                // Process in 6-second chunks with VAD
                while buffer.len() >= chunk_size {
                    let chunk: Vec<f32> = buffer.drain(..chunk_size).collect();
                    let is_speech = vad.lock().unwrap().is_speech(&chunk)?;
                    
                    if is_speech > 0.5 {
                        let transcript = whisper.lock().unwrap()
                            .transcribe_chunk(&chunk, sample_rate)?;
                        
                        if !transcript.is_empty() {
                            app_clone.emit("transcription-chunk", TranscriptionChunk {
                                text: transcript,
                                processing_time_ms: elapsed,
                                method: "Whisper".to_string(),
                            });
                        }
                    }
                }
            } else {
                // Parakeet: Process in 1.12-second chunks
                let parakeet_chunk_size = (sample_rate as f32 * 1.12) as usize;
                while buffer.len() >= parakeet_chunk_size {
                    let chunk: Vec<f32> = buffer.drain(..parakeet_chunk_size).collect();
                    let transcript = parakeet.lock().unwrap()
                        .transcribe_chunk(&chunk, sample_rate)?;
                    
                    if !transcript.is_empty() {
                        app_clone.emit("transcription-chunk", TranscriptionChunk { ... });
                    }
                }
            }
        }
    });

    // STEP 9: Build and start audio stream
    let stream = device.build_input_stream(
        &config,
        move |data: &[f32], _| {
            file_tx.send(data.to_vec()).ok();      // Send to file writer
            let mono = convert_to_mono(data);       // Convert stereo to mono
            whisper_tx.send(mono).ok();             // Send to transcriber
        },
        move |err| eprintln!("Audio input error: {}", err),
        None,
    )?;
    stream.play()?;

    // STEP 10: Store recording handle
    *state.recording_handle.lock().unwrap() = Some(RecordingHandle {
        stream: SendStream(stream),
        file_tx,
        whisper_tx,
    });

    Ok(format!("Recording started: {}", path.display()))
}
```

**Thread architecture**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Recording Architecture (3 Threads)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                              â”‚
â”‚  â”‚   MAIN THREAD   â”‚  (Tauri event loop)                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                              â”‚
â”‚           â”‚                                                       â”‚
â”‚           â”‚ spawn()                                               â”‚
â”‚           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚           â”‚                                             â”‚         â”‚
â”‚           â–¼                                             â–¼         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  FILE WRITER    â”‚                           â”‚  TRANSCRIBER    â”‚â”‚
â”‚  â”‚    THREAD       â”‚                           â”‚    THREAD       â”‚â”‚
â”‚  â”‚                 â”‚                           â”‚                 â”‚â”‚
â”‚  â”‚ while recv():   â”‚                           â”‚ while recv():   â”‚â”‚
â”‚  â”‚   write_sample()â”‚                           â”‚   if Whisper:   â”‚â”‚
â”‚  â”‚                 â”‚                           â”‚     VAD check   â”‚â”‚
â”‚  â”‚ finalize()      â”‚                           â”‚     transcribe()â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚   else Parakeet:â”‚â”‚
â”‚           â”‚                                    â”‚     transcribe()â”‚â”‚
â”‚           â”‚                                    â”‚   emit event    â”‚â”‚
â”‚           â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚           â”‚                                             â”‚         â”‚
â”‚           â”‚                                             â”‚         â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                          â”‚                                        â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                    â”‚ CHANNELS  â”‚                                   â”‚
â”‚                    â”‚ file_tx   â”‚                                   â”‚
â”‚                    â”‚whisper_tx â”‚                                   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                          â”‚                                        â”‚
â”‚                          â”‚                                        â”‚
â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚                 â”‚   AUDIO INPUT   â”‚  (cpal callback)               â”‚
â”‚                 â”‚    CALLBACK     â”‚                                â”‚
â”‚                 â”‚                 â”‚                                â”‚
â”‚                 â”‚ for each chunk: â”‚                                â”‚
â”‚                 â”‚   file_tx.send()â”‚                                â”‚
â”‚                 â”‚  whisper_tx.sendâ”‚                                â”‚
â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                          â”‚                                        â”‚
â”‚                          â”‚                                        â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                    â”‚ MICROPHONEâ”‚                                   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Function 2: `stop_recording()` (Lines 274-344)
**Purpose**: Stop recording, run final transcription, cleanup.

```rust
#[tauri::command]
pub fn stop_recording(state: State<AudioState>) -> Result<String, String> {
    // STEP 1: Take recording handle (stops mic)
    let mut handle = state.recording_handle.lock().unwrap();
    if let Some(recording) = handle.take() {
        // STEP 2: Drop stream and channels (signals threads to stop)
        drop(recording.stream);
        drop(recording.file_tx);
        drop(recording.whisper_tx);

        // STEP 3: Wait for threads to finish
        std::thread::sleep(std::time::Duration::from_millis(500));

        let active_engine = *state.active_engine.lock().unwrap();

        // STEP 4A: For Parakeet - use accumulated transcript
        if active_engine == ASREngine::Parakeet {
            let transcript = state.session_transcript.lock().unwrap().clone();
            let final_text = clean_transcript(&transcript);
            return Ok(final_text);
        }

        // STEP 4B: For Whisper - run high-quality final pass
        let path = state.last_recording_path.lock().unwrap().clone();
        if let Some(path) = path {
            // Load audio file
            let mut whisper = state.whisper.lock().unwrap();
            let audio_data = whisper.load_audio(&path)?;

            // Apply VAD filtering
            let mut vad = state.vad.lock().unwrap();
            let timestamps = vad.get_speech_timestamps(&audio_data, 500)?;

            if timestamps.is_empty() {
                return Ok("[silence]".to_string());
            }

            // Extract speech segments only
            let mut clean = Vec::new();
            for (start, end) in timestamps {
                let s = (start * 16000.0) as usize;
                let e = (end * 16000.0) as usize;
                clean.extend_from_slice(&audio_data[s..e]);
            }

            // Final transcription
            let result = whisper.transcribe_audio_data(&clean)?;
            Ok(result)
        } else {
            Ok("Recording saved.".to_string())
        }
    } else {
        Err("Not recording".to_string())
    }
}
```

---

### ğŸ“„ `commands/transcription.rs` - All 2 Functions

#### Function 1: `list_sample_files()` (Lines 6-67)
**Purpose**: List WAV files available for benchmarking.

```rust
#[tauri::command]
pub fn list_sample_files() -> Result<Vec<SampleFile>, String> {
    let possible_paths = [
        "taurscribe-runtime/samples",
        "../taurscribe-runtime/samples",
        "../../taurscribe-runtime/samples",
    ];
    
    // Find directory with .wav files
    let mut target_dir = PathBuf::new();
    for path in possible_paths {
        if let Ok(p) = std::fs::canonicalize(path) {
            if p.is_dir() && has_wav_files(&p) {
                target_dir = p;
                break;
            }
        }
    }
    
    // List all .wav files
    let mut files = Vec::new();
    for entry in std::fs::read_dir(target_dir)? {
        if let Ok(entry) = entry {
            let path = entry.path();
            if path.extension().map(|e| e == "wav").unwrap_or(false) {
                files.push(SampleFile {
                    name: path.file_name().unwrap().to_string_lossy().to_string(),
                    path: path.to_string_lossy().to_string(),
                });
            }
        }
    }
    
    files.sort_by(|a, b| a.name.cmp(&b.name));
    Ok(files)
}
```

---

#### Function 2: `benchmark_test()` (Lines 69-223)
**Purpose**: Compare Whisper vs Parakeet performance.

```rust
#[tauri::command]
pub fn benchmark_test(state: State<AudioState>, file_path: String) -> Result<String, String> {
    // 1. Load audio file
    let mut reader = hound::WavReader::open(&absolute_path)?;
    let audio_duration_secs = sample_count / sample_rate / channels;
    
    // 2. Convert to mono samples
    let mono_samples = convert_to_mono(samples);
    
    // 3. Test Whisper (without VAD)
    state.whisper.lock().unwrap().clear_context();
    let start_whisper_naive = Instant::now();
    for chunk in mono_samples.chunks(chunk_size) {
        state.whisper.lock().unwrap().transcribe_chunk(chunk, sample_rate).ok();
    }
    let time_whisper_naive = start_whisper_naive.elapsed();
    
    // 4. Test Whisper (with VAD)
    state.whisper.lock().unwrap().clear_context();
    let start_whisper_vad = Instant::now();
    let mut chunks_skipped = 0;
    for chunk in mono_samples.chunks(chunk_size) {
        let is_speech = state.vad.lock().unwrap().is_speech(chunk)?;
        if is_speech > 0.5 {
            state.whisper.lock().unwrap().transcribe_chunk(chunk, sample_rate).ok();
        } else {
            chunks_skipped += 1;
        }
    }
    let time_whisper_vad = start_whisper_vad.elapsed();
    
    // 5. Test Parakeet
    let start_parakeet = Instant::now();
    for chunk in mono_samples.chunks(parakeet_chunk_size) {
        state.parakeet.lock().unwrap().transcribe_chunk(chunk, sample_rate).ok();
    }
    let time_parakeet = start_parakeet.elapsed();
    
    // 6. Calculate speed factors
    let factor_whisper = audio_duration_secs / time_whisper_vad.as_secs_f32();
    let factor_parakeet = audio_duration_secs / time_parakeet.as_secs_f32();
    
    // 7. Determine winner
    let winner = if time_whisper_vad < time_parakeet { "Whisper AI" } else { "NVIDIA Parakeet" };
    
    // 8. Format results
    Ok(format!(
        "ğŸ“Š BENCHMARK RESULTS\n\
        ğŸ™ï¸ WHISPER AI:\n\
        - Baseline: {:.2}s\n\
        - Optimized: {:.2}s\n\
        - Speed: {:.1}x\n\n\
        ğŸ¦œ PARAKEET:\n\
        - Streaming: {:.2}s\n\
        - Speed: {:.1}x\n\n\
        ğŸ† WINNER: {}",
        time_whisper_naive.as_secs_f32(),
        time_whisper_vad.as_secs_f32(),
        factor_whisper,
        time_parakeet.as_secs_f32(),
        factor_parakeet,
        winner
    ))
}
```

---

### ğŸ“„ `commands/models.rs` - All 6 Functions

#### Function 1: `list_models()` (Lines 7-11)
```rust
#[tauri::command]
pub fn list_models() -> Result<Vec<whisper::ModelInfo>, String> {
    whisper::WhisperManager::list_available_models()
}
```

#### Function 2: `get_current_model()` (Lines 13-18)
```rust
#[tauri::command]
pub fn get_current_model(state: State<AudioState>) -> Result<Option<String>, String> {
    let whisper = state.whisper.lock().unwrap();
    Ok(whisper.get_current_model().cloned())
}
```

#### Function 3: `switch_model()` (Lines 20-35)
```rust
#[tauri::command]
pub fn switch_model(state: State<AudioState>, model_id: String) -> Result<String, String> {
    // Safety check
    let handle = state.recording_handle.lock().unwrap();
    if handle.is_some() {
        return Err("Cannot switch models while recording".to_string());
    }
    drop(handle);
    
    let mut whisper = state.whisper.lock().unwrap();
    whisper.initialize(Some(&model_id))
}
```

#### Function 4: `list_parakeet_models()` (Lines 37-41)
```rust
#[tauri::command]
pub fn list_parakeet_models() -> Result<Vec<parakeet::ParakeetModelInfo>, String> {
    parakeet::ParakeetManager::list_available_models()
}
```

#### Function 5: `init_parakeet()` (Lines 43-53)
```rust
#[tauri::command]
pub fn init_parakeet(state: State<AudioState>, model_id: Option<String>) -> Result<String, String> {
    let mut parakeet = state.parakeet.lock().unwrap();
    let result = parakeet.initialize(model_id.as_deref())?;
    
    // Auto-switch to Parakeet
    *state.active_engine.lock().unwrap() = ASREngine::Parakeet;
    
    Ok(result)
}
```

#### Function 6: `get_parakeet_status()` (Lines 55-60)
```rust
#[tauri::command]
pub fn get_parakeet_status(state: State<AudioState>) -> Result<parakeet::ParakeetStatus, String> {
    let parakeet = state.parakeet.lock().unwrap();
    Ok(parakeet.get_status())
}
```

---

### ğŸ“„ `commands/settings.rs` - All 4 Functions

#### Function 1: `get_backend_info()` (Lines 7-11)
```rust
#[tauri::command]
pub fn get_backend_info(state: State<AudioState>) -> Result<String, String> {
    let whisper = state.whisper.lock().unwrap();
    Ok(format!("{}", whisper.get_backend()))  // "CUDA", "Vulkan", or "CPU"
}
```

#### Function 2: `set_active_engine()` (Lines 13-25)
```rust
#[tauri::command]
pub fn set_active_engine(state: State<AudioState>, engine: String) -> Result<String, String> {
    let new_engine = match engine.to_lowercase().as_str() {
        "whisper" => ASREngine::Whisper,
        "parakeet" => ASREngine::Parakeet,
        _ => return Err(format!("Unknown engine: {}", engine)),
    };
    
    *state.active_engine.lock().unwrap() = new_engine;
    Ok(format!("Engine switched to {:?}", new_engine))
}
```

#### Function 3: `get_active_engine()` (Lines 27-31)
```rust
#[tauri::command]
pub fn get_active_engine(state: State<AudioState>) -> Result<ASREngine, String> {
    Ok(*state.active_engine.lock().unwrap())
}
```

#### Function 4: `set_tray_state()` (Lines 33-55)
```rust
#[tauri::command]
pub fn set_tray_state(
    app: AppHandle,
    state: State<AudioState>,
    new_state: String,
) -> Result<(), String> {
    let app_state = match new_state.as_str() {
        "ready" => AppState::Ready,
        "recording" => AppState::Recording,
        "processing" => AppState::Processing,
        _ => return Err(format!("Unknown state: {}", new_state)),
    };
    
    *state.current_app_state.lock().unwrap() = app_state;
    tray::update_tray_icon(&app, app_state)?;
    
    Ok(())
}
```

---

### ğŸ“„ `commands/llm.rs` - All 4 Functions

#### Function 1: `init_llm()` (Lines 5-34)
```rust
#[tauri::command]
pub async fn init_llm(state: State<'_, AudioState>) -> Result<String, String> {
    // Check if already loaded
    {
        let llm_guard = state.llm.lock().unwrap();
        if llm_guard.is_some() {
            return Ok("LLM already initialized".to_string());
        }
    }
    
    // Load in blocking task (heavy operation)
    let result = tauri::async_runtime::spawn_blocking(move || LLMEngine::new())
        .await
        .map_err(|e| format!("JoinError: {}", e))?;
    
    match result {
        Ok(engine) => {
            let mut llm_guard = state.llm.lock().unwrap();
            *llm_guard = Some(engine);
            Ok("Gemma LLM initialized successfully".to_string())
        }
        Err(e) => Err(format!("Failed to load LLM: {}", e)),
    }
}
```

#### Function 2: `run_llm_inference()` (Lines 36-65)
```rust
#[tauri::command]
pub async fn run_llm_inference(
    state: State<'_, AudioState>,
    prompt: String,
) -> Result<String, String> {
    let llm_handle = state.llm.clone();
    
    let output = tauri::async_runtime::spawn_blocking(move || {
        let mut llm_guard = llm_handle.lock().unwrap();
        if let Some(engine) = llm_guard.as_mut() {
            engine.run(&prompt).map_err(|e| e.to_string())
        } else {
            Err("LLM not initialized".to_string())
        }
    })
    .await??;
    
    Ok(output)
}
```

#### Function 3: `check_llm_status()` (Lines 67-71)
```rust
#[tauri::command]
pub fn check_llm_status(state: State<'_, AudioState>) -> bool {
    state.llm.lock().unwrap().is_some()
}
```

#### Function 4: `correct_text()` (Lines 73-97)
```rust
#[tauri::command]
pub async fn correct_text(state: State<'_, AudioState>, text: String) -> Result<String, String> {
    let llm_handle = state.llm.clone();
    
    let output = tauri::async_runtime::spawn_blocking(move || {
        let mut llm_guard = llm_handle.lock().unwrap();
        if let Some(engine) = llm_guard.as_mut() {
            engine.run(&text).map_err(|e| e.to_string())
        } else {
            Err("LLM not initialized. Please load Gemma first.".to_string())
        }
    })
    .await??;
    
    Ok(output)
}
```

---

### ğŸ“„ `commands/misc.rs` - 1 Function

#### Function 1: `greet()` (Lines 2-5)
```rust
#[tauri::command]
pub fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}
```

---

### ğŸ“„ `hotkeys/listener.rs` - 1 Function

#### Function 1: `start_hotkey_listener()` (Lines 6-74)
**Purpose**: Listen for Ctrl+Win global hotkey to start/stop recording.

```rust
pub fn start_hotkey_listener(app_handle: AppHandle) {
    // Atomic flags for key states
    let ctrl_held = Arc::new(AtomicBool::new(false));
    let meta_held = Arc::new(AtomicBool::new(false));
    let recording_active = Arc::new(AtomicBool::new(false));
    
    let callback = move |event: Event| {
        match event.event_type {
            EventType::KeyPress(key) => {
                // Track key presses
                match key {
                    Key::ControlLeft | Key::ControlRight => {
                        ctrl_held.store(true, Ordering::SeqCst);
                    }
                    Key::MetaLeft | Key::MetaRight => {
                        meta_held.store(true, Ordering::SeqCst);
                    }
                    _ => {}
                }
                
                // Both pressed? Start recording!
                if ctrl_held.load(Ordering::SeqCst) 
                    && meta_held.load(Ordering::SeqCst) 
                    && !recording_active.load(Ordering::SeqCst) 
                {
                    recording_active.store(true, Ordering::SeqCst);
                    app_handle.emit("hotkey-start-recording", ());
                }
            }
            EventType::KeyRelease(key) => {
                // Track key releases
                match key {
                    Key::ControlLeft | Key::ControlRight => {
                        ctrl_held.store(false, Ordering::SeqCst);
                    }
                    Key::MetaLeft | Key::MetaRight => {
                        meta_held.store(false, Ordering::SeqCst);
                    }
                    _ => {}
                }
                
                // Either released? Stop recording!
                if recording_active.load(Ordering::SeqCst) 
                    && (!ctrl_held.load(Ordering::SeqCst) || !meta_held.load(Ordering::SeqCst))
                {
                    recording_active.store(false, Ordering::SeqCst);
                    app_handle.emit("hotkey-stop-recording", ());
                }
            }
            _ => {}
        }
    };
    
    // This blocks forever - must be run in separate thread
    listen(callback).ok();
}
```

---

### ğŸ“„ `tray/icons.rs` - 2 Functions

#### Function 1: `update_tray_icon()` (Lines 23-50)
**Purpose**: Change system tray icon based on app state.

```rust
pub fn update_tray_icon(app: &AppHandle, state: AppState) -> Result<(), String> {
    // Select icon based on state
    let icon = match state {
        AppState::Ready => tray_icon_green!(),      // ğŸŸ¢
        AppState::Recording => tray_icon_red!(),    // ğŸ”´
        AppState::Processing => tray_icon_yellow!(), // ğŸŸ¡
    };
    
    // Select tooltip text
    let tooltip = match state {
        AppState::Ready => "Taurscribe - Ready",
        AppState::Recording => "Taurscribe - Recording...",
        AppState::Processing => "Taurscribe - Processing...",
    };
    
    // Apply changes
    if let Some(tray) = app.tray_by_id("main-tray") {
        tray.set_icon(Some(icon))?;
        tray.set_tooltip(Some(tooltip))?;
    }
    
    Ok(())
}
```

#### Function 2: `setup_tray()` (Lines 53-92)
**Purpose**: Create system tray with menu.

```rust
pub fn setup_tray(app: &tauri::App) -> Result<(), Box<dyn std::error::Error>> {
    // Create menu items
    let show_item = MenuItem::with_id(app, "show", "Show Taurscribe", true, None::<&str>)?;
    let quit_item = MenuItem::with_id(app, "quit", "Exit", true, None::<&str>)?;
    let separator = PredefinedMenuItem::separator(app)?;
    let menu = Menu::with_items(app, &[&show_item, &separator, &quit_item])?;
    
    // Build tray icon
    let _tray = TrayIconBuilder::with_id("main-tray")
        .icon(tray_icon_green!())
        .tooltip("Taurscribe - Ready")
        .menu(&menu)
        .show_menu_on_left_click(false)
        .on_menu_event(|app, event| {
            match event.id.as_ref() {
                "show" => {
                    if let Some(window) = app.get_webview_window("main") {
                        window.show();
                        window.set_focus();
                    }
                }
                "quit" => app.exit(0),
                _ => {}
            }
        })
        .on_tray_icon_event(|tray, event| {
            if let TrayIconEvent::Click { .. } = event {
                // Left-click shows window
                if let Some(window) = tray.app_handle().get_webview_window("main") {
                    window.show();
                    window.set_focus();
                }
            }
        })
        .build(app)?;
    
    Ok(())
}
```

---

### ğŸ“„ `utils.rs` - 2 Functions

#### Function 1: `clean_transcript()` (Lines 1-31)
Already documented above.

#### Function 2: `get_recordings_dir()` (Lines 33-46)
Already documented above.

---

### ğŸ“„ `state.rs` - 1 Function

#### Function 1: `AudioState::new()` (Lines 40-54)
Already documented above.

---

### ğŸ“„ `build.rs` - 1 Function

#### Function 1: `main()` (Lines 1-73)
**Purpose**: Build-time configuration for CUDA and platform-specific settings.

```rust
fn main() {
    // Standard Tauri build
    tauri_build::build();
    
    // macOS: Set deployment target for ONNX Runtime
    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=13.4");
    }
    
    // Windows ARM64: Force Clang compiler
    #[cfg(all(target_os = "windows", target_arch = "aarch64"))]
    {
        std::env::set_var("CC", "clang-cl");
        std::env::set_var("CXX", "clang-cl");
    }
    
    // Windows: Add CUDA library search paths
    #[cfg(windows)]
    {
        if let Ok(cuda_path) = std::env::var("CUDA_PATH") {
            let lib_path = PathBuf::from(cuda_path).join("lib").join("x64");
            if lib_path.exists() {
                println!("cargo:rustc-link-search=native={}", lib_path.display());
            }
        }
    }
}
```

---

## ğŸ“Š Function Count Summary

| File | Functions | Lines |
|------|-----------|-------|
| `whisper.rs` | 18 | 781 |
| `parakeet.rs` | 25 | 615 |
| `vad.rs` | 4 | 215 |
| `llm.rs` | 2 | 98 |
| `lib.rs` | 1 | 119 |
| `main.rs` | 1 | 7 |
| `state.rs` | 1 | 55 |
| `types.rs` | 0 (types only) | 31 |
| `utils.rs` | 2 | 47 |
| `audio.rs` | 0 (types only) | 17 |
| `commands/recording.rs` | 2 | 345 |
| `commands/transcription.rs` | 2 | 224 |
| `commands/models.rs` | 6 | 61 |
| `commands/settings.rs` | 4 | 56 |
| `commands/llm.rs` | 4 | 98 |
| `commands/misc.rs` | 1 | 6 |
| `hotkeys/listener.rs` | 1 | 75 |
| `tray/icons.rs` | 2 | 93 |
| `build.rs` | 1 | 74 |
| **TOTAL** | **77 functions** | **3,017 lines** |

---

## ğŸ­ Analogies for Complex Concepts

This section explains the trickiest parts of the codebase using real-world analogies.

---

### 1. `Arc<Mutex<T>>` - The Shared Notebook in a Library

**The Code:**
```rust
pub struct AudioState {
    pub whisper: Arc<Mutex<WhisperManager>>,
    pub vad: Arc<Mutex<VADManager>>,
    // ...
}
```

**The Analogy: A Shared Notebook in a Library Study Room**

Imagine a library study room where multiple students need to use the same notebook:

| Rust Concept | Library Analogy |
|--------------|-----------------|
| `WhisperManager` | The notebook itself (contains valuable information) |
| `Mutex<...>` | A lock on the notebook - only one person can write at a time |
| `Arc<...>` | Multiple library cards that all point to the same notebook |
| `.lock().unwrap()` | "I'd like to check out the notebook, please" |
| `drop(guard)` | Returning the notebook so others can use it |

**Why we need both:**
- **Without `Mutex`**: Two students write at the same time â†’ scribbled mess (data corruption)
- **Without `Arc`**: Each student gets their own copy â†’ changes aren't shared

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LIBRARY (Your Application)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Student A              Student B              Student C        â”‚
â”‚   (Main Thread)          (File Writer)          (Transcriber)    â”‚
â”‚        â”‚                      â”‚                      â”‚           â”‚
â”‚        â”‚                      â”‚                      â”‚           â”‚
â”‚        â–¼                      â–¼                      â–¼           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚  Arc    â”‚            â”‚  Arc    â”‚            â”‚  Arc    â”‚      â”‚
â”‚   â”‚(Library â”‚            â”‚(Library â”‚            â”‚(Library â”‚      â”‚
â”‚   â”‚  Card)  â”‚            â”‚  Card)  â”‚            â”‚  Card)  â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â”‚
â”‚        â”‚                      â”‚                      â”‚           â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                               â”‚                                  â”‚
â”‚                               â–¼                                  â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                    â”‚      Mutex       â”‚                          â”‚
â”‚                    â”‚   (The Lock)     â”‚                          â”‚
â”‚                    â”‚   ğŸ”’ LOCKED      â”‚                          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                             â”‚                                    â”‚
â”‚                             â–¼                                    â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                    â”‚  WhisperManager  â”‚                          â”‚
â”‚                    â”‚  (The Notebook)  â”‚                          â”‚
â”‚                    â”‚                  â”‚                          â”‚
â”‚                    â”‚  ğŸ“ Data inside  â”‚                          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2. Channels (`crossbeam_channel`) - The Sushi Conveyor Belt

**The Code:**
```rust
let (file_tx, file_rx) = unbounded::<Vec<f32>>();
let (whisper_tx, whisper_rx) = unbounded::<Vec<f32>>();

// Sender side (in audio callback)
file_tx.send(data.to_vec()).ok();

// Receiver side (in file writer thread)
while let Ok(samples) = file_rx.recv() {
    // process samples
}
```

**The Analogy: A Sushi Restaurant Conveyor Belt**

| Rust Concept | Sushi Analogy |
|--------------|---------------|
| `unbounded()` | Creating a new conveyor belt |
| `tx` (transmitter) | The chef putting plates on the belt |
| `rx` (receiver) | The customer taking plates off the belt |
| `Vec<f32>` | A plate of sushi (audio samples) |
| `.send()` | Chef places a plate on the belt |
| `.recv()` | Customer picks up a plate |
| `unbounded` | Belt can hold unlimited plates (no backpressure) |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SUSHI RESTAURANT (Recording System)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚   ğŸ¤ CHEF    â”‚  (Audio Input Callback)                        â”‚
â”‚  â”‚  (Microphone)â”‚                                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                â”‚
â”‚         â”‚                                                        â”‚
â”‚         â”‚  .send(plate)                                          â”‚
â”‚         â–¼                                                        â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚     ğŸ£ â†’ ğŸ£ â†’ ğŸ£ â†’ ğŸ£ â†’ ğŸ£ â†’ ğŸ£ â†’ ğŸ£    CONVEYOR BELT            â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚         â”‚                              â”‚                         â”‚
â”‚         â”‚ .recv()                      â”‚ .recv()                 â”‚
â”‚         â–¼                              â–¼                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  CUSTOMER 1  â”‚               â”‚  CUSTOMER 2  â”‚                 â”‚
â”‚  â”‚ (File Writer)â”‚               â”‚(Transcriber) â”‚                 â”‚
â”‚  â”‚              â”‚               â”‚              â”‚                 â”‚
â”‚  â”‚ Saves to WAV â”‚               â”‚ Runs Whisper â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Timeline:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
Chef puts    Belt moves    Customer 1    Customer 2    Everyone
plate on     plates        takes plate   takes plate   happy!
belt         along                                     ğŸ‰
```

**Why this pattern?**
- Chef doesn't wait for customers (non-blocking)
- Customers don't fight over plates (separate belts)
- Belt can buffer plates if customers are slow

---

### 3. Audio Resampling - The Currency Exchange

**The Code:**
```rust
let resampler = SincFixedIn::<f32>::new(
    16000_f64 / input_sample_rate as f64,  // Ratio: 16000/48000 = 0.333
    2.0,
    params,
    samples.len(),
    1,
)?;
let resampled = resampler.process(&[samples], None)?;
```

**The Analogy: Exchanging Currency at the Airport**

| Rust Concept | Currency Analogy |
|--------------|------------------|
| `48000 Hz audio` | 48,000 Japanese Yen |
| `16000 Hz audio` | 16,000 US Dollars (what Whisper accepts) |
| `SincFixedIn` | The currency exchange booth |
| `16000/48000 = 0.333` | Exchange rate (1 USD = 3 JPY) |
| `sinc interpolation` | Sophisticated math to avoid losing value |
| `samples.len()` | How many bills you're exchanging |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CURRENCY EXCHANGE BOOTH                       â”‚
â”‚                      (Audio Resampler)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  INPUT: 48,000 samples/second                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´â”‚ â”‚
â”‚  â”‚ ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´ğŸ’´â”‚ â”‚
â”‚  â”‚         (48,000 Japanese Yen - Microphone format)           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                    â”‚   EXCHANGE      â”‚                           â”‚
â”‚                    â”‚   RATE: 0.333   â”‚                           â”‚
â”‚                    â”‚                 â”‚                           â”‚
â”‚                    â”‚  Sinc Filter    â”‚                           â”‚
â”‚                    â”‚  (Smart math    â”‚                           â”‚
â”‚                    â”‚   to preserve   â”‚                           â”‚
â”‚                    â”‚   audio quality)â”‚                           â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                             â”‚                                    â”‚
â”‚                             â–¼                                    â”‚
â”‚  OUTPUT: 16,000 samples/second                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µğŸ’µ                        â”‚ â”‚
â”‚  â”‚         (16,000 US Dollars - Whisper format)                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  Note: We have fewer "bills" but the SAME VALUE (audio content)  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why 16kHz?**
- Whisper was trained on 16kHz audio (it only speaks "US Dollars")
- Human speech is mostly below 8kHz (Nyquist: 16kHz captures this perfectly)
- Higher sample rates waste processing power with inaudible frequencies

---

### 4. VAD (Voice Activity Detection) - The Security Guard

**The Code:**
```rust
pub fn is_speech(&mut self, audio: &[f32]) -> Result<f32, String> {
    let sum_squares: f32 = audio.iter().map(|&x| x * x).sum();
    let rms = (sum_squares / audio.len() as f32).sqrt();
    
    if rms < self.threshold { 0.0 }      // Silence
    else if rms > self.threshold * 5.0 { 1.0 }  // Definitely speech
    else { /* interpolate */ }
}
```

**The Analogy: A Security Guard at a VIP Club**

| Rust Concept | Club Analogy |
|--------------|--------------|
| VAD | The bouncer at the door |
| `audio chunk` | A person trying to enter |
| `RMS energy` | How loudly they're dressed (flashy = high energy) |
| `threshold` | Dress code minimum |
| `> 0.5` (speech) | "You may enter the Whisper VIP lounge" |
| `< 0.5` (silence) | "Sorry, too quiet. Wait outside." |
| Whisper | The expensive VIP area (costs GPU time) |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        THE WHISPER CLUB ğŸ¤                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚                           ENTRANCE                               â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                    â”‚    ğŸ•´ï¸ VAD       â”‚                           â”‚
â”‚                    â”‚   (Bouncer)     â”‚                           â”‚
â”‚                    â”‚                 â”‚                           â”‚
â”‚                    â”‚ "Let me check   â”‚                           â”‚
â”‚                    â”‚  your energy    â”‚                           â”‚
â”‚                    â”‚  level..."      â”‚                           â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                             â”‚                                    â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚              â”‚              â”‚              â”‚                     â”‚
â”‚              â–¼              â”‚              â–¼                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚     â”‚  REJECTED  â”‚          â”‚      â”‚  ACCEPTED  â”‚                â”‚
â”‚     â”‚            â”‚          â”‚      â”‚            â”‚                â”‚
â”‚     â”‚ ğŸ¤« Silence â”‚          â”‚      â”‚ ğŸ—£ï¸ Speech â”‚                â”‚
â”‚     â”‚ (RMS < 0.5)â”‚          â”‚      â”‚ (RMS > 0.5)â”‚                â”‚
â”‚     â”‚            â”‚          â”‚      â”‚            â”‚                â”‚
â”‚     â”‚ "Go home,  â”‚          â”‚      â”‚ "Welcome   â”‚                â”‚
â”‚     â”‚  nothing   â”‚          â”‚      â”‚  to the    â”‚                â”‚
â”‚     â”‚  to hear"  â”‚          â”‚      â”‚  VIP area!"â”‚                â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                             â”‚            â”‚                       â”‚
â”‚                             â”‚            â–¼                       â”‚
â”‚                             â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                             â”‚   â”‚  ğŸ­ WHISPER AI  â”‚              â”‚
â”‚                             â”‚   â”‚   VIP LOUNGE    â”‚              â”‚
â”‚                             â”‚   â”‚                 â”‚              â”‚
â”‚                             â”‚   â”‚ (Expensive GPU  â”‚              â”‚
â”‚                             â”‚   â”‚  processing)    â”‚              â”‚
â”‚                             â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WITHOUT VAD:                      WITH VAD:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Process EVERYTHINGâ”‚             â”‚ Only process     â”‚
â”‚                  â”‚              â”‚ SPEECH chunks    â”‚
â”‚ ğŸ˜° GPU: 100% loadâ”‚              â”‚                  â”‚
â”‚ ğŸŒ Slow          â”‚              â”‚ ğŸ˜ GPU: 30% load â”‚
â”‚ ğŸ’¸ Wasteful      â”‚              â”‚ ğŸš€ Fast          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ ğŸ’° Efficient     â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why VAD matters:**
- 60-70% of a typical recording is silence
- Whisper AI is expensive (GPU time = money)
- VAD = Free filter that saves 60-70% of processing

---

### 5. GPU Backends - The Transportation Options

**The Code:**
```rust
pub enum GpuBackend {
    Cuda,   // NVIDIA
    Vulkan, // AMD/Intel (Whisper)
    DirectML, // Windows (Parakeet)
    Cpu,    // Fallback
}

// Initialization tries them in order:
let (ctx, backend) = self.try_gpu(&path)
    .or_else(|_| self.try_cpu(&path))?;
```

**The Analogy: Getting to Work**

| Rust Concept | Transportation Analogy |
|--------------|------------------------|
| `Cpu` | Walking (slow but always works) |
| `Vulkan` | Taking the bus (decent, widely available) |
| `DirectML` | Taking an Uber (good on Windows) |
| `Cuda` | Taking a Ferrari (fastest, but need to own one) |
| `or_else` | "If Ferrari unavailable, try Uber, then bus, then walk" |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              HOW TO GET TO WORK (Process Audio)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ  HOME                                              ğŸ¢ WORK    â”‚
â”‚  (Raw Audio)                                    (Transcription)  â”‚
â”‚      â”‚                                                           â”‚
â”‚      â”‚                                                           â”‚
â”‚      â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    TRANSPORTATION OPTIONS                   â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  1. ğŸï¸ CUDA (Ferrari)                                       â”‚ â”‚
â”‚  â”‚     Speed: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 50x realtime                â”‚ â”‚
â”‚  â”‚     Requirement: NVIDIA GPU                                 â”‚ â”‚
â”‚  â”‚     Cost: $$$$ (need to own a Ferrari)                      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  2. ğŸš— DirectML (Uber)                                      â”‚ â”‚
â”‚  â”‚     Speed: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 30x realtime                    â”‚ â”‚
â”‚  â”‚     Requirement: Windows + Any GPU                          â”‚ â”‚
â”‚  â”‚     Cost: $$ (pay per ride)                                 â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  3. ğŸšŒ Vulkan (Bus)                                         â”‚ â”‚
â”‚  â”‚     Speed: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 20x realtime                        â”‚ â”‚
â”‚  â”‚     Requirement: Any modern GPU                             â”‚ â”‚
â”‚  â”‚     Cost: $ (public transit)                                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  4. ğŸš¶ CPU (Walking)                                        â”‚ â”‚
â”‚  â”‚     Speed: â–ˆâ–ˆâ–ˆâ–ˆ 3x realtime                                 â”‚ â”‚
â”‚  â”‚     Requirement: None (always works)                        â”‚ â”‚
â”‚  â”‚     Cost: Free (but takes forever)                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  FALLBACK LOGIC:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    âŒ     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    âŒ     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  CUDA   â”‚ â”€â”€â”€â”€â”€â”€â”€â–º â”‚ DirectMLâ”‚ â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Vulkan  â”‚          â”‚
â”‚  â”‚(Ferrari)â”‚ not      â”‚ (Uber)  â”‚ not      â”‚  (Bus)  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ availableâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ availableâ””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜          â”‚
â”‚                                                 â”‚ âŒ              â”‚
â”‚                                                 â–¼ not available  â”‚
â”‚                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                                           â”‚   CPU   â”‚            â”‚
â”‚                                           â”‚(Walking)â”‚            â”‚
â”‚                                           â”‚ ALWAYS  â”‚            â”‚
â”‚                                           â”‚ WORKS   â”‚            â”‚
â”‚                                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 6. Whisper Context/Prompting - The Conversation Memory

**The Code:**
```rust
// Store previous text
if !final_text.is_empty() {
    self.last_transcript.push_str(&final_text);
}

// Use it as context for next chunk
if !self.last_transcript.is_empty() {
    params.set_initial_prompt(&self.last_transcript);
}
```

**The Analogy: A Stenographer Taking Notes**

| Rust Concept | Stenographer Analogy |
|--------------|---------------------|
| `last_transcript` | The stenographer's notepad |
| `set_initial_prompt()` | "Here's what we discussed so far..." |
| Whisper AI | The stenographer |
| Each audio chunk | A new sentence spoken |
| Context | Memory of the conversation |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            COURTROOM STENOGRAPHER (Whisper AI)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT CONTEXT:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Speaker: "...and that's why I went to the BANK."          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Stenographer: "BANK? ğŸ¤”"                                   â”‚ â”‚
â”‚  â”‚     - River bank? (nature)                                  â”‚ â”‚
â”‚  â”‚     - Money bank? (finance)                                 â”‚ â”‚
â”‚  â”‚     - Blood bank? (medical)                                 â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Result: "...and that's why I went to the BLANK."  âŒ       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WITH CONTEXT:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Notepad (last_transcript):                                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â”‚
â”‚  â”‚  â”‚ "I needed to deposit my paycheck. The ATM was       â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  broken, so I had to go inside..."                  â”‚    â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Speaker: "...and that's why I went to the BANK."          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Stenographer: "BANK! ğŸ’¡"                                   â”‚ â”‚
â”‚  â”‚     - Context mentions paycheck, ATM, deposit              â”‚ â”‚
â”‚  â”‚     - Obviously a MONEY bank!                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Result: "...and that's why I went to the bank."  âœ…       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  TIMELINE:                                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚
â”‚                                                                  â”‚
â”‚  Chunk 1        Chunk 2           Chunk 3           Chunk 4      â”‚
â”‚  "Hello"        "my name"         "is Alice"        "nice to"    â”‚
â”‚     â”‚              â”‚                  â”‚                â”‚         â”‚
â”‚     â”‚              â”‚                  â”‚                â”‚         â”‚
â”‚     â–¼              â–¼                  â–¼                â–¼         â”‚
â”‚  Notepad:       Notepad:          Notepad:         Notepad:      â”‚
â”‚  ""             "Hello"           "Hello my        "Hello my     â”‚
â”‚                                    name"            name is      â”‚
â”‚                                                     Alice"       â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why context matters:**
- Whisper processes audio in chunks (not the whole file at once)
- Each chunk is independent by default
- Giving it previous text helps it understand ambiguous words
- Dramatically improves accuracy for names, technical terms, etc.

---

### 7. `Option<T>` and `Result<T, E>` - The Package Delivery

**The Code:**
```rust
// Option: Maybe there's something inside
let model: Option<String> = whisper.get_current_model().cloned();

// Result: Either success or failure
let transcript: Result<String, String> = whisper.transcribe_chunk(&audio, 16000);
```

**The Analogy: Checking Your Mailbox**

| Rust Concept | Mailbox Analogy |
|--------------|-----------------|
| `Option<T>` | A mailbox (might have mail, might be empty) |
| `Some(value)` | "You've got mail! ğŸ“¬" |
| `None` | "Mailbox is empty ğŸ“­" |
| `Result<T, E>` | A tracked package delivery |
| `Ok(value)` | "Package delivered successfully! ğŸ“¦" |
| `Err(error)` | "Delivery failed: Address not found ğŸš«" |
| `.unwrap()` | "I'm 100% sure there's mail, just give it to me" |
| `.ok_or()` | "If empty, pretend this error happened" |
| `?` operator | "If error, stop and return it to caller" |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPTION<T> - THE MAILBOX                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚     let current_model: Option<String> = whisper.get_current_model();
â”‚                                                                  â”‚
â”‚     SCENARIO A: Model loaded                                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚     â”‚   ğŸ“¬ MAILBOX     â”‚                                         â”‚
â”‚     â”‚                  â”‚                                         â”‚
â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                         â”‚
â”‚     â”‚  â”‚ Some(      â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚  "tiny.en" â”‚  â”‚  â† There's a model name inside!        â”‚
â”‚     â”‚  â”‚ )          â”‚  â”‚                                         â”‚
â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â”‚                                                                  â”‚
â”‚     SCENARIO B: No model loaded                                  â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚     â”‚   ğŸ“­ MAILBOX     â”‚                                         â”‚
â”‚     â”‚                  â”‚                                         â”‚
â”‚     â”‚      None        â”‚  â† Nothing here yet                     â”‚
â”‚     â”‚                  â”‚                                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â”‚                                                                  â”‚
â”‚     HANDLING IT:                                                 â”‚
â”‚     match current_model {                                        â”‚
â”‚         Some(name) => println!("Model: {}", name),  // Use it!   â”‚
â”‚         None => println!("No model loaded"),        // Handle it â”‚
â”‚     }                                                            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  RESULT<T, E> - PACKAGE DELIVERY                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚     let transcript: Result<String, String> =                     â”‚
â”‚         whisper.transcribe_chunk(&audio, 16000);                 â”‚
â”‚                                                                  â”‚
â”‚     SCENARIO A: Success!                                         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚     â”‚  ğŸ“¦ DELIVERED    â”‚                                         â”‚
â”‚     â”‚                  â”‚                                         â”‚
â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                         â”‚
â”‚     â”‚  â”‚ Ok(        â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚  "Hello    â”‚  â”‚  â† Transcription succeeded!            â”‚
â”‚     â”‚  â”‚   world"   â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚ )          â”‚  â”‚                                         â”‚
â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â”‚                                                                  â”‚
â”‚     SCENARIO B: Failure!                                         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚     â”‚  ğŸš« FAILED       â”‚                                         â”‚
â”‚     â”‚                  â”‚                                         â”‚
â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                                         â”‚
â”‚     â”‚  â”‚ Err(       â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚  "Model    â”‚  â”‚  â† Something went wrong                â”‚
â”‚     â”‚  â”‚   not      â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚   loaded"  â”‚  â”‚                                         â”‚
â”‚     â”‚  â”‚ )          â”‚  â”‚                                         â”‚
â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â”‚                                                                  â”‚
â”‚     HANDLING IT:                                                 â”‚
â”‚     match transcript {                                           â”‚
â”‚         Ok(text) => println!("Heard: {}", text),                 â”‚
â”‚         Err(e) => eprintln!("Error: {}", e),                     â”‚
â”‚     }                                                            â”‚
â”‚                                                                  â”‚
â”‚     OR with ? operator (propagate error to caller):              â”‚
â”‚     let text = whisper.transcribe_chunk(&audio, 16000)?;         â”‚
â”‚     // If Err, function returns early with that error            â”‚
â”‚     // If Ok, unwraps and continues                              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 8. `unsafe` and `Send`/`Sync` - The Safety Waiver

**The Code:**
```rust
pub struct SendStream(pub cpal::Stream);

// "I promise this is safe to send between threads"
unsafe impl Send for SendStream {}
unsafe impl Sync for SendStream {}
```

**The Analogy: Signing a Liability Waiver at an Adventure Park**

| Rust Concept | Adventure Park Analogy |
|--------------|------------------------|
| Rust's type system | The safety rules (helmets, harnesses, etc.) |
| `Send` trait | "Can this equipment be passed to another person?" |
| `Sync` trait | "Can multiple people use this at the same time?" |
| `unsafe impl` | Signing the waiver: "I take responsibility" |
| `cpal::Stream` | A specialized piece of equipment |
| The compiler | The safety inspector |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ADVENTURE PARK SAFETY SYSTEM                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  NORMAL EQUIPMENT (Rust-approved):                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  String, Vec<f32>, etc.                                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  âœ… Send: Can pass to another person                        â”‚ â”‚
â”‚  â”‚  âœ… Sync: Multiple people can reference                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Safety Inspector: "All good! âœ“"                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  SPECIAL EQUIPMENT (cpal::Stream):                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  cpal::Stream (Audio hardware handle)                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  â“ Send: Compiler doesn't know if safe                     â”‚ â”‚
â”‚  â”‚  â“ Sync: Compiler doesn't know if safe                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Safety Inspector: "I can't verify this... ğŸ¤·"              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  YOU (the developer):                                       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â”‚
â”‚  â”‚  â”‚        ğŸ“ LIABILITY WAIVER                          â”‚    â”‚ â”‚
â”‚  â”‚  â”‚                                                     â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  I, the developer, hereby declare that:             â”‚    â”‚ â”‚
â”‚  â”‚  â”‚                                                     â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  unsafe impl Send for SendStream {}                 â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  unsafe impl Sync for SendStream {}                 â”‚    â”‚ â”‚
â”‚  â”‚  â”‚                                                     â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  I have verified that cpal::Stream:                 â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  - Can be safely moved between threads              â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  - Can be safely shared via &reference              â”‚    â”‚ â”‚
â”‚  â”‚  â”‚                                                     â”‚    â”‚ â”‚
â”‚  â”‚  â”‚  Signature: _Developer_Name_                        â”‚    â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Safety Inspector: "Okay, you signed the waiver. âœ“"         â”‚ â”‚
â”‚  â”‚                    "But if something breaks, it's on you!"  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHY WE NEED THIS:                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                  â”‚
â”‚  Thread A (Main)              Thread B (Recording)               â”‚
â”‚       â”‚                             â”‚                            â”‚
â”‚       â”‚   RecordingHandle {         â”‚                            â”‚
â”‚       â”‚     stream: SendStream      â”‚                            â”‚
â”‚       â”‚   }                         â”‚                            â”‚
â”‚       â”‚         â”‚                   â”‚                            â”‚
â”‚       â”‚         â””â”€â”€â”€â”€â”€ MOVE â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  (Need Send!)              â”‚
â”‚       â”‚                             â”‚                            â”‚
â”‚       â”‚                             â”‚                            â”‚
â”‚       â””â”€â”€â”€â”€ REFERENCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  (Need Sync!)              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why this is necessary:**
- `cpal::Stream` is from an external C library
- Rust doesn't know if it's safe to share between threads
- We (the developers) verified it's safe for our use case
- `unsafe` = "Trust me, I know what I'm doing"

---

### 9. The Recording Thread Architecture - The Restaurant Kitchen

**The Code (simplified):**
```rust
// Main thread sets up the kitchen
let (order_tx, order_rx) = unbounded();  // Order system

// Spawn chef thread
std::thread::spawn(move || {
    while let Ok(order) = order_rx.recv() {
        cook(order);
    }
});

// Waiter takes orders
stream.on_data(|food| {
    order_tx.send(food).ok();
});
```

**The Analogy: A Busy Restaurant Kitchen**

| Rust Concept | Restaurant Analogy |
|--------------|-------------------|
| Main thread | Restaurant manager |
| Audio callback | Waiter taking orders |
| File writer thread | Line cook #1 (saves to storage) |
| Transcriber thread | Line cook #2 (processes orders) |
| Channels | Order tickets on a rail |
| `stream.play()` | Opening for business |
| `drop(tx)` | Closing the kitchen |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    THE TAURSCRIBE RESTAURANT                     â”‚
â”‚                      (Recording System)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                      DINING ROOM                            â”‚ â”‚
â”‚  â”‚                      (User's Voice)                         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚    ğŸ—£ï¸ "Hello, I'd like to order..."                         â”‚ â”‚
â”‚  â”‚         â”‚                                                   â”‚ â”‚
â”‚  â”‚         â”‚ (Sound waves)                                     â”‚ â”‚
â”‚  â”‚         â–¼                                                   â”‚ â”‚
â”‚  â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                              â”‚ â”‚
â”‚  â”‚    â”‚   ğŸ¤    â”‚  WAITER (Audio Callback)                     â”‚ â”‚
â”‚  â”‚    â”‚Microphoneâ”‚  - Listens constantly                       â”‚ â”‚
â”‚  â”‚    â”‚         â”‚  - Writes orders on tickets                  â”‚ â”‚
â”‚  â”‚    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                              â”‚ â”‚
â”‚  â”‚         â”‚                                                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                                                     â”‚
â”‚            â”‚  ğŸ« Order tickets (audio chunks)                    â”‚
â”‚            â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         â”‚              KITCHEN                              â”‚ â”‚
â”‚  â”‚         â”‚          (Background Threads)                     â”‚ â”‚
â”‚  â”‚         â”‚                                                   â”‚ â”‚
â”‚  â”‚         â–¼                                                   â”‚ â”‚
â”‚  â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â”‚ â”‚
â”‚  â”‚      ğŸ«â†’ğŸ«â†’ğŸ«â†’ğŸ«    ORDER RAIL (Channel)    ğŸ«â†’ğŸ«â†’ğŸ«â†’ğŸ«      â”‚ â”‚
â”‚  â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    â”‚ â”‚
â”‚  â”‚         â”‚                              â”‚                    â”‚ â”‚
â”‚  â”‚         â”‚                              â”‚                    â”‚ â”‚
â”‚  â”‚         â–¼                              â–¼                    â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚ â”‚
â”‚  â”‚  â”‚  ğŸ‘¨â€ğŸ³ COOK #1 â”‚                â”‚  ğŸ‘¨â€ğŸ³ COOK #2 â”‚             â”‚ â”‚
â”‚  â”‚  â”‚             â”‚                â”‚             â”‚             â”‚ â”‚
â”‚  â”‚  â”‚ FILE WRITER â”‚                â”‚ TRANSCRIBER â”‚             â”‚ â”‚
â”‚  â”‚  â”‚             â”‚                â”‚             â”‚             â”‚ â”‚
â”‚  â”‚  â”‚ "I'll save  â”‚                â”‚ "I'll send  â”‚             â”‚ â”‚
â”‚  â”‚  â”‚  this to    â”‚                â”‚  this to    â”‚             â”‚ â”‚
â”‚  â”‚  â”‚  the walk-inâ”‚                â”‚  Whisper"   â”‚             â”‚ â”‚
â”‚  â”‚  â”‚  freezer"   â”‚                â”‚             â”‚             â”‚ â”‚
â”‚  â”‚  â”‚             â”‚                â”‚             â”‚             â”‚ â”‚
â”‚  â”‚  â”‚   ğŸ“ WAV    â”‚                â”‚   ğŸ§  AI     â”‚             â”‚ â”‚
â”‚  â”‚  â”‚   File      â”‚                â”‚  Whisper    â”‚             â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜             â”‚ â”‚
â”‚  â”‚                                        â”‚                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                           â”‚                      â”‚
â”‚                                           â–¼                      â”‚
â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚                                  â”‚  ğŸ“± FRONTEND â”‚                â”‚
â”‚                                  â”‚             â”‚                 â”‚
â”‚                                  â”‚ "Your order â”‚                 â”‚
â”‚                                  â”‚  is ready!" â”‚                 â”‚
â”‚                                  â”‚             â”‚                 â”‚
â”‚                                  â”‚ "Hello, I'd â”‚                 â”‚
â”‚                                  â”‚  like to    â”‚                 â”‚ 
â”‚                                  â”‚  order..."  â”‚                 â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TIMELINE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º

  t=0         t=1         t=2         t=3         t=4
  â”‚           â”‚           â”‚           â”‚           â”‚
  â”‚           â”‚           â”‚           â”‚           â”‚
  â–¼           â–¼           â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”
â”‚OPEN â”‚    â”‚Orderâ”‚    â”‚Orderâ”‚    â”‚Orderâ”‚    â”‚CLOSEâ”‚
â”‚DOORSâ”‚    â”‚ #1  â”‚    â”‚ #2  â”‚    â”‚ #3  â”‚    â”‚DOORSâ”‚
â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
           â•‘     â•‘    â•‘     â•‘    â•‘     â•‘
           â•‘     â•‘    â•‘     â•‘    â•‘     â•‘
           â–¼     â–¼    â–¼     â–¼    â–¼     â–¼
        Cook #1    Cook #1    Cook #1    
        saves      saves      saves     
                                        
        Cook #2    Cook #2    Cook #2    
        transcribes           transcribes
        (if speech)           (if speech)
```

**Why multiple threads?**
- Waiter can't stop for chefs (audio callback must be fast)
- Chefs work independently (file writing doesn't block AI)
- Order rail prevents lost tickets (channel buffers data)
- Closing doors signals kitchen to finish up (dropping tx)

---

### 10. Tauri Commands - The Drive-Through Window

**The Code:**
```rust
#[tauri::command]
pub fn start_recording(
    app_handle: AppHandle,
    state: State<AudioState>,
) -> Result<String, String> {
    // ... do stuff
    Ok("Recording started".to_string())
}
```

**The Analogy: A Fast Food Drive-Through**

| Rust Concept | Drive-Through Analogy |
|--------------|----------------------|
| Frontend (React) | Customer in car |
| Tauri Command | The ordering speaker/window |
| `#[tauri::command]` | "This window accepts orders" |
| `State<AudioState>` | Access to the kitchen equipment |
| `AppHandle` | Walkie-talkie to communicate back |
| `Result<String, String>` | Either food or "Sorry, we're out" |
| `invoke("start_recording")` | Customer places order |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAURSCRIBE DRIVE-THROUGH                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  CUSTOMER (Frontend - React/TypeScript)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     ğŸš— "I'd like to start_recording, please!"               â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     await invoke("start_recording")                         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â”‚ Order                             â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     ğŸ¤ ORDERING SPEAKER (#[tauri::command])                 â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     "Welcome to Taurscribe!                                 â”‚ â”‚
â”‚  â”‚      One start_recording coming right up..."                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     MENU:                                                   â”‚ â”‚
â”‚  â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚     â”‚ start_recording  â”‚ stop_recording            â”‚       â”‚ â”‚
â”‚  â”‚     â”‚ list_models      â”‚ switch_model              â”‚       â”‚ â”‚
â”‚  â”‚     â”‚ init_parakeet    â”‚ get_backend_info          â”‚       â”‚ â”‚
â”‚  â”‚     â”‚ benchmark_test   â”‚ correct_text              â”‚       â”‚ â”‚
â”‚  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â”‚ Forward to kitchen                â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    ğŸ­ KITCHEN (Rust Backend)                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     fn start_recording(state: State<AudioState>) {          â”‚ â”‚
â”‚  â”‚         // Setup microphone                                 â”‚ â”‚
â”‚  â”‚         // Create threads                                   â”‚ â”‚
â”‚  â”‚         // Start recording                                  â”‚ â”‚
â”‚  â”‚         Ok("Recording started: /path/to/file.wav")          â”‚ â”‚
â”‚  â”‚     }                                                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â”‚ Result                            â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚     ğŸš— CUSTOMER RECEIVES ORDER                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     const result = await invoke("start_recording");         â”‚ â”‚
â”‚  â”‚     // result = "Recording started: /path/to/file.wav"      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚     OR if error:                                            â”‚ â”‚
â”‚  â”‚     // catch(e) â†’ "No microphone detected"                  â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMMUNICATION FLOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Frontend                    Tauri                     Backend
  (React)                    Bridge                     (Rust)
     â”‚                          â”‚                          â”‚
     â”‚   invoke("cmd", args)    â”‚                          â”‚
     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                          â”‚
     â”‚                          â”‚    #[tauri::command]     â”‚
     â”‚                          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
     â”‚                          â”‚                          â”‚
     â”‚                          â”‚    Ok("result") or       â”‚
     â”‚                          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
     â”‚                          â”‚    Err("error")          â”‚
     â”‚   Promise resolves       â”‚                          â”‚
     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                          â”‚
     â”‚                          â”‚                          â”‚
```

---

## ğŸ“š Analogy Quick Reference

| Complex Concept | Simple Analogy |
|-----------------|----------------|
| `Arc<Mutex<T>>` | Shared notebook with a lock in a library |
| Channels | Sushi conveyor belt |
| Resampling | Currency exchange |
| VAD | Bouncer at a VIP club |
| GPU Backends | Transportation options (Ferrari â†’ Walking) |
| Whisper Context | Stenographer's notepad |
| `Option<T>` | Mailbox (might be empty) |
| `Result<T, E>` | Package delivery (success or failure) |
| `unsafe Send/Sync` | Liability waiver at adventure park |
| Thread Architecture | Restaurant kitchen with multiple cooks |
| Tauri Commands | Fast food drive-through window |

---

## ğŸ”¬ Data Type Decisions: Why These Types?

This section explains the reasoning behind every major data type choice in the codebase, including why alternatives were rejected.

---

### 1. `Arc<Mutex<T>>` for Shared State

**What we chose:**
```rust
pub struct AudioState {
    pub whisper: Arc<Mutex<WhisperManager>>,
    pub vad: Arc<Mutex<VADManager>>,
    pub parakeet: Arc<Mutex<ParakeetManager>>,
    // ...
}
```

**Why `Arc<Mutex<T>>`?**

| Requirement | Why Arc<Mutex<T>> Satisfies It |
|-------------|-------------------------------|
| Multiple threads need access | `Arc` = Atomic Reference Counting (thread-safe sharing) |
| Threads need to modify data | `Mutex` = Mutual Exclusion (one writer at a time) |
| Owned by Tauri state system | `Arc` allows cloning handles without moving ownership |

**Alternatives Considered:**

| Alternative | Why NOT Used |
|-------------|--------------|
| `Rc<RefCell<T>>` | âŒ NOT thread-safe! `Rc` is single-threaded only. Would panic if used across threads. |
| `Arc<RwLock<T>>` | âš ï¸ Could work, but overkill. RwLock allows multiple readers OR one writer. Our access patterns are mostly exclusive writes (recording), so Mutex is simpler. |
| `Arc<T>` (no Mutex) | âŒ Only allows read-only access. We need to modify WhisperManager's internal state. |
| Pass by argument | âŒ Can't pass owned values to spawned threads that outlive the function. |
| Global static | âŒ Rust makes global mutable state intentionally hard. Would need `lazy_static` + `Mutex` anyway. |
| Channels only | âš ï¸ Could work for some cases, but we need synchronous access (lock, use, unlock) not async message passing. |

**Visual comparison:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SHARING DATA ACROSS THREADS                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  âŒ Rc<RefCell<T>> - SINGLE THREAD ONLY                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Thread A        Thread B                                â”‚    â”‚
â”‚  â”‚     â”‚               â”‚                                    â”‚    â”‚
â”‚  â”‚     â”‚    clone()    â”‚                                    â”‚    â”‚
â”‚  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚    â”‚
â”‚  â”‚           ğŸ’¥ PANIC! Rc is not Send!                      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â”‚  âš ï¸ Arc<RwLock<T>> - WORKS BUT OVERKILL                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Thread A (read)   Thread B (read)   Thread C (write)    â”‚    â”‚
â”‚  â”‚     â”‚                  â”‚                  â”‚              â”‚    â”‚
â”‚  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚              â”‚    â”‚
â”‚  â”‚            âœ“ Both can read               â”‚              â”‚    â”‚
â”‚  â”‚            simultaneously                 â”‚ âœ— Must wait  â”‚    â”‚
â”‚  â”‚                                                          â”‚    â”‚
â”‚  â”‚  Good for: Many readers, few writers                     â”‚    â”‚
â”‚  â”‚  Our case: Mostly exclusive access â†’ Mutex simpler       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â”‚  âœ… Arc<Mutex<T>> - PERFECT FIT                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Thread A          Thread B          Thread C            â”‚    â”‚
â”‚  â”‚     â”‚                  â”‚                  â”‚              â”‚    â”‚
â”‚  â”‚     â”‚  lock()         â”‚                  â”‚              â”‚    â”‚
â”‚  â”‚     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚              â”‚    â”‚
â”‚  â”‚     â”‚  USE DATA       â”‚ (waiting)        â”‚ (waiting)    â”‚    â”‚
â”‚  â”‚     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚              â”‚    â”‚
â”‚  â”‚     â”‚  drop(guard)    â”‚                  â”‚              â”‚    â”‚
â”‚  â”‚     â”‚                 â”‚  lock()          â”‚              â”‚    â”‚
â”‚  â”‚     â”‚                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚    â”‚
â”‚  â”‚     â”‚                 â”‚  USE DATA        â”‚ (waiting)    â”‚    â”‚
â”‚  â”‚                                                          â”‚    â”‚
â”‚  â”‚  Simple, correct, efficient for our use case             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2. `Vec<f32>` for Audio Samples

**What we chose:**
```rust
pub fn transcribe_chunk(&mut self, samples: &[f32], sample_rate: u32) -> Result<String, String>
```

**Why `f32` (not `f64`, `i16`, `i32`)?**

| Type | Pros | Cons | Verdict |
|------|------|------|---------|
| `f32` | Whisper expects f32, GPU optimized for f32, half the memory of f64 | Slightly less precision | âœ… **CHOSEN** |
| `f64` | More precision | Whisper doesn't need it, 2x memory, slower on GPU | âŒ Overkill |
| `i16` | Native WAV format, compact | Need to convert to f32 anyway for Whisper | âŒ Extra conversion step |
| `i32` | More range than i16 | Still need f32 conversion, uncommon format | âŒ No benefit |

**Why `Vec<f32>` (not `&[f32]`, `Box<[f32]>`, `ArrayVec`)?**

| Type | Pros | Cons | Verdict |
|------|------|------|---------|
| `Vec<f32>` | Growable, owned, can be moved between threads | Heap allocation | âœ… **CHOSEN** |
| `&[f32]` | No allocation, fast | Can't own, can't send to thread, lifetime issues | âŒ Can't move to spawned threads |
| `Box<[f32]>` | Owned, fixed size | Can't grow, awkward to create | âŒ Need growable for accumulation |
| `ArrayVec<f32, N>` | Stack allocated, no heap | Fixed max size, can't handle variable audio lengths | âŒ Audio chunks vary in size |

**Why f32 precision is enough:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AUDIO PRECISION COMPARISON                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  HUMAN HEARING DYNAMIC RANGE:                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Threshold         Whisper         Pain threshold           â”‚ â”‚
â”‚  â”‚  of hearing                        (120 dB)                 â”‚ â”‚
â”‚  â”‚     â”‚                                  â”‚                    â”‚ â”‚
â”‚  â”‚     0 dB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 120 dB                 â”‚ â”‚
â”‚  â”‚     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ~120 dB range â”€â”€â”€â”€â”€â–ºâ”‚                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  f32 PRECISION:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ 23 bits of mantissa = ~140 dB dynamic range              â”‚ â”‚
â”‚  â”‚  â€¢ MORE than human hearing needs!                           â”‚ â”‚
â”‚  â”‚  â€¢ Standard for audio processing industry                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  f64 PRECISION:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ 52 bits of mantissa = ~310 dB dynamic range              â”‚ â”‚
â”‚  â”‚  â€¢ WAY more than needed                                     â”‚ â”‚
â”‚  â”‚  â€¢ 2x memory, slower processing                             â”‚ â”‚
â”‚  â”‚  â€¢ Used for scientific computing, not audio                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  CONCLUSION: f32 is perfect. f64 wastes resources.               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3. `String` vs `&str` for Transcripts

**What we chose:**
```rust
pub struct WhisperManager {
    last_transcript: String,  // Owned string
    // ...
}

pub fn transcribe_chunk(&mut self, ...) -> Result<String, String>  // Returns owned
```

**Why `String` (not `&str`)?**

| Scenario | `String` | `&str` |
|----------|----------|--------|
| Store in struct | âœ… Owns the data | âŒ Needs lifetime parameter, can't outlive source |
| Return from function | âœ… Caller owns result | âŒ What does it borrow from? Lifetime hell |
| Modify (append) | âœ… `.push_str()` works | âŒ Immutable by nature |
| Send to frontend | âœ… Serializes cleanly | âš ï¸ Works but must clone anyway |
| Accumulate context | âœ… Can grow | âŒ Fixed size slice |

**The lifetime problem with `&str`:**
```rust
// âŒ THIS WON'T COMPILE
pub struct WhisperManager {
    last_transcript: &str,  // Error: missing lifetime specifier
}

// âŒ EVEN WITH LIFETIME, STILL BROKEN
pub struct WhisperManager<'a> {
    last_transcript: &'a str,  // But where does 'a come from?
}

// The string is CREATED inside transcribe_chunk(), so it can't
// outlive the function. We'd be returning a reference to a local!

// âœ… THIS WORKS
pub struct WhisperManager {
    last_transcript: String,  // Owns the data, no lifetime issues
}
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STRING OWNERSHIP FLOW                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  INSIDE transcribe_chunk():                                      â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let mut transcript = String::new();  // Created here       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  for segment in segments {                                  â”‚ â”‚
â”‚  â”‚      transcript.push_str(&segment);   // Accumulate         â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  self.last_transcript.push_str(&transcript);  // Store copy â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Ok(transcript)  // MOVE ownership to caller                â”‚ â”‚
â”‚  â”‚       â”‚                                                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚          â”‚                                                       â”‚
â”‚          â”‚ Ownership moves OUT                                   â”‚
â”‚          â–¼                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  CALLER:                                                    â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let result = whisper.transcribe_chunk(&audio, 16000)?;     â”‚ â”‚
â”‚  â”‚  //    ^^^^^^ Now OWNS the String                           â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  app.emit("transcription", result);  // Can move again      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  If we used &str:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let transcript = String::new();  // Created here           â”‚ â”‚
â”‚  â”‚  // ...                                                     â”‚ â”‚
â”‚  â”‚  Ok(&transcript)  // âŒ ERROR! Can't return reference to    â”‚ â”‚
â”‚  â”‚                   //    local variable - it's about to die! â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 4. `Option<T>` vs Sentinel Values

**What we chose:**
```rust
pub struct WhisperManager {
    context: Option<WhisperContext>,  // None = not loaded
    current_model: Option<String>,    // None = no model selected
}
```

**Why `Option<T>` (not sentinel values)?**

| Approach | Example | Pros | Cons |
|----------|---------|------|------|
| `Option<T>` | `context: Option<WhisperContext>` | Type-safe, compiler enforces handling | Extra enum wrapper |
| Sentinel value | `model_name: String` with `""` meaning "none" | No wrapper | âŒ Easy to forget check, `""` might be valid |
| Nullable pointer | `context: *mut WhisperContext` with `null` | C-compatible | âŒ Unsafe, no compiler help |
| Boolean flag | `is_loaded: bool` + `context: WhisperContext` | Explicit | âŒ Can get out of sync, can't have uninitialized context |

**The sentinel value trap:**
```rust
// âŒ BAD: Using empty string as "none"
pub struct WhisperManager {
    current_model: String,  // "" means no model
}

// Easy to forget the check:
fn get_model_name(&self) -> &str {
    &self.current_model  // Oops! Returns "" instead of indicating "none"
}

// What if "" is a valid model name? (unlikely but possible)
// The compiler can't help you remember to check!

// âœ… GOOD: Using Option
pub struct WhisperManager {
    current_model: Option<String>,
}

// Compiler FORCES you to handle both cases:
fn get_model_name(&self) -> Option<&String> {
    self.current_model.as_ref()  // Explicit: might be None
}

// Can't accidentally use a None value:
let name = whisper.current_model;  // Type is Option<String>, not String
// Must handle: name.unwrap(), name.expect(), match name { ... }, etc.
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              OPTION<T> vs SENTINEL VALUES                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  SENTINEL VALUE (Bad):                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  current_model: String                                      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Value: "tiny.en"    â†’ Model is tiny.en                     â”‚ â”‚
â”‚  â”‚  Value: "large-v3"   â†’ Model is large-v3                    â”‚ â”‚
â”‚  â”‚  Value: ""           â†’ No model? Or bug? Or valid?          â”‚ â”‚
â”‚  â”‚         ^^                                                  â”‚ â”‚
â”‚  â”‚         ğŸ¤” Ambiguous! Is "" intentional or a mistake?       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  COMPILER: "Looks fine to me! ğŸ¤·"                           â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  OPTION<T> (Good):                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  current_model: Option<String>                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Value: Some("tiny.en")  â†’ Model is tiny.en                 â”‚ â”‚
â”‚  â”‚  Value: Some("large-v3") â†’ Model is large-v3                â”‚ â”‚
â”‚  â”‚  Value: None             â†’ EXPLICITLY no model              â”‚ â”‚
â”‚  â”‚         ^^^^                                                â”‚ â”‚
â”‚  â”‚         âœ… Crystal clear! Impossible to misinterpret.       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  COMPILER: "You MUST handle the None case! ğŸ›¡ï¸"              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5. `Result<T, String>` vs Custom Error Types

**What we chose:**
```rust
pub fn transcribe_chunk(&mut self, ...) -> Result<String, String>
pub fn initialize(&mut self, ...) -> Result<String, String>
```

**Why `Result<T, String>` (not custom error enum)?**

| Approach | Example | Pros | Cons |
|----------|---------|------|------|
| `Result<T, String>` | `Result<String, String>` | Simple, human-readable errors, easy to serialize to frontend | Less structured, can't match on error types |
| Custom error enum | `Result<String, WhisperError>` | Pattern matching, structured | More boilerplate, overkill for Tauri commands |
| `anyhow::Error` | `Result<String, anyhow::Error>` | Ergonomic, chains errors | External dependency, less control |
| `thiserror` | Custom error with derive macro | Best of both worlds | More code, more complexity |

**Why `String` is fine for this project:**

```rust
// Our errors go directly to the frontend:
#[tauri::command]
pub fn start_recording(...) -> Result<String, String> {
    // Error needs to be displayable to user anyway
    let device = host.default_input_device()
        .ok_or("No microphone detected")?;  // User-friendly message
    
    // ...
}

// In frontend (TypeScript):
try {
    await invoke("start_recording");
} catch (error) {
    showToast(error);  // Error is already a nice string!
}
```

**When you WOULD use custom errors:**
```rust
// If we needed to handle errors differently based on type:
enum WhisperError {
    ModelNotFound(String),
    GpuUnavailable,
    AudioTooShort,
    NetworkError(std::io::Error),
}

// Then we could do:
match whisper.transcribe_chunk(&audio, 16000) {
    Ok(text) => show_text(text),
    Err(WhisperError::GpuUnavailable) => fallback_to_cpu(),  // Specific handling
    Err(WhisperError::AudioTooShort) => wait_for_more_audio(),
    Err(e) => show_error(e),
}

// But our app just shows errors to user, so String is simpler.
```

---

### 6. `crossbeam_channel` vs `std::sync::mpsc`

**What we chose:**
```rust
use crossbeam_channel::unbounded;

let (file_tx, file_rx) = unbounded::<Vec<f32>>();
```

**Why `crossbeam_channel` (not `std::sync::mpsc`)?**

| Feature | `std::sync::mpsc` | `crossbeam_channel` |
|---------|-------------------|---------------------|
| Multi-producer | âœ… Yes (mpsc) | âœ… Yes |
| Multi-consumer | âŒ No (single consumer) | âœ… Yes (mpmc) |
| Clone receiver | âŒ Can't clone Receiver | âœ… Can clone |
| Select/try_recv | âš ï¸ Limited | âœ… Full support |
| Performance | Good | Better (lock-free) |
| Bounded channels | âš ï¸ sync_channel only | âœ… First-class |

**Our specific need:**
```rust
// We clone the sender to give to multiple producers:
let file_tx_clone = file_tx.clone();    // For audio callback
let whisper_tx_clone = whisper_tx.clone();  // For audio callback

// std::sync::mpsc can do this (clone sender is fine)
// BUT crossbeam is faster and we might need multi-consumer later
```

**Visual comparison:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHANNEL COMPARISON                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  std::sync::mpsc (Multi-Producer, Single-Consumer):              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚   Producer 1 â”€â”€â”                                            â”‚ â”‚
â”‚  â”‚                â”œâ”€â”€â–º Channel â”€â”€â–º Consumer                    â”‚ â”‚
â”‚  â”‚   Producer 2 â”€â”€â”˜              (only one!)                   â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚   âŒ Can't have: Channel â”€â”€â”¬â”€â”€â–º Consumer 1                  â”‚ â”‚
â”‚  â”‚                            â””â”€â”€â–º Consumer 2                  â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  crossbeam_channel (Multi-Producer, Multi-Consumer):             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚   Producer 1 â”€â”€â”              â”Œâ”€â”€â–º Consumer 1               â”‚ â”‚
â”‚  â”‚                â”œâ”€â”€â–º Channel â”€â”€â”¤                             â”‚ â”‚
â”‚  â”‚   Producer 2 â”€â”€â”˜              â””â”€â”€â–º Consumer 2               â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚   âœ… Can clone both sender AND receiver                     â”‚ â”‚
â”‚  â”‚   âœ… Lock-free implementation (faster)                      â”‚ â”‚
â”‚  â”‚   âœ… Better select! macro support                           â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHY WE CHOSE CROSSBEAM:                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  1. Already a dependency (via other crates)                 â”‚ â”‚
â”‚  â”‚  2. Better performance in high-throughput audio scenario    â”‚ â”‚
â”‚  â”‚  3. Flexibility if we need multi-consumer later             â”‚ â”‚
â”‚  â”‚  4. Cleaner API for bounded channels                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 7. `u32` for Sample Rate vs Other Integer Types

**What we chose:**
```rust
pub fn transcribe_chunk(&mut self, samples: &[f32], input_sample_rate: u32) -> Result<String, String>
```

**Why `u32` (not `usize`, `u16`, `i32`)?**

| Type | Range | Verdict |
|------|-------|---------|
| `u32` | 0 to 4,294,967,295 | âœ… Matches audio industry standard, can represent any sample rate |
| `usize` | Platform-dependent (32 or 64 bit) | âŒ Overkill, inconsistent across platforms |
| `u16` | 0 to 65,535 | âŒ Too small! 192kHz audio wouldn't fit |
| `i32` | -2B to +2B | âŒ Negative sample rates make no sense |
| `u64` | 0 to 18 quintillion | âŒ Massive overkill, wastes memory |

**Real-world sample rates:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMMON SAMPLE RATES                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Sample Rate     Use Case                   Fits in u32?         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚  8,000 Hz        Telephone                  âœ… Yes               â”‚
â”‚  16,000 Hz       Whisper AI input           âœ… Yes               â”‚
â”‚  22,050 Hz       AM Radio                   âœ… Yes               â”‚
â”‚  44,100 Hz       CD Audio                   âœ… Yes               â”‚
â”‚  48,000 Hz       Standard microphone        âœ… Yes               â”‚
â”‚  96,000 Hz       High-res audio             âœ… Yes               â”‚
â”‚  192,000 Hz      Studio master              âœ… Yes               â”‚
â”‚  384,000 Hz      Extreme audiophile         âœ… Yes               â”‚
â”‚                                                                  â”‚
â”‚  u32 max: 4,294,967,295 Hz = 4.3 GHz                             â”‚
â”‚  That's 4.3 BILLION samples per second!                          â”‚
â”‚  No audio needs anywhere near this.                              â”‚
â”‚                                                                  â”‚
â”‚  u16 max: 65,535 Hz                                              â”‚
â”‚  âŒ Would NOT fit 96kHz or 192kHz!                               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 8. `PathBuf` vs `String` for File Paths

**What we chose:**
```rust
fn get_models_dir() -> Result<std::path::PathBuf, String>
let absolute_path = models_dir.join(&file_name);
```

**Why `PathBuf` (not `String`)?**

| Feature | `String` | `PathBuf` |
|---------|----------|-----------|
| Cross-platform | âŒ `/` vs `\` issues | âœ… Handles automatically |
| Path manipulation | âŒ Manual string concat | âœ… `.join()`, `.parent()`, `.extension()` |
| Unicode handling | âš ï¸ Assumes UTF-8 | âœ… Handles OS-native encoding |
| Type safety | âŒ Any string is "valid" | âœ… Clearly indicates "this is a path" |

**The cross-platform problem:**
```rust
// âŒ BAD: Using String for paths
let models_dir = "taurscribe-runtime/models".to_string();
let model_path = models_dir + "/" + &file_name;  // Only works on Unix!
// On Windows: "taurscribe-runtime/models/ggml-tiny.bin"
//             (forward slash might work, but inconsistent)

// âœ… GOOD: Using PathBuf
let models_dir = PathBuf::from("taurscribe-runtime/models");
let model_path = models_dir.join(&file_name);  // Works everywhere!
// On Windows: "taurscribe-runtime\models\ggml-tiny.bin"
// On Unix:    "taurscribe-runtime/models/ggml-tiny.bin"
```

**PathBuf superpowers:**
```rust
let path = PathBuf::from("/home/user/models/ggml-tiny.en-q5_1.bin");

path.file_name()      // Some("ggml-tiny.en-q5_1.bin")
path.extension()      // Some("bin")
path.parent()         // Some("/home/user/models")
path.is_absolute()    // true
path.exists()         // true/false (filesystem check)
path.join("subdir")   // "/home/user/models/ggml-tiny.en-q5_1.bin/subdir"

// With String, you'd have to implement all of this manually!
```

---

### 9. Enum vs Struct for State Machines

**What we chose:**
```rust
// For GPU backend (fixed set of options):
pub enum GpuBackend {
    Cuda,
    Vulkan,
    Cpu,
}

// For app state (fixed set of states):
pub enum AppState {
    Ready,
    Recording,
    Processing,
}

// For model info (multiple fields, not alternatives):
pub struct ModelInfo {
    pub id: String,
    pub display_name: String,
    pub file_name: String,
    pub size_mb: f32,
}
```

**When to use Enum vs Struct:**

| Use Case | Enum | Struct |
|----------|------|--------|
| **One of many options** | âœ… `GpuBackend::Cuda` | âŒ |
| **Multiple fields together** | âŒ | âœ… `ModelInfo { id, name, ... }` |
| **State machine** | âœ… `AppState::Recording` | âŒ |
| **Data container** | âŒ | âœ… `TranscriptionChunk { text, time }` |
| **Pattern matching** | âœ… `match backend { ... }` | âš ï¸ Possible but awkward |
| **Can be in multiple states** | âŒ | âœ… (use multiple bools/fields) |

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ENUM vs STRUCT                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ENUM: "I am ONE of these things"                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  enum GpuBackend {                                          â”‚ â”‚
â”‚  â”‚      Cuda,      â”€â”€â”                                         â”‚ â”‚
â”‚  â”‚      Vulkan,    â”€â”€â”¼â”€â”€ Can only be ONE at a time            â”‚ â”‚
â”‚  â”‚      Cpu,       â”€â”€â”˜                                         â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let backend = GpuBackend::Cuda;                            â”‚ â”‚
â”‚  â”‚  // It's Cuda. Not Vulkan. Not Cpu. Just Cuda.              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  STRUCT: "I have ALL of these things"                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  struct ModelInfo {                                         â”‚ â”‚
â”‚  â”‚      id: String,           â”€â”€â”                              â”‚ â”‚
â”‚  â”‚      display_name: String, â”€â”€â”¼â”€â”€ Has ALL of these           â”‚ â”‚
â”‚  â”‚      file_name: String,    â”€â”€â”¤   simultaneously             â”‚ â”‚
â”‚  â”‚      size_mb: f32,         â”€â”€â”˜                              â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let model = ModelInfo {                                    â”‚ â”‚
â”‚  â”‚      id: "tiny.en".into(),                                  â”‚ â”‚
â”‚  â”‚      display_name: "Tiny English".into(),                   â”‚ â”‚
â”‚  â”‚      file_name: "ggml-tiny.en.bin".into(),                  â”‚ â”‚
â”‚  â”‚      size_mb: 42.3,                                         â”‚ â”‚
â”‚  â”‚  };                                                         â”‚ â”‚
â”‚  â”‚  // Has ALL four fields at once                             â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WRONG CHOICES:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âŒ BAD: Struct for mutually exclusive options           â”‚ â”‚
â”‚  â”‚  struct GpuBackend {                                        â”‚ â”‚
â”‚  â”‚      is_cuda: bool,                                         â”‚ â”‚
â”‚  â”‚      is_vulkan: bool,                                       â”‚ â”‚
â”‚  â”‚      is_cpu: bool,                                          â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚  // Problem: What if is_cuda AND is_vulkan are both true?   â”‚ â”‚
â”‚  â”‚  // Enum makes this impossible by design!                   â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âŒ BAD: Enum for independent properties                 â”‚ â”‚
â”‚  â”‚  enum ModelInfo {                                           â”‚ â”‚
â”‚  â”‚      Id(String),                                            â”‚ â”‚
â”‚  â”‚      DisplayName(String),                                   â”‚ â”‚
â”‚  â”‚      FileName(String),                                      â”‚ â”‚
â”‚  â”‚      SizeMb(f32),                                           â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚  // Problem: A model has ALL of these, not just one!        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 10. Tuple vs Named Struct for Resampler Cache

**What we chose:**
```rust
pub struct WhisperManager {
    resampler: Option<(u32, usize, Box<SincFixedIn<f32>>)>,
    //                 ^^^  ^^^^^  ^^^^^^^^^^^^^^^^^^^^^^
    //                 â”‚    â”‚      â””â”€ The actual resampler
    //                 â”‚    â””â”€ Expected input chunk size
    //                 â””â”€ Source sample rate
}
```

**Why a tuple here (not a named struct)?**

| Approach | Pros | Cons |
|----------|------|------|
| Tuple `(u32, usize, Box<...>)` | Concise, private implementation detail | Less readable at call site |
| Named struct | Self-documenting field names | More boilerplate for internal detail |

**When tuples are okay:**
```rust
// âœ… GOOD: Tuple for private, simple grouping
resampler: Option<(u32, usize, Box<SincFixedIn<f32>>)>

// Usage is internal only:
if let Some((rate, size, resampler)) = &mut self.resampler {
    // Destructure gives names anyway
}

// âš ï¸ WOULD USE STRUCT IF:
// - It was part of the public API
// - It had more than 3-4 fields
// - The meaning wasn't obvious from context
```

**When to definitely use a named struct:**
```rust
// âŒ BAD: Tuple with too many elements
let config: (u32, u32, f64, bool, String, usize) = ...;
// What is each field?! ğŸ˜±

// âœ… GOOD: Named struct for clarity
struct ResamplerConfig {
    source_rate: u32,
    target_rate: u32,
    quality: f64,
    preserve_length: bool,
    algorithm: String,
    chunk_size: usize,
}
```

---

### 11. `Box<T>` for Large Types

**What we chose:**
```rust
resampler: Option<(u32, usize, Box<SincFixedIn<f32>>)>
//                             ^^^^
//                             Boxed!
```

**Why `Box<SincFixedIn<f32>>` (not just `SincFixedIn<f32>`)?**

| Storage | `SincFixedIn<f32>` | `Box<SincFixedIn<f32>>` |
|---------|-------------------|------------------------|
| Location | Stack (inline in struct) | Heap (pointer in struct) |
| Size | Large (internal buffers) | 8 bytes (just a pointer) |
| Move cost | Expensive (copy all data) | Cheap (copy pointer) |

**The problem with large stack types:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STACK vs HEAP STORAGE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT Box (everything on stack):                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  WhisperManager {                                           â”‚ â”‚
â”‚  â”‚      context: Option<...>,        // ~100 bytes            â”‚ â”‚
â”‚  â”‚      last_transcript: String,     // 24 bytes              â”‚ â”‚
â”‚  â”‚      backend: GpuBackend,         // 1 byte                â”‚ â”‚
â”‚  â”‚      current_model: Option<...>,  // 24 bytes              â”‚ â”‚
â”‚  â”‚      resampler: Option<(                                   â”‚ â”‚
â”‚  â”‚          u32,                     // 4 bytes               â”‚ â”‚
â”‚  â”‚          usize,                   // 8 bytes               â”‚ â”‚
â”‚  â”‚          SincFixedIn<f32>,        // ~50,000 bytes!! ğŸ˜±    â”‚ â”‚
â”‚  â”‚      )>,                          // (internal buffers)    â”‚ â”‚
â”‚  â”‚  }                                                         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Total: ~50KB on stack! Stack overflow risk!                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WITH Box (large data on heap):                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  WhisperManager (on stack) {                                â”‚ â”‚
â”‚  â”‚      context: Option<...>,        // ~100 bytes            â”‚ â”‚
â”‚  â”‚      last_transcript: String,     // 24 bytes              â”‚ â”‚
â”‚  â”‚      backend: GpuBackend,         // 1 byte                â”‚ â”‚
â”‚  â”‚      current_model: Option<...>,  // 24 bytes              â”‚ â”‚
â”‚  â”‚      resampler: Option<(                                   â”‚ â”‚
â”‚  â”‚          u32,                     // 4 bytes               â”‚ â”‚
â”‚  â”‚          usize,                   // 8 bytes               â”‚ â”‚
â”‚  â”‚          Box<SincFixedIn<f32>>,   // 8 bytes (pointer)     â”‚ â”‚
â”‚  â”‚      )>,                          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚ â”‚
â”‚  â”‚  }                                          â”‚              â”‚ â”‚
â”‚  â”‚                                             â”‚              â”‚ â”‚
â”‚  â”‚  Total stack: ~170 bytes âœ…                 â”‚              â”‚ â”‚
â”‚  â”‚                                             â”‚              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚                HEAP                               â”‚     â”‚ â”‚
â”‚  â”‚  â”‚                                                   â”‚     â”‚ â”‚
â”‚  â”‚  â”‚  SincFixedIn<f32> {                               â”‚     â”‚ â”‚
â”‚  â”‚  â”‚      internal_buffers: [...50KB of data...]       â”‚     â”‚ â”‚
â”‚  â”‚  â”‚  }                                                â”‚     â”‚ â”‚
â”‚  â”‚  â”‚                                                   â”‚     â”‚ â”‚
â”‚  â”‚  â”‚  Heap is much larger than stack - no problem!     â”‚     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Quick Reference: Type Decision Tree

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              WHICH TYPE SHOULD I USE?                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  SHARING DATA BETWEEN THREADS?                                   â”‚
â”‚  â”œâ”€ Yes, need write access â†’ Arc<Mutex<T>>                       â”‚
â”‚  â”œâ”€ Yes, mostly read, rare write â†’ Arc<RwLock<T>>                â”‚
â”‚  â””â”€ No, single thread â†’ Rc<RefCell<T>> or just T                 â”‚
â”‚                                                                  â”‚
â”‚  RETURNING VALUE FROM FUNCTION?                                  â”‚
â”‚  â”œâ”€ Might not exist â†’ Option<T>                                  â”‚
â”‚  â”œâ”€ Might fail â†’ Result<T, E>                                    â”‚
â”‚  â””â”€ Always exists â†’ T                                            â”‚
â”‚                                                                  â”‚
â”‚  STORING TEXT?                                                   â”‚
â”‚  â”œâ”€ Need to own/modify â†’ String                                  â”‚
â”‚  â””â”€ Just reading, no ownership â†’ &str                            â”‚
â”‚                                                                  â”‚
â”‚  COLLECTION OF ITEMS?                                            â”‚
â”‚  â”œâ”€ Unknown size, growable â†’ Vec<T>                              â”‚
â”‚  â”œâ”€ Fixed size at compile time â†’ [T; N]                          â”‚
â”‚  â””â”€ Key-value lookup â†’ HashMap<K, V>                             â”‚
â”‚                                                                  â”‚
â”‚  FILE PATH?                                                      â”‚
â”‚  â””â”€ Always use PathBuf (not String)                              â”‚
â”‚                                                                  â”‚
â”‚  MUTUALLY EXCLUSIVE OPTIONS?                                     â”‚
â”‚  â””â”€ Use Enum                                                     â”‚
â”‚                                                                  â”‚
â”‚  MULTIPLE PROPERTIES TOGETHER?                                   â”‚
â”‚  â””â”€ Use Struct                                                   â”‚
â”‚                                                                  â”‚
â”‚  LARGE DATA STRUCTURE?                                           â”‚
â”‚  â””â”€ Box<T> to put it on heap                                     â”‚
â”‚                                                                  â”‚
â”‚  THREAD COMMUNICATION?                                           â”‚
â”‚  â”œâ”€ Async message passing â†’ crossbeam_channel                    â”‚
â”‚  â””â”€ Sync shared access â†’ Arc<Mutex<T>>                           â”‚
â”‚                                                                  â”‚
â”‚  NUMERIC TYPE?                                                   â”‚
â”‚  â”œâ”€ Audio samples â†’ f32                                          â”‚
â”‚  â”œâ”€ Array index â†’ usize                                          â”‚
â”‚  â”œâ”€ Sample rate â†’ u32                                            â”‚
â”‚  â””â”€ Can be negative â†’ i32/i64                                    â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¦€ Rust Fundamentals for Beginners

This section teaches core Rust concepts using real examples from this codebase. If you're new to Rust, read this before diving into the code!

---

### 1. Ownership: Rust's Superpower

**The Golden Rule**: Every value in Rust has exactly ONE owner. When the owner goes out of scope, the value is dropped (freed).

**From our codebase:**
```rust
// In recording.rs
let filename = format!("recording_{}.wav", chrono::Utc::now().timestamp());
//  ^^^^^^^^
//  `filename` OWNS this String

let path = recordings_dir.join(&filename);
//                        ^^^^
//                        BORROWING filename (not taking ownership)

println!("Saving to: {}", filename);  // Still works! We only borrowed above
```

**What happens when ownership moves:**
```rust
// EXAMPLE: Ownership transfer
let audio = vec![0.1, 0.2, 0.3];  // `audio` owns the Vec
let processed = process(audio);    // Ownership MOVES to `process()`
// println!("{:?}", audio);        // âŒ ERROR! `audio` no longer owns the data
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OWNERSHIP VISUALIZED                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  STEP 1: Create data                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  let audio = vec![0.1, 0.2, 0.3];                         â”‚   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â”‚  audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º [0.1, 0.2, 0.3]                     â”‚   â”‚
â”‚  â”‚  (owner)              (data on heap)                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  STEP 2: Move ownership                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  let processed = process(audio);                          â”‚   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â”‚  audio â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€                                    â”‚   â”‚
â”‚  â”‚  (invalid!)         â•²                                     â”‚   â”‚
â”‚  â”‚                      â•²                                    â”‚   â”‚
â”‚  â”‚                       â•²                                   â”‚   â”‚
â”‚  â”‚  process() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º[0.1, 0.2, 0.3]                    â”‚   â”‚
â”‚  â”‚  (new owner)           (same data)                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  STEP 3: Function returns, data cleaned up                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  } // End of scope                                        â”‚   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â”‚  processed goes out of scope                              â”‚   â”‚
â”‚  â”‚                    â”‚                                      â”‚   â”‚
â”‚  â”‚                    â–¼                                      â”‚   â”‚
â”‚  â”‚           [0.1, 0.2, 0.3] is FREED                        â”‚   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â”‚  No memory leaks! No double-free! Guaranteed by compiler! â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2. Borrowing: Using Without Owning

**Two types of borrows:**
- `&T` = Immutable borrow (can read, can't modify, many allowed)
- `&mut T` = Mutable borrow (can modify, only ONE at a time)

**From our codebase:**
```rust
// In whisper.rs - Immutable borrow
pub fn transcribe_chunk(
    &mut self,           // Mutable borrow of self (we'll modify internal state)
    samples: &[f32],     // Immutable borrow of samples (just reading)
    input_sample_rate: u32,
) -> Result<String, String> {
    // We can READ samples but not modify them
    let sum: f32 = samples.iter().sum();  // âœ… Reading is fine
    // samples[0] = 0.0;                   // âŒ ERROR! Can't modify
    
    // We CAN modify self because we have &mut self
    self.last_transcript.push_str("text");  // âœ… Modifying is fine
}
```

**The borrowing rules:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BORROWING RULES                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  RULE 1: You can have EITHER:                                    â”‚
â”‚     â€¢ One mutable reference (&mut T)                             â”‚
â”‚     â€¢ OR any number of immutable references (&T)                 â”‚
â”‚     â€¢ BUT NOT BOTH at the same time!                             â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let mut data = vec![1, 2, 3];                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… VALID: Multiple immutable borrows                    â”‚ â”‚
â”‚  â”‚  let r1 = &data;                                            â”‚ â”‚
â”‚  â”‚  let r2 = &data;                                            â”‚ â”‚
â”‚  â”‚  println!("{:?} {:?}", r1, r2);  // Both reading - OK!      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… VALID: Single mutable borrow                         â”‚ â”‚
â”‚  â”‚  let r3 = &mut data;                                        â”‚ â”‚
â”‚  â”‚  r3.push(4);  // Modifying - OK!                            â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âŒ INVALID: Mutable + immutable at same time            â”‚ â”‚
â”‚  â”‚  let r4 = &data;      // Immutable borrow                   â”‚ â”‚
â”‚  â”‚  let r5 = &mut data;  // ERROR! Can't borrow mutably        â”‚ â”‚
â”‚  â”‚                       // while immutably borrowed!          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHY THIS RULE?                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Prevents data races at compile time!                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Thread A: reading data    }                                â”‚ â”‚
â”‚  â”‚  Thread B: modifying data  } = DATA RACE! ğŸ’¥               â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Rust: "You can't even COMPILE this code."                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3. The `?` Operator: Error Handling Magic

**What it does:** If the Result is `Err`, return early. If `Ok`, unwrap the value.

**From our codebase:**
```rust
// In whisper.rs
pub fn transcribe_file(&mut self, file_path: &str) -> Result<String, String> {
    // Without ? operator (verbose):
    let reader = match hound::WavReader::open(file_path) {
        Ok(r) => r,
        Err(e) => return Err(format!("Failed to open: {}", e)),
    };
    
    // With ? operator (concise):
    let reader = hound::WavReader::open(file_path)
        .map_err(|e| format!("Failed to open: {}", e))?;
    //                                              ^^
    //                                              This does the same thing!
    
    // ... rest of function
    Ok(transcript)
}
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    THE ? OPERATOR                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  some_function()?                                                â”‚
â”‚         â”‚                                                        â”‚
â”‚         â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚ Returns Result  â”‚                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                             â”‚
â”‚           â”‚                                                      â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                                                â”‚
â”‚     â”‚           â”‚                                                â”‚
â”‚     â–¼           â–¼                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”                                             â”‚
â”‚  â”‚ Ok  â”‚     â”‚ Err â”‚                                             â”‚
â”‚  â””â”€â”€â”¬â”€â”€â”˜     â””â”€â”€â”¬â”€â”€â”˜                                             â”‚
â”‚     â”‚           â”‚                                                â”‚
â”‚     â”‚           â”‚                                                â”‚
â”‚     â–¼           â–¼                                                â”‚
â”‚  Unwrap      RETURN EARLY                                        â”‚
â”‚  value       from function                                       â”‚
â”‚  and         with this error                                     â”‚
â”‚  continue                                                        â”‚
â”‚                                                                  â”‚
â”‚                                                                  â”‚
â”‚  EXAMPLE:                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  fn process() -> Result<String, String> {                   â”‚ â”‚
â”‚  â”‚      let data = read_file()?;   // If Err, return Err       â”‚ â”‚
â”‚  â”‚      let parsed = parse(data)?; // If Err, return Err       â”‚ â”‚
â”‚  â”‚      let result = compute(parsed)?; // If Err, return Err   â”‚ â”‚
â”‚  â”‚      Ok(result)  // All succeeded!                          â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Equivalent without ?:                                   â”‚ â”‚
â”‚  â”‚  fn process() -> Result<String, String> {                   â”‚ â”‚
â”‚  â”‚      let data = match read_file() {                         â”‚ â”‚
â”‚  â”‚          Ok(d) => d,                                        â”‚ â”‚
â”‚  â”‚          Err(e) => return Err(e),                           â”‚ â”‚
â”‚  â”‚      };                                                     â”‚ â”‚
â”‚  â”‚      let parsed = match parse(data) {                       â”‚ â”‚
â”‚  â”‚          Ok(p) => p,                                        â”‚ â”‚
â”‚  â”‚          Err(e) => return Err(e),                           â”‚ â”‚
â”‚  â”‚      };                                                     â”‚ â”‚
â”‚  â”‚      // ... you get the idea, MUCH more verbose!            â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 4. Closures: Anonymous Functions

**Syntax:** `|parameters| body` or `|parameters| { body }`

**From our codebase:**
```rust
// In recording.rs - Simple closure
let mono_data: Vec<f32> = data.chunks(channels)
    .map(|chunk| chunk.iter().sum::<f32>() / channels as f32)
    //   ^^^^^^^ This is a closure!
    //   |chunk| = takes one parameter called `chunk`
    //   chunk.iter().sum::<f32>() / channels as f32 = returns this value
    .collect();

// In recording.rs - Closure with move
std::thread::spawn(move || {
//                 ^^^^
//                 `move` means: take ownership of captured variables
    let mut writer = writer;  // `writer` was moved into this closure
    while let Ok(samples) = file_rx.recv() {
        // ...
    }
});
```

**Understanding `move`:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLOSURES AND MOVE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT move (borrows by default):                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let name = String::from("Alice");                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let greet = || println!("Hello, {}", name);                â”‚ â”‚
â”‚  â”‚              ^^                                             â”‚ â”‚
â”‚  â”‚              Closure BORROWS `name`                         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  greet();  // Works!                                        â”‚ â”‚
â”‚  â”‚  println!("{}", name);  // Still works! name still valid    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WITH move (takes ownership):                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let name = String::from("Alice");                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let greet = move || println!("Hello, {}", name);           â”‚ â”‚
â”‚  â”‚              ^^^^                                           â”‚ â”‚
â”‚  â”‚              Closure TAKES OWNERSHIP of `name`              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  greet();  // Works!                                        â”‚ â”‚
â”‚  â”‚  // println!("{}", name);  // âŒ ERROR! name was moved      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHY USE move WITH THREADS?                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  std::thread::spawn(move || {                               â”‚ â”‚
â”‚  â”‚      // This closure might outlive the current function!    â”‚ â”‚
â”‚  â”‚      // If we only borrowed, the data could be freed        â”‚ â”‚
â”‚  â”‚      // while the thread is still using it!                 â”‚ â”‚
â”‚  â”‚      //                                                     â”‚ â”‚
â”‚  â”‚      // `move` ensures the thread OWNS the data,            â”‚ â”‚
â”‚  â”‚      // so it will live as long as the thread needs it.     â”‚ â”‚
â”‚  â”‚  });                                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5. Pattern Matching: The Swiss Army Knife

**`match` is like `switch` on steroids.**

**From our codebase:**
```rust
// In parakeet.rs - Matching on enum
match model {
    LoadedModel::Nemotron(m) => {
        // m is the inner Nemotron value
        m.transcribe_chunk(&chunk)
    }
    LoadedModel::Ctc(m) => {
        m.transcribe_samples(audio, 16000, 1, None)
    }
    LoadedModel::Eou(m) => {
        m.transcribe(&chunk, false)
    }
    LoadedModel::Tdt(m) => {
        m.transcribe_samples(audio, 16000, 1, None)
    }
}

// In whisper.rs - Matching on Result
match WhisperContext::new_with_params(path, params) {
    Ok(ctx) => {
        // Success! ctx is the WhisperContext
        Ok((ctx, GpuBackend::Cuda))
    }
    Err(e) => {
        // Failure! e is the error
        Err(format!("Failed: {:?}", e))
    }
}
```

**`if let` and `while let` - Shorthand for single-pattern matching:**
```rust
// In recording.rs
// Instead of:
match handle.take() {
    Some(recording) => { /* use recording */ }
    None => { /* do nothing */ }
}

// You can write:
if let Some(recording) = handle.take() {
    // Only runs if it's Some
    // `recording` is the inner value
}

// while let - Loop while pattern matches
while let Ok(samples) = file_rx.recv() {
    // Loops as long as recv() returns Ok
    // Stops when recv() returns Err (channel closed)
}
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PATTERN MATCHING                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  match value {                                                   â”‚
â”‚      Pattern1 => action1,                                        â”‚
â”‚      Pattern2 => action2,                                        â”‚
â”‚      _ => default_action,  // _ matches anything                 â”‚
â”‚  }                                                               â”‚
â”‚                                                                  â”‚
â”‚  PATTERNS CAN:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Destructure enums                                       â”‚ â”‚
â”‚  â”‚  Some(value) => use(value),                                 â”‚ â”‚
â”‚  â”‚  None => handle_none(),                                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Destructure tuples                                      â”‚ â”‚
â”‚  â”‚  (x, y, z) => compute(x, y, z),                             â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Destructure structs                                     â”‚ â”‚
â”‚  â”‚  Point { x, y } => draw(x, y),                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Match ranges                                            â”‚ â”‚
â”‚  â”‚  0..=9 => println!("single digit"),                         â”‚ â”‚
â”‚  â”‚  10..=99 => println!("double digit"),                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Match with guards                                       â”‚ â”‚
â”‚  â”‚  n if n > 0 => println!("positive"),                        â”‚ â”‚
â”‚  â”‚  n if n < 0 => println!("negative"),                        â”‚ â”‚
â”‚  â”‚  _ => println!("zero"),                                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Match multiple patterns                                 â”‚ â”‚
â”‚  â”‚  Key::Left | Key::Right => move_horizontal(),               â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  MUST BE EXHAUSTIVE:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  enum Color { Red, Green, Blue }                            â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  match color {                                              â”‚ â”‚
â”‚  â”‚      Color::Red => "red",                                   â”‚ â”‚
â”‚  â”‚      Color::Green => "green",                               â”‚ â”‚
â”‚  â”‚      // âŒ ERROR! Missing Color::Blue case!                 â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Compiler: "You MUST handle all cases!"                  â”‚ â”‚
â”‚  â”‚  // This prevents bugs when you add new enum variants.      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 6. Iterators and Method Chaining

**Iterators are lazy** - they don't do anything until consumed.

**From our codebase:**
```rust
// In whisper.rs - Complex iterator chain
let mono_samples = if spec.channels == 2 {
    samples
        .chunks(2)                              // Split into pairs [L,R]
        .map(|chunk| (chunk[0] + chunk[1]) / 2.0)  // Average each pair
        .collect::<Vec<f32>>()                  // Collect into Vec
} else {
    samples
};

// In vad.rs - RMS calculation
let sum_squares: f32 = audio
    .iter()                    // Create iterator over &f32
    .map(|&x| x * x)          // Square each sample
    .sum();                    // Sum them all

// In whisper.rs - Finding models
let entries = std::fs::read_dir(&models_dir)?
    .filter_map(|e| e.ok())   // Keep only Ok values
    .filter(|e| e.path().is_file())  // Keep only files
    .filter(|e| {
        e.file_name()
            .to_str()
            .map(|n| n.starts_with("ggml-"))
            .unwrap_or(false)
    });
```

**Common iterator methods:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ITERATOR CHEAT SHEET                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  CREATING ITERATORS:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  vec.iter()       // Iterator of &T (borrowing)             â”‚ â”‚
â”‚  â”‚  vec.iter_mut()   // Iterator of &mut T (mutable borrow)    â”‚ â”‚
â”‚  â”‚  vec.into_iter()  // Iterator of T (takes ownership)        â”‚ â”‚
â”‚  â”‚  (0..10)          // Range iterator                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  TRANSFORMING:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  .map(|x| x * 2)       // Transform each element            â”‚ â”‚
â”‚  â”‚  .filter(|x| x > 5)    // Keep elements matching condition  â”‚ â”‚
â”‚  â”‚  .filter_map(|x| ...)  // Map + filter out None values      â”‚ â”‚
â”‚  â”‚  .flat_map(|x| ...)    // Map then flatten nested iterators â”‚ â”‚
â”‚  â”‚  .take(5)              // Take first 5 elements             â”‚ â”‚
â”‚  â”‚  .skip(3)              // Skip first 3 elements             â”‚ â”‚
â”‚  â”‚  .enumerate()          // Add index: (0, val), (1, val)...  â”‚ â”‚
â”‚  â”‚  .zip(other)           // Pair with another iterator        â”‚ â”‚
â”‚  â”‚  .chain(other)         // Concatenate iterators             â”‚ â”‚
â”‚  â”‚  .flatten()            // Flatten nested iterators          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  CONSUMING (these actually run the iterator):                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  .collect::<Vec<_>>()  // Collect into a collection         â”‚ â”‚
â”‚  â”‚  .sum()                // Sum all elements                  â”‚ â”‚
â”‚  â”‚  .product()            // Multiply all elements             â”‚ â”‚
â”‚  â”‚  .count()              // Count elements                    â”‚ â”‚
â”‚  â”‚  .find(|x| ...)        // Find first matching element       â”‚ â”‚
â”‚  â”‚  .any(|x| ...)         // True if any element matches       â”‚ â”‚
â”‚  â”‚  .all(|x| ...)         // True if all elements match        â”‚ â”‚
â”‚  â”‚  .for_each(|x| ...)    // Run side effect on each           â”‚ â”‚
â”‚  â”‚  .fold(init, |acc, x| ...)  // Reduce to single value       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  EXAMPLE CHAIN:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  let result = (0..100)          // 0, 1, 2, ..., 99         â”‚ â”‚
â”‚  â”‚      .filter(|n| n % 2 == 0)    // 0, 2, 4, ..., 98         â”‚ â”‚
â”‚  â”‚      .map(|n| n * n)            // 0, 4, 16, ..., 9604      â”‚ â”‚
â”‚  â”‚      .take(5)                   // 0, 4, 16, 36, 64         â”‚ â”‚
â”‚  â”‚      .sum::<i32>();             // 120                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 7. Derive Macros: Auto-Implementing Traits

**`#[derive(...)]` automatically implements traits for your types.**

**From our codebase:**
```rust
// In types.rs
#[derive(Debug, Clone, Copy, PartialEq, serde::Serialize, serde::Deserialize)]
pub enum ASREngine {
    Whisper,
    Parakeet,
}
```

**What each derive does:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMMON DERIVES                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  DERIVE          WHAT IT ENABLES                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                  â”‚
â”‚  Debug           println!("{:?}", value)  // Debug formatting   â”‚
â”‚                  Prints struct/enum internals                    â”‚
â”‚                                                                  â”‚
â”‚  Clone           value.clone()  // Deep copy                     â”‚
â”‚                  Creates a duplicate of the value                â”‚
â”‚                                                                  â”‚
â”‚  Copy            Implicit copy on assignment                     â”‚
â”‚                  let x = y;  // x is a copy, y still valid       â”‚
â”‚                  Only for small, stack-only types                â”‚
â”‚                                                                  â”‚
â”‚  PartialEq       value1 == value2  // Equality comparison        â”‚
â”‚                  Enables == and != operators                     â”‚
â”‚                                                                  â”‚
â”‚  Eq              Marker that equality is total                   â”‚
â”‚                  (NaN != NaN, so f32 can't be Eq)               â”‚
â”‚                                                                  â”‚
â”‚  PartialOrd      value1 < value2  // Ordering                   â”‚
â”‚                  Enables <, >, <=, >= operators                  â”‚
â”‚                                                                  â”‚
â”‚  Ord             Marker that ordering is total                   â”‚
â”‚                  Enables sorting                                 â”‚
â”‚                                                                  â”‚
â”‚  Hash            Can be used as HashMap key                      â”‚
â”‚                  Enables use in HashSet                          â”‚
â”‚                                                                  â”‚
â”‚  Default         Type::default()  // Default value               â”‚
â”‚                  Creates a "zero" or "empty" instance            â”‚
â”‚                                                                  â”‚
â”‚  serde::Serialize    Convert to JSON/bytes                       â”‚
â”‚                      Enables sending to frontend via Tauri       â”‚
â”‚                                                                  â”‚
â”‚  serde::Deserialize  Convert from JSON/bytes                     â”‚
â”‚                      Enables receiving from frontend             â”‚
â”‚                                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                  â”‚
â”‚  WHICH TO USE WHEN:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  Almost always:  #[derive(Debug)]                           â”‚ â”‚
â”‚  â”‚                  (makes debugging much easier)              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  For enums:      #[derive(Debug, Clone, Copy, PartialEq)]   â”‚ â”‚
â”‚  â”‚                  (enums are usually small, copyable)        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  For Tauri:      #[derive(Debug, Clone, serde::Serialize)]  â”‚ â”‚
â”‚  â”‚                  (to send to frontend)                      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  For state:      #[derive(Debug, Default)]                  â”‚ â”‚
â”‚  â”‚                  (makes initialization easier)              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 8. The Module System: Organizing Code

**Keywords:**
- `mod` = Declare a module
- `pub` = Make something public
- `use` = Bring something into scope

**From our codebase:**
```rust
// In lib.rs - Declaring modules
mod audio;       // Loads from audio.rs
mod commands;    // Loads from commands/mod.rs (it's a folder!)
mod whisper;
mod parakeet;

// In commands/mod.rs - Re-exporting
pub mod llm;
pub mod models;
pub mod recording;
// Now commands::recording::start_recording is accessible

// In lib.rs - Using items
use crate::commands::*;  // Import everything from commands
use crate::whisper::WhisperManager;  // Import specific item
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MODULE STRUCTURE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  FILE SYSTEM:                    RUST MODULE TREE:               â”‚
â”‚                                                                  â”‚
â”‚  src-tauri/src/                  crate (lib.rs)                  â”‚
â”‚  â”œâ”€â”€ lib.rs          â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ audio                       â”‚
â”‚  â”œâ”€â”€ audio.rs        â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ whisper                     â”‚
â”‚  â”œâ”€â”€ whisper.rs      â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ parakeet                    â”‚
â”‚  â”œâ”€â”€ parakeet.rs     â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ vad                         â”‚
â”‚  â”œâ”€â”€ vad.rs          â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ llm                         â”‚
â”‚  â”œâ”€â”€ llm.rs          â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ state                       â”‚
â”‚  â”œâ”€â”€ state.rs        â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ types                       â”‚
â”‚  â”œâ”€â”€ types.rs        â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ utils                       â”‚
â”‚  â”œâ”€â”€ utils.rs        â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”‚                               â”‚
â”‚  â”‚                               â”‚                               â”‚
â”‚  â”œâ”€â”€ commands/       â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ commands                    â”‚
â”‚  â”‚   â”œâ”€â”€ mod.rs                  â”‚   â”œâ”€â”€ llm                     â”‚
â”‚  â”‚   â”œâ”€â”€ llm.rs                  â”‚   â”œâ”€â”€ models                  â”‚
â”‚  â”‚   â”œâ”€â”€ models.rs               â”‚   â”œâ”€â”€ recording               â”‚
â”‚  â”‚   â””â”€â”€ ...                     â”‚   â””â”€â”€ ...                     â”‚
â”‚  â”‚                               â”‚                               â”‚
â”‚  â”œâ”€â”€ tray/           â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”œâ”€â”€ tray                        â”‚
â”‚  â”‚   â”œâ”€â”€ mod.rs                  â”‚   â””â”€â”€ icons                   â”‚
â”‚  â”‚   â””â”€â”€ icons.rs                â”‚                               â”‚
â”‚  â”‚                               â”‚                               â”‚
â”‚  â””â”€â”€ hotkeys/        â”€â”€â”€â”€â”€â”€â”€â”€â–º   â””â”€â”€ hotkeys                     â”‚
â”‚      â”œâ”€â”€ mod.rs                      â””â”€â”€ listener                â”‚
â”‚      â””â”€â”€ listener.rs                                             â”‚
â”‚                                                                  â”‚
â”‚  VISIBILITY:                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  (nothing)    = private to this module                      â”‚ â”‚
â”‚  â”‚  pub          = public (visible outside module)             â”‚ â”‚
â”‚  â”‚  pub(crate)   = public within this crate only               â”‚ â”‚
â”‚  â”‚  pub(super)   = public to parent module only                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  PATH TYPES:                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  crate::whisper::WhisperManager  // Absolute from crate rootâ”‚ â”‚
â”‚  â”‚  super::something                // Parent module           â”‚ â”‚
â”‚  â”‚  self::something                 // Current module          â”‚ â”‚
â”‚  â”‚  something                       // Relative (in scope)     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 9. Lifetimes: The Borrow Checker's Memory

**Lifetimes tell the compiler how long references are valid.**

**You'll see them as `'a`, `'static`, etc.**

**From our codebase:**
```rust
// In commands - Lifetime in function signature
#[tauri::command]
pub async fn correct_text(
    state: State<'_, AudioState>,  // '_ = "infer the lifetime"
    text: String,
) -> Result<String, String>

// What the lifetime means:
// The State reference is valid for the duration of this function call
// Tauri manages this automatically
```

**When you need explicit lifetimes:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LIFETIMES EXPLAINED                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  MOST OF THE TIME: You don't need to write lifetimes!            â”‚
â”‚  The compiler infers them (lifetime elision).                    â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // Compiler infers lifetimes here:                         â”‚ â”‚
â”‚  â”‚  fn first_word(s: &str) -> &str { ... }                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // What compiler actually sees:                            â”‚ â”‚
â”‚  â”‚  fn first_word<'a>(s: &'a str) -> &'a str { ... }           â”‚ â”‚
â”‚  â”‚  //           ^^     ^^          ^^                         â”‚ â”‚
â”‚  â”‚  //           â”‚      â”‚           â”‚                          â”‚ â”‚
â”‚  â”‚  //           â”‚      â”‚           â””â”€ Output lives as long    â”‚ â”‚
â”‚  â”‚  //           â”‚      â”‚              as input                â”‚ â”‚
â”‚  â”‚  //           â”‚      â””â”€ Input has lifetime 'a               â”‚ â”‚
â”‚  â”‚  //           â””â”€ Declare lifetime parameter                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHEN YOU NEED EXPLICIT LIFETIMES:                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Multiple references - which one does output come from?  â”‚ â”‚
â”‚  â”‚  fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {       â”‚ â”‚
â”‚  â”‚      if s1.len() > s2.len() { s1 } else { s2 }              â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Storing references in structs                           â”‚ â”‚
â”‚  â”‚  struct Excerpt<'a> {                                       â”‚ â”‚
â”‚  â”‚      text: &'a str,  // This reference must outlive struct  â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  'static LIFETIME:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // 'static = lives for entire program duration             â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let s: &'static str = "Hello";  // String literals         â”‚ â”‚
â”‚  â”‚  // String literals are baked into the binary,              â”‚ â”‚
â”‚  â”‚  // so they live forever!                                   â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  VISUAL:                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  fn example() {                                             â”‚ â”‚
â”‚  â”‚      let s1 = String::from("hello");  â”€â”€â”                   â”‚ â”‚
â”‚  â”‚                                         â”‚ 'a                â”‚ â”‚
â”‚  â”‚      {                                  â”‚                   â”‚ â”‚
â”‚  â”‚          let s2 = String::from("hi");  â”€â”¼â”€â”                 â”‚ â”‚
â”‚  â”‚                                         â”‚ â”‚ 'b              â”‚ â”‚
â”‚  â”‚          let r = longer(&s1, &s2);      â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚          //      ^^^^^^^^^^^^^^         â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚          // r's lifetime = shorter of   â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚          // s1 and s2 = 'b              â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚                                         â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚          println!("{}", r);  // OK      â”‚ â”‚                 â”‚ â”‚
â”‚  â”‚      }  // s2 dropped here â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”˜                 â”‚ â”‚
â”‚  â”‚                                         â”‚                   â”‚ â”‚
â”‚  â”‚      // Can't use r here - s2 is gone!  â”‚                   â”‚ â”‚
â”‚  â”‚  }  // s1 dropped here â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 10. `impl` Blocks: Adding Methods

**Two types of functions in `impl`:**
- **Methods**: Take `self` as first parameter (called on instance)
- **Associated functions**: No `self` (called on type, like constructors)

**From our codebase:**
```rust
impl WhisperManager {
    // Associated function (no self) - called as WhisperManager::new()
    pub fn new() -> Self {
        Self {
            context: None,
            // ...
        }
    }
    
    // Method (takes &self) - called as manager.get_backend()
    pub fn get_backend(&self) -> &GpuBackend {
        &self.backend
    }
    
    // Method (takes &mut self) - called as manager.initialize()
    pub fn initialize(&mut self, model_id: Option<&str>) -> Result<String, String> {
        // Can modify self
        self.context = Some(ctx);
        // ...
    }
    
    // Associated function (no self) - called as WhisperManager::list_available_models()
    pub fn list_available_models() -> Result<Vec<ModelInfo>, String> {
        // Note: No self parameter!
        // ...
    }
}
```

**Visual:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    METHODS vs ASSOCIATED FUNCTIONS               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  impl MyType {                                                   â”‚
â”‚      // ASSOCIATED FUNCTION (no self)                            â”‚
â”‚      // Called: MyType::new()                                    â”‚
â”‚      pub fn new() -> Self { ... }                                â”‚
â”‚      //         ^^                                               â”‚
â”‚      //         No self parameter!                               â”‚
â”‚                                                                  â”‚
â”‚      // METHOD - Immutable borrow                                â”‚
â”‚      // Called: instance.read_data()                             â”‚
â”‚      pub fn read_data(&self) -> Data { ... }                     â”‚
â”‚      //               ^^^^^                                      â”‚
â”‚      //               Borrows self, can't modify                 â”‚
â”‚                                                                  â”‚
â”‚      // METHOD - Mutable borrow                                  â”‚
â”‚      // Called: instance.modify_data()                           â”‚
â”‚      pub fn modify_data(&mut self) { ... }                       â”‚
â”‚      //                 ^^^^^^^^^                                â”‚
â”‚      //                 Borrows self mutably, can modify         â”‚
â”‚                                                                  â”‚
â”‚      // METHOD - Takes ownership                                 â”‚
â”‚      // Called: instance.consume()                               â”‚
â”‚      pub fn consume(self) { ... }                                â”‚
â”‚      //             ^^^^                                         â”‚
â”‚      //             Takes ownership, instance unusable after     â”‚
â”‚  }                                                               â”‚
â”‚                                                                  â”‚
â”‚  CALLING THEM:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Associated function - use :: syntax                     â”‚ â”‚
â”‚  â”‚  let manager = WhisperManager::new();                       â”‚ â”‚
â”‚  â”‚  //                         ^^                              â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Methods - use . syntax                                  â”‚ â”‚
â”‚  â”‚  let backend = manager.get_backend();                       â”‚ â”‚
â”‚  â”‚  //                   ^                                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Mutable method needs mut variable                       â”‚ â”‚
â”‚  â”‚  let mut manager = WhisperManager::new();                   â”‚ â”‚
â”‚  â”‚  manager.initialize(None)?;  // Needs &mut self             â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 11. Conditional Compilation: `#[cfg(...)]`

**Compile different code for different platforms/features.**

**From our codebase:**
```rust
// In whisper.rs - Different code for macOS vs others
#[cfg(target_os = "macos")]
unsafe extern "C" fn null_log_callback(_level: u32, ...) { }
//                                     ^^^
//                                     macOS uses u32

#[cfg(not(target_os = "macos"))]
unsafe extern "C" fn null_log_callback(_level: i32, ...) { }
//                                     ^^^
//                                     Other OSes use i32

// In parakeet.rs - Feature-gated code
#[cfg(any(
    target_os = "linux",
    all(target_os = "windows", target_arch = "x86_64")
))]
{
    // CUDA code - only on Linux or Windows x64
}

#[cfg(not(any(...)))]
{
    // Fallback code for other platforms
}
```

**Common `cfg` conditions:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CONDITIONAL COMPILATION                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  PLATFORM DETECTION:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  #[cfg(target_os = "windows")]                              â”‚ â”‚
â”‚  â”‚  #[cfg(target_os = "macos")]                                â”‚ â”‚
â”‚  â”‚  #[cfg(target_os = "linux")]                                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  #[cfg(target_arch = "x86_64")]   // Intel/AMD 64-bit       â”‚ â”‚
â”‚  â”‚  #[cfg(target_arch = "aarch64")]  // ARM 64-bit (M1/M2)     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  #[cfg(windows)]  // Shorthand for target_os = "windows"    â”‚ â”‚
â”‚  â”‚  #[cfg(unix)]     // Linux, macOS, BSD, etc.                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  COMBINING CONDITIONS:                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  #[cfg(not(windows))]           // NOT Windows              â”‚ â”‚
â”‚  â”‚  #[cfg(any(linux, macos))]      // Linux OR macOS           â”‚ â”‚
â”‚  â”‚  #[cfg(all(windows, x86_64))]   // Windows AND x86_64       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  FEATURE FLAGS:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  #[cfg(feature = "cuda")]       // If "cuda" feature on     â”‚ â”‚
â”‚  â”‚  #[cfg(debug_assertions)]       // Debug mode               â”‚ â”‚
â”‚  â”‚  #[cfg(test)]                   // Running tests            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  VISUAL:                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  SOURCE CODE:                                               â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚ â”‚
â”‚  â”‚  â”‚ #[cfg(windows)]                   â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚ fn do_thing() { windows_code(); } â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚                                   â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚ #[cfg(not(windows))]              â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚ fn do_thing() { unix_code(); }    â”‚                      â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚ â”‚
â”‚  â”‚                  â”‚                                          â”‚ â”‚
â”‚  â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚ â”‚
â”‚  â”‚        â”‚                   â”‚                                â”‚ â”‚
â”‚  â”‚        â–¼                   â–¼                                â”‚ â”‚
â”‚  â”‚  COMPILE FOR          COMPILE FOR                           â”‚ â”‚
â”‚  â”‚  WINDOWS:             LINUX:                                â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚ â”‚
â”‚  â”‚  â”‚ fn do_thing â”‚      â”‚ fn do_thing â”‚                       â”‚ â”‚
â”‚  â”‚  â”‚ windows_codeâ”‚      â”‚ unix_code() â”‚                       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  The OTHER version doesn't even exist in the binary!        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 12. Common Rust Idioms in This Codebase

**Patterns you'll see repeatedly:**

```rust
// 1. UNWRAP_OR - Default value if None/Err
let model = model_id.unwrap_or("tiny.en-q5_1");
// If model_id is None, use "tiny.en-q5_1"

// 2. OK_OR - Convert Option to Result
let device = host.default_input_device()
    .ok_or("No input device")?;
// If None, return Err("No input device")

// 3. MAP_ERR - Transform error type
let reader = hound::WavReader::open(file_path)
    .map_err(|e| format!("Failed to open: {}", e))?;
// Transform hound::Error into String

// 4. AS_REF - Convert Option<T> to Option<&T>
pub fn get_current_model(&self) -> Option<&String> {
    self.current_model.as_ref()
}
// Don't move out of self, just borrow

// 5. CLONED - Convert Option<&T> to Option<T>
let model_name = whisper.get_current_model().cloned();
// Get owned String from &String

// 6. INTO - Convert types
let config: StreamConfig = device.default_input_config()?.into();
// Convert SupportedStreamConfig into StreamConfig

// 7. TO_STRING / TO_OWNED - Create owned String from &str
let id = file_name.trim_start_matches("ggml-").to_string();

// 8. FORMAT! - String interpolation
let message = format!("Processing {} files", count);

// 9. COLLECT - Turn iterator into collection
let models: Vec<ModelInfo> = entries.collect();

// 10. CLONE - Explicit deep copy
let whisper = state.whisper.clone();  // Clone the Arc (cheap)
```

**Visual cheat sheet:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RUST IDIOM CHEAT SHEET                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  OPTION METHODS:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  .unwrap()           â†’ T or PANIC!                          â”‚ â”‚
â”‚  â”‚  .expect("msg")      â†’ T or PANIC with message              â”‚ â”‚
â”‚  â”‚  .unwrap_or(default) â†’ T or default value                   â”‚ â”‚
â”‚  â”‚  .unwrap_or_else(f)  â†’ T or compute default with closure    â”‚ â”‚
â”‚  â”‚  .ok_or(err)         â†’ Result<T, E>                         â”‚ â”‚
â”‚  â”‚  .map(f)             â†’ Option<U> (transform inner value)    â”‚ â”‚
â”‚  â”‚  .and_then(f)        â†’ Option<U> (chain Option operations)  â”‚ â”‚
â”‚  â”‚  .as_ref()           â†’ Option<&T>                           â”‚ â”‚
â”‚  â”‚  .as_mut()           â†’ Option<&mut T>                       â”‚ â”‚
â”‚  â”‚  .cloned()           â†’ Option<T> (clone inner value)        â”‚ â”‚
â”‚  â”‚  .is_some()          â†’ bool                                 â”‚ â”‚
â”‚  â”‚  .is_none()          â†’ bool                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  RESULT METHODS:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  .unwrap()           â†’ T or PANIC with error                â”‚ â”‚
â”‚  â”‚  .expect("msg")      â†’ T or PANIC with message              â”‚ â”‚
â”‚  â”‚  .unwrap_or(default) â†’ T or default value                   â”‚ â”‚
â”‚  â”‚  .ok()               â†’ Option<T> (discard error)            â”‚ â”‚
â”‚  â”‚  .err()              â†’ Option<E> (discard success)          â”‚ â”‚
â”‚  â”‚  .map(f)             â†’ Result<U, E>                         â”‚ â”‚
â”‚  â”‚  .map_err(f)         â†’ Result<T, F> (transform error)       â”‚ â”‚
â”‚  â”‚  .and_then(f)        â†’ Result<U, E>                         â”‚ â”‚
â”‚  â”‚  .is_ok()            â†’ bool                                 â”‚ â”‚
â”‚  â”‚  .is_err()           â†’ bool                                 â”‚ â”‚
â”‚  â”‚  ?                   â†’ Early return on Err                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  STRING CONVERSIONS:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  &str â†’ String:                                             â”‚ â”‚
â”‚  â”‚    "hello".to_string()                                      â”‚ â”‚
â”‚  â”‚    "hello".to_owned()                                       â”‚ â”‚
â”‚  â”‚    String::from("hello")                                    â”‚ â”‚
â”‚  â”‚    "hello".into()                                           â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  String â†’ &str:                                             â”‚ â”‚
â”‚  â”‚    &my_string                                               â”‚ â”‚
â”‚  â”‚    my_string.as_str()                                       â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  PathBuf â†’ &Path:                                           â”‚ â”‚
â”‚  â”‚    path_buf.as_path()                                       â”‚ â”‚
â”‚  â”‚    &path_buf                                                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  &Path â†’ PathBuf:                                           â”‚ â”‚
â”‚  â”‚    path.to_path_buf()                                       â”‚ â”‚
â”‚  â”‚    PathBuf::from(path)                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 13. Common Beginner Gotchas

**Mistakes you'll make (and how to fix them):**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMMON MISTAKES                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  GOTCHA #1: "Cannot move out of borrowed content"                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // âŒ WRONG                                                â”‚ â”‚
â”‚  â”‚  fn get_name(&self) -> String {                             â”‚ â”‚
â”‚  â”‚      self.name  // Error! Can't move out of &self           â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… FIX: Clone or return reference                       â”‚ â”‚
â”‚  â”‚  fn get_name(&self) -> String {                             â”‚ â”‚
â”‚  â”‚      self.name.clone()  // Clone it                         â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â”‚  // OR                                                      â”‚ â”‚
â”‚  â”‚  fn get_name(&self) -> &String {                            â”‚ â”‚
â”‚  â”‚      &self.name  // Return reference                        â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  GOTCHA #2: "Value borrowed here after move"                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // âŒ WRONG                                                â”‚ â”‚
â”‚  â”‚  let data = vec![1, 2, 3];                                  â”‚ â”‚
â”‚  â”‚  process(data);           // data moved here                â”‚ â”‚
â”‚  â”‚  println!("{:?}", data);  // Error! data was moved          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… FIX: Borrow instead of move                          â”‚ â”‚
â”‚  â”‚  let data = vec![1, 2, 3];                                  â”‚ â”‚
â”‚  â”‚  process(&data);          // Borrow, don't move             â”‚ â”‚
â”‚  â”‚  println!("{:?}", data);  // Works!                         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // OR clone if you need to give ownership                  â”‚ â”‚
â”‚  â”‚  process(data.clone());                                     â”‚ â”‚
â”‚  â”‚  println!("{:?}", data);  // Works!                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  GOTCHA #3: "Cannot borrow as mutable more than once"            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // âŒ WRONG                                                â”‚ â”‚
â”‚  â”‚  let mut data = vec![1, 2, 3];                              â”‚ â”‚
â”‚  â”‚  let r1 = &mut data;                                        â”‚ â”‚
â”‚  â”‚  let r2 = &mut data;  // Error! Already borrowed mutably    â”‚ â”‚
â”‚  â”‚  r1.push(4);                                                â”‚ â”‚
â”‚  â”‚  r2.push(5);                                                â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… FIX: Scope the borrows                               â”‚ â”‚
â”‚  â”‚  let mut data = vec![1, 2, 3];                              â”‚ â”‚
â”‚  â”‚  {                                                          â”‚ â”‚
â”‚  â”‚      let r1 = &mut data;                                    â”‚ â”‚
â”‚  â”‚      r1.push(4);                                            â”‚ â”‚
â”‚  â”‚  }  // r1 goes out of scope                                 â”‚ â”‚
â”‚  â”‚  {                                                          â”‚ â”‚
â”‚  â”‚      let r2 = &mut data;                                    â”‚ â”‚
â”‚  â”‚      r2.push(5);                                            â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  GOTCHA #4: "Mutex poisoned"                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // Happens when a thread panics while holding the lock     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âŒ Can crash                                            â”‚ â”‚
â”‚  â”‚  let data = mutex.lock().unwrap();                          â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… Handle poison error                                  â”‚ â”‚
â”‚  â”‚  let data = mutex.lock().unwrap_or_else(|e| e.into_inner());â”‚ â”‚
â”‚  â”‚  // OR just use unwrap if panic = unrecoverable anyway      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  GOTCHA #5: "Expected (), found String"                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // âŒ WRONG - Last expression has ;                        â”‚ â”‚
â”‚  â”‚  fn get_message() -> String {                               â”‚ â”‚
â”‚  â”‚      "hello".to_string();  // Semicolon makes it statement  â”‚ â”‚
â”‚  â”‚  }                         // Returns () not String!        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… FIX - Remove semicolon for implicit return           â”‚ â”‚
â”‚  â”‚  fn get_message() -> String {                               â”‚ â”‚
â”‚  â”‚      "hello".to_string()   // No semicolon = return this    â”‚ â”‚
â”‚  â”‚  }                                                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  GOTCHA #6: "Use of moved value in closure"                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // âŒ WRONG                                                â”‚ â”‚
â”‚  â”‚  let data = vec![1, 2, 3];                                  â”‚ â”‚
â”‚  â”‚  std::thread::spawn(|| {                                    â”‚ â”‚
â”‚  â”‚      println!("{:?}", data);  // Error! May outlive data    â”‚ â”‚
â”‚  â”‚  });                                                        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // âœ… FIX - Use move closure                               â”‚ â”‚
â”‚  â”‚  let data = vec![1, 2, 3];                                  â”‚ â”‚
â”‚  â”‚  std::thread::spawn(move || {                               â”‚ â”‚
â”‚  â”‚      println!("{:?}", data);  // data moved into closure    â”‚ â”‚
â”‚  â”‚  });                                                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 14. Memory Layout: Stack vs Heap

**Understanding where data lives:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STACK vs HEAP                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  THE STACK (Fast, Fixed-Size, Automatic):                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let x: i32 = 42;           // 4 bytes on stack             â”‚ â”‚
â”‚  â”‚  let y: f64 = 3.14;         // 8 bytes on stack             â”‚ â”‚
â”‚  â”‚  let arr: [i32; 3] = [1,2,3]; // 12 bytes on stack          â”‚ â”‚
â”‚  â”‚  let tuple: (i32, bool) = (5, true); // 5 bytes on stack    â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚ â”‚
â”‚  â”‚  â”‚     STACK          â”‚                                     â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                     â”‚ â”‚
â”‚  â”‚  â”‚ x: 42              â”‚ â† Fast access                       â”‚ â”‚
â”‚  â”‚  â”‚ y: 3.14            â”‚ â† Known size at compile time        â”‚ â”‚
â”‚  â”‚  â”‚ arr: [1, 2, 3]     â”‚ â† Automatically freed               â”‚ â”‚
â”‚  â”‚  â”‚ tuple: (5, true)   â”‚                                     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  THE HEAP (Flexible, Dynamic, Manual-ish):                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  let s: String = String::from("hello");                     â”‚ â”‚
â”‚  â”‚  let v: Vec<i32> = vec![1, 2, 3, 4, 5];                     â”‚ â”‚
â”‚  â”‚  let b: Box<i32> = Box::new(42);                            â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚     STACK          â”‚     â”‚         HEAP               â”‚  â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚ â”‚
â”‚  â”‚  â”‚ s: {ptr, len, cap} â”‚â”€â”€â”€â”€â–ºâ”‚ "hello"                    â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    (24 bytes)      â”‚     â”‚                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚                    â”‚     â”‚                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚ v: {ptr, len, cap} â”‚â”€â”€â”€â”€â–ºâ”‚ [1, 2, 3, 4, 5]            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    (24 bytes)      â”‚     â”‚                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚                    â”‚     â”‚                            â”‚  â”‚ â”‚
â”‚  â”‚  â”‚ b: ptr             â”‚â”€â”€â”€â”€â–ºâ”‚ 42                         â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    (8 bytes)       â”‚     â”‚                            â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  â†‘ Stack has POINTERS       â†‘ Heap has ACTUAL DATA          â”‚ â”‚
â”‚  â”‚    to heap data               (can grow/shrink)             â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHEN DATA IS DROPPED:                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  fn example() {                                             â”‚ â”‚
â”‚  â”‚      let s = String::from("hello");                         â”‚ â”‚
â”‚  â”‚      // s is on stack, "hello" is on heap                   â”‚ â”‚
â”‚  â”‚  }   // s goes out of scope:                                â”‚ â”‚
â”‚  â”‚      // 1. Rust calls drop(s)                               â”‚ â”‚
â”‚  â”‚      // 2. Heap memory for "hello" is freed                 â”‚ â”‚
â”‚  â”‚      // 3. Stack memory for s is reclaimed                  â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // No memory leaks! No manual free()!                      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WHY THIS MATTERS FOR OUR CODE:                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Audio data is BIG - must be on heap                     â”‚ â”‚
â”‚  â”‚  let audio: Vec<f32> = vec![0.0; 480000];  // ~2MB!         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // WhisperContext is BIG - Box it for cheaper moves        â”‚ â”‚
â”‚  â”‚  let resampler: Box<SincFixedIn<f32>> = Box::new(...);      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  // Arc means multiple owners of SAME heap data             â”‚ â”‚
â”‚  â”‚  let whisper: Arc<Mutex<WhisperManager>> = Arc::new(...);   â”‚ â”‚
â”‚  â”‚  let whisper2 = whisper.clone();  // Same heap data!        â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 15. Reading Rust Error Messages

**Rust errors are verbose but helpful. Learn to read them!**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    READING ERROR MESSAGES                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  EXAMPLE ERROR:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  error[E0382]: borrow of moved value: `data`                â”‚ â”‚
â”‚  â”‚     --> src/main.rs:5:20                                    â”‚ â”‚
â”‚  â”‚      |                                                      â”‚ â”‚
â”‚  â”‚  3   |     let data = vec![1, 2, 3];                        â”‚ â”‚
â”‚  â”‚      |         ---- move occurs because `data` has type     â”‚ â”‚
â”‚  â”‚      |              `Vec<i32>`, which does not implement    â”‚ â”‚
â”‚  â”‚      |              the `Copy` trait                        â”‚ â”‚
â”‚  â”‚  4   |     process(data);                                   â”‚ â”‚
â”‚  â”‚      |             ---- value moved here                    â”‚ â”‚
â”‚  â”‚  5   |     println!("{:?}", data);                          â”‚ â”‚
â”‚  â”‚      |                      ^^^^ value borrowed here        â”‚ â”‚
â”‚  â”‚      |                           after move                 â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  For more information about this error, try `rustc --explainâ”‚ â”‚
â”‚  â”‚  E0382`.                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  HOW TO READ IT:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  1. ERROR CODE: E0382                                       â”‚ â”‚
â”‚  â”‚     Run `rustc --explain E0382` for detailed explanation    â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  2. WHAT HAPPENED: "borrow of moved value"                  â”‚ â”‚
â”‚  â”‚     You tried to use something after giving it away         â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  3. WHERE: src/main.rs:5:20                                 â”‚ â”‚
â”‚  â”‚     File, line 5, column 20                                 â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  4. THE STORY (read the ---- arrows):                       â”‚ â”‚
â”‚  â”‚     Line 3: data created                                    â”‚ â”‚
â”‚  â”‚     Line 4: data MOVED into process()                       â”‚ â”‚
â”‚  â”‚     Line 5: tried to use data (ERROR!)                      â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â”‚  5. WHY: Vec<i32> doesn't implement Copy                    â”‚ â”‚
â”‚  â”‚     So passing it moves ownership                           â”‚ â”‚
â”‚  â”‚                                                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  COMMON ERROR CODES:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  E0382 - Use of moved value                                 â”‚ â”‚
â”‚  â”‚  E0502 - Cannot borrow as mutable (already borrowed)        â”‚ â”‚
â”‚  â”‚  E0499 - Cannot borrow mutably more than once               â”‚ â”‚
â”‚  â”‚  E0597 - Borrowed value does not live long enough           â”‚ â”‚
â”‚  â”‚  E0106 - Missing lifetime specifier                         â”‚ â”‚
â”‚  â”‚  E0308 - Mismatched types                                   â”‚ â”‚
â”‚  â”‚  E0425 - Cannot find value in scope                         â”‚ â”‚
â”‚  â”‚  E0433 - Failed to resolve (module/type not found)          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š Quick Reference Card

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RUST QUICK REFERENCE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  OWNERSHIP:                                                      â”‚
â”‚    let x = value;      // x owns value                           â”‚
â”‚    let y = x;          // ownership moves to y, x invalid        â”‚
â”‚    let z = x.clone();  // z gets a copy, x still valid           â”‚
â”‚                                                                  â”‚
â”‚  BORROWING:                                                      â”‚
â”‚    &value              // immutable borrow (can read)            â”‚
â”‚    &mut value          // mutable borrow (can modify)            â”‚
â”‚                                                                  â”‚
â”‚  ERROR HANDLING:                                                 â”‚
â”‚    Option<T>           // Some(value) or None                    â”‚
â”‚    Result<T, E>        // Ok(value) or Err(error)                â”‚
â”‚    value?              // return early if Err/None               â”‚
â”‚    value.unwrap()      // get value or panic                     â”‚
â”‚                                                                  â”‚
â”‚  PATTERN MATCHING:                                               â”‚
â”‚    match value { ... }     // exhaustive matching                â”‚
â”‚    if let Some(x) = opt    // match single pattern               â”‚
â”‚    while let Ok(x) = iter  // loop while pattern matches         â”‚
â”‚                                                                  â”‚
â”‚  CLOSURES:                                                       â”‚
â”‚    |x| x + 1               // simple closure                     â”‚
â”‚    |x, y| { ... }          // multi-line closure                 â”‚
â”‚    move |x| ...            // take ownership of captures         â”‚
â”‚                                                                  â”‚
â”‚  SMART POINTERS:                                                 â”‚
â”‚    Box<T>                  // heap allocation                    â”‚
â”‚    Rc<T>                   // reference counting (single-thread) â”‚
â”‚    Arc<T>                  // atomic ref counting (multi-thread) â”‚
â”‚    Mutex<T>                // mutual exclusion lock              â”‚
â”‚                                                                  â”‚
â”‚  COMMON TRAITS:                                                  â”‚
â”‚    Debug                   // {:?} formatting                    â”‚
â”‚    Clone                   // .clone() method                    â”‚
â”‚    Copy                    // implicit copying                   â”‚
â”‚    Send                    // can send between threads           â”‚
â”‚    Sync                    // can share between threads          â”‚
â”‚                                                                  â”‚
â”‚  MODULES:                                                        â”‚
â”‚    mod name;               // declare module                     â”‚
â”‚    pub                     // make public                        â”‚
â”‚    use crate::path::Item;  // bring into scope                   â”‚
â”‚                                                                  â”‚
â”‚  USEFUL METHODS:                                                 â”‚
â”‚    .to_string()            // &str â†’ String                      â”‚
â”‚    .as_str()               // String â†’ &str                      â”‚
â”‚    .clone()                // deep copy                          â”‚
â”‚    .into()                 // convert types                      â”‚
â”‚    .as_ref()               // Option<T> â†’ Option<&T>             â”‚
â”‚    .map()                  // transform inner value              â”‚
â”‚    .map_err()              // transform error                    â”‚
â”‚    .ok_or()                // Option â†’ Result                    â”‚
â”‚    .collect()              // iterator â†’ collection              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”Š Audio Flow Diagrams

This section shows how audio data flows through the entire system, from microphone to final transcript.

---

### Complete Recording Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMPLETE AUDIO FLOW DIAGRAM                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         PHASE 1: CAPTURE                                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚     ğŸ¤ MICROPHONE                                                            â”‚
â”‚        â”‚                                                                     â”‚
â”‚        â”‚ Raw analog sound waves                                              â”‚
â”‚        â–¼                                                                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   SOUND CARD        â”‚                                                  â”‚
â”‚     â”‚   (Hardware ADC)    â”‚                                                  â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚ Converts analog â†’   â”‚                                                  â”‚
â”‚     â”‚ digital samples     â”‚                                                  â”‚
â”‚     â”‚ @ 48000 Hz          â”‚                                                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                â”‚                                                             â”‚
â”‚                â”‚ Digital audio stream                                        â”‚
â”‚                â”‚ f32 samples, 48kHz, stereo                                  â”‚
â”‚                â–¼                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   CPAL LIBRARY      â”‚  (recording.rs)                                  â”‚
â”‚     â”‚   (Audio API)       â”‚                                                  â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚ Buffers audio into  â”‚                                                  â”‚
â”‚     â”‚ chunks (~10ms each) â”‚                                                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                â”‚                                                             â”‚
â”‚                â”‚ Vec<f32> chunks                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         PHASE 2: DISTRIBUTION                           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   AUDIO CALLBACK    â”‚  (in build_input_stream)                         â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚ For each chunk:     â”‚                                                  â”‚
â”‚     â”‚ 1. Clone to file_tx â”‚                                                  â”‚
â”‚     â”‚ 2. Convert to mono  â”‚                                                  â”‚
â”‚     â”‚ 3. Send to whisper_txâ”‚                                                 â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                â”‚                                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                                                    â”‚
â”‚       â”‚                 â”‚                                                    â”‚
â”‚       â–¼                 â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                â”‚
â”‚  â”‚ file_tx â”‚      â”‚whisper_txâ”‚                                               â”‚
â”‚  â”‚(channel)â”‚      â”‚(channel) â”‚                                               â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                                â”‚
â”‚       â”‚                â”‚                                                     â”‚
â”‚       â”‚                â”‚                                                     â”‚
â”‚       â–¼                â–¼                                                     â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         PHASE 3: PROCESSING                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   FILE WRITER       â”‚      â”‚         TRANSCRIBER THREAD                  â”‚â”‚
â”‚  â”‚   THREAD            â”‚      â”‚                                             â”‚â”‚
â”‚  â”‚                     â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â”‚
â”‚  â”‚ while recv():       â”‚      â”‚  â”‚ ACCUMULATION BUFFER                     â”‚â”‚â”‚
â”‚  â”‚   writer.write()    â”‚      â”‚  â”‚                                         â”‚â”‚â”‚
â”‚  â”‚                     â”‚      â”‚  â”‚ Collects chunks until 6 seconds         â”‚â”‚â”‚
â”‚  â”‚ Output:             â”‚      â”‚  â”‚ (288,000 samples at 48kHz)              â”‚â”‚â”‚
â”‚  â”‚ recording_XXX.wav   â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚
â”‚  â”‚                     â”‚      â”‚                 â”‚                           â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                 â–¼                           â”‚â”‚
â”‚                               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â”‚
â”‚                               â”‚  â”‚ VAD CHECK (Whisper only)                â”‚â”‚â”‚
â”‚                               â”‚  â”‚                                         â”‚â”‚â”‚
â”‚                               â”‚  â”‚ is_speech() > 0.5?                      â”‚â”‚â”‚
â”‚                               â”‚  â”‚  â”œâ”€ YES â†’ Continue to AI                â”‚â”‚â”‚
â”‚                               â”‚  â”‚  â””â”€ NO  â†’ Skip (save GPU)               â”‚â”‚â”‚
â”‚                               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚
â”‚                               â”‚                 â”‚                           â”‚â”‚
â”‚                               â”‚                 â–¼                           â”‚â”‚
â”‚                               â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚â”‚
â”‚                               â”‚  â”‚ ENGINE SELECTION                        â”‚â”‚â”‚
â”‚                               â”‚  â”‚                                         â”‚â”‚â”‚
â”‚                               â”‚  â”‚ ASREngine::Whisper?                     â”‚â”‚â”‚
â”‚                               â”‚  â”‚  â”œâ”€ YES â†’ WhisperManager                â”‚â”‚â”‚
â”‚                               â”‚  â”‚  â””â”€ NO  â†’ ParakeetManager               â”‚â”‚â”‚
â”‚                               â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚
â”‚                               â”‚                 â”‚                           â”‚â”‚
â”‚                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                 â”‚                            â”‚
â”‚                                                 â–¼                            â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         PHASE 4: TRANSCRIPTION                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚      WHISPER PATH             â”‚  â”‚        PARAKEET PATH                  â”‚â”‚
â”‚  â”‚                               â”‚  â”‚                                       â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚â”‚
â”‚  â”‚  â”‚ RESAMPLER               â”‚  â”‚  â”‚  â”‚ RESAMPLER                       â”‚  â”‚â”‚
â”‚  â”‚  â”‚ 48kHz â†’ 16kHz           â”‚  â”‚  â”‚  â”‚ 48kHz â†’ 16kHz                   â”‚  â”‚â”‚
â”‚  â”‚  â”‚ (rubato SincFixedIn)    â”‚  â”‚  â”‚  â”‚ (rubato SincFixedIn)            â”‚  â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚â”‚
â”‚  â”‚              â”‚                â”‚  â”‚                  â”‚                    â”‚â”‚
â”‚  â”‚              â–¼                â”‚  â”‚                  â–¼                    â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚â”‚
â”‚  â”‚  â”‚ WHISPER CONTEXT         â”‚  â”‚  â”‚  â”‚ PARAKEET MODEL                  â”‚  â”‚â”‚
â”‚  â”‚  â”‚                         â”‚  â”‚  â”‚  â”‚                                 â”‚  â”‚â”‚
â”‚  â”‚  â”‚ â€¢ Load previous context â”‚  â”‚  â”‚  â”‚ â€¢ Nemotron (streaming)          â”‚  â”‚â”‚
â”‚  â”‚  â”‚ â€¢ Run GGML inference    â”‚  â”‚  â”‚  â”‚ â€¢ OR CTC (batch)                â”‚  â”‚â”‚
â”‚  â”‚  â”‚ â€¢ GPU: CUDA/Vulkan      â”‚  â”‚  â”‚  â”‚ â€¢ OR TDT (batch)                â”‚  â”‚â”‚
â”‚  â”‚  â”‚ â€¢ Extract segments      â”‚  â”‚  â”‚  â”‚ â€¢ GPU: CUDA/DirectML            â”‚  â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚â”‚
â”‚  â”‚              â”‚                â”‚  â”‚                  â”‚                    â”‚â”‚
â”‚  â”‚              â–¼                â”‚  â”‚                  â–¼                    â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚â”‚
â”‚  â”‚  â”‚ UPDATE CONTEXT          â”‚  â”‚  â”‚  â”‚ ACCUMULATE TRANSCRIPT           â”‚  â”‚â”‚
â”‚  â”‚  â”‚                         â”‚  â”‚  â”‚  â”‚                                 â”‚  â”‚â”‚
â”‚  â”‚  â”‚ last_transcript +=      â”‚  â”‚  â”‚  â”‚ session_transcript +=           â”‚  â”‚â”‚
â”‚  â”‚  â”‚   new_text              â”‚  â”‚  â”‚  â”‚   new_text                      â”‚  â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚â”‚
â”‚  â”‚              â”‚                â”‚  â”‚                  â”‚                    â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                 â”‚                                      â”‚                     â”‚
â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                â”‚                                             â”‚
â”‚                                â–¼                                             â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         PHASE 5: OUTPUT                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   TAURI EVENT       â”‚                                                  â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚ app.emit(           â”‚                                                  â”‚
â”‚     â”‚   "transcription-   â”‚                                                  â”‚
â”‚     â”‚    chunk",          â”‚                                                  â”‚
â”‚     â”‚   TranscriptionChunkâ”‚                                                  â”‚
â”‚     â”‚ )                   â”‚                                                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                â”‚                                                             â”‚
â”‚                â”‚ JSON over IPC                                               â”‚
â”‚                â–¼                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   FRONTEND (React)  â”‚                                                  â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚ listen(             â”‚                                                  â”‚
â”‚     â”‚   "transcription-   â”‚                                                  â”‚
â”‚     â”‚    chunk",          â”‚                                                  â”‚
â”‚     â”‚   (event) => {      â”‚                                                  â”‚
â”‚     â”‚     updateUI(event) â”‚                                                  â”‚
â”‚     â”‚   }                 â”‚                                                  â”‚
â”‚     â”‚ )                   â”‚                                                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                â”‚                                                             â”‚
â”‚                â–¼                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                  â”‚
â”‚     â”‚   USER SEES TEXT    â”‚                                                  â”‚
â”‚     â”‚                     â”‚                                                  â”‚
â”‚     â”‚   "Hello, this is   â”‚                                                  â”‚
â”‚     â”‚    a test..."       â”‚                                                  â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                  â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Stop Recording Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    STOP RECORDING FLOW                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  User clicks STOP                                                            â”‚
â”‚        â”‚                                                                     â”‚
â”‚        â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                     â”‚
â”‚  â”‚ stop_recording()    â”‚                                                     â”‚
â”‚  â”‚ command called      â”‚                                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                     â”‚
â”‚             â”‚                                                                â”‚
â”‚             â–¼                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                     â”‚
â”‚  â”‚ DROP RecordingHandleâ”‚                                                     â”‚
â”‚  â”‚                     â”‚                                                     â”‚
â”‚  â”‚ â€¢ drop(stream)      â”‚ â† Stops microphone                                  â”‚
â”‚  â”‚ â€¢ drop(file_tx)     â”‚ â† Signals file writer to finish                     â”‚
â”‚  â”‚ â€¢ drop(whisper_tx)  â”‚ â† Signals transcriber to finish                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                     â”‚
â”‚             â”‚                                                                â”‚
â”‚             â”‚ Channels close, threads see Err on recv()                      â”‚
â”‚             â”‚                                                                â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                                                          â”‚
â”‚       â”‚           â”‚                                                          â”‚
â”‚       â–¼           â–¼                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ FILE    â”‚  â”‚ TRANSCRIBER FINISHES                                    â”‚    â”‚
â”‚  â”‚ WRITER  â”‚  â”‚                                                         â”‚    â”‚
â”‚  â”‚         â”‚  â”‚ â€¢ Processes remaining buffer                            â”‚    â”‚
â”‚  â”‚finalize()â”‚ â”‚ â€¢ Handles partial chunks                                â”‚    â”‚
â”‚  â”‚         â”‚  â”‚                                                         â”‚    â”‚
â”‚  â”‚ WAV     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”‚ saved   â”‚                                                                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                 â”‚
â”‚             â”‚                                                                â”‚
â”‚             â–¼                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    ENGINE-SPECIFIC FINAL PASS                           â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  IF PARAKEET:                     IF WHISPER:                           â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚ Return accumulated    â”‚        â”‚ HIGH-QUALITY FINAL PASS           â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ session_transcript    â”‚        â”‚                                   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚                       â”‚        â”‚ 1. Load saved WAV file            â”‚ â”‚ â”‚
â”‚  â”‚  â”‚ (Streaming was        â”‚        â”‚ 2. Run VAD to find speech         â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  sufficient)          â”‚        â”‚ 3. Extract only speech segments   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚                       â”‚        â”‚ 4. Transcribe cleaned audio       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚                       â”‚        â”‚ 5. Return final transcript        â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚                                   â”‚ â”‚ â”‚
â”‚  â”‚                                   â”‚ (Better quality than real-time)   â”‚ â”‚ â”‚
â”‚  â”‚                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚             â”‚                                                                â”‚
â”‚             â–¼                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                     â”‚
â”‚  â”‚ RETURN TRANSCRIPT   â”‚                                                     â”‚
â”‚  â”‚                     â”‚                                                     â”‚
â”‚  â”‚ Ok("Final cleaned   â”‚                                                     â”‚
â”‚  â”‚    transcript...")  â”‚                                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                     â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Audio Sample Format Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SAMPLE FORMAT TRANSFORMATIONS                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  MICROPHONE OUTPUT:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Format: f32 (32-bit float)                                             â”‚ â”‚
â”‚  â”‚  Range: -1.0 to +1.0                                                    â”‚ â”‚
â”‚  â”‚  Sample Rate: 48,000 Hz (typical)                                       â”‚ â”‚
â”‚  â”‚  Channels: 2 (stereo)                                                   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Data: [Lâ‚€, Râ‚€, Lâ‚, Râ‚, Lâ‚‚, Râ‚‚, ...]                                   â”‚ â”‚
â”‚  â”‚         â–²   â–²   â–²   â–²                                                   â”‚ â”‚
â”‚  â”‚         â”‚   â”‚   â”‚   â””â”€â”€ Right channel, sample 1                         â”‚ â”‚
â”‚  â”‚         â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€ Left channel, sample 1                          â”‚ â”‚
â”‚  â”‚         â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Right channel, sample 0                         â”‚ â”‚
â”‚  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Left channel, sample 0                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â–¼                                               â”‚
â”‚  STEREO â†’ MONO CONVERSION:                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Formula: mono[i] = (left[i] + right[i]) / 2.0                          â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Before: [Lâ‚€, Râ‚€, Lâ‚, Râ‚, Lâ‚‚, Râ‚‚]  (6 samples, stereo)                 â”‚ â”‚
â”‚  â”‚  After:  [Mâ‚€, Mâ‚, Mâ‚‚]              (3 samples, mono)                    â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Where: Mâ‚€ = (Lâ‚€ + Râ‚€) / 2                                              â”‚ â”‚
â”‚  â”‚         Mâ‚ = (Lâ‚ + Râ‚) / 2                                              â”‚ â”‚
â”‚  â”‚         Mâ‚‚ = (Lâ‚‚ + Râ‚‚) / 2                                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â–¼                                               â”‚
â”‚  RESAMPLING (48kHz â†’ 16kHz):                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Algorithm: Sinc Interpolation (high quality)                           â”‚ â”‚
â”‚  â”‚  Ratio: 16000 / 48000 = 0.333...                                        â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Before: [â–  â–  â–  â–  â–  â–  â–  â–  â–  â–  â–  â– ]  (48,000 samples/sec)               â”‚ â”‚
â”‚  â”‚           â”‚     â”‚     â”‚     â”‚                                           â”‚ â”‚
â”‚  â”‚           â–¼     â–¼     â–¼     â–¼                                           â”‚ â”‚
â”‚  â”‚  After:  [â–      â–      â–      â–     ]  (16,000 samples/sec)                â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Note: Not just dropping samples! Sinc filter preserves audio quality.  â”‚ â”‚
â”‚  â”‚        It's like resizing an image with anti-aliasing.                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â–¼                                               â”‚
â”‚  WHISPER/PARAKEET INPUT:                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Format: f32 (32-bit float)                                             â”‚ â”‚
â”‚  â”‚  Range: -1.0 to +1.0                                                    â”‚ â”‚
â”‚  â”‚  Sample Rate: 16,000 Hz (required!)                                     â”‚ â”‚
â”‚  â”‚  Channels: 1 (mono)                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  This is what the AI models were trained on.                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  NUMBERS:                                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  1 second of audio:                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Stage              Samples    Bytes (f32)    Bytes (i16)               â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚ â”‚
â”‚  â”‚  Mic (48kHz stereo)  96,000    384,000        192,000                   â”‚ â”‚
â”‚  â”‚  Mono (48kHz)        48,000    192,000         96,000                   â”‚ â”‚
â”‚  â”‚  Resampled (16kHz)   16,000     64,000         32,000                   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  6 second chunk (what we process):                                      â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚ â”‚
â”‚  â”‚  Mic (48kHz stereo) 576,000  2,304,000 bytes (~2.2 MB)                  â”‚ â”‚
â”‚  â”‚  Final (16kHz mono)  96,000    384,000 bytes (~375 KB)                  â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### VAD (Voice Activity Detection) Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VAD DECISION FLOW                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  INPUT: 6 seconds of audio (96,000 samples at 16kHz)                         â”‚
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  STEP 1: Calculate Energy (RMS)                                         â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  RMS = âˆš(Î£(sampleÂ²) / n)                                                â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Example:                                                               â”‚ â”‚
â”‚  â”‚  samples = [0.1, -0.2, 0.15, -0.1]                                      â”‚ â”‚
â”‚  â”‚  squares = [0.01, 0.04, 0.0225, 0.01]                                   â”‚ â”‚
â”‚  â”‚  mean = 0.0825 / 4 = 0.020625                                           â”‚ â”‚
â”‚  â”‚  RMS = âˆš0.020625 = 0.1436                                               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  STEP 2: Compare to Threshold                                           â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  threshold = 0.005                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚                                                                   â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  0.000    0.005    0.010    0.015    0.020    0.025    0.030      â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚        â”‚        â”‚        â”‚        â”‚        â”‚        â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚        â”‚                                   â”‚        â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚ SILENCEâ”‚         TRANSITION ZONE           â”‚ SPEECH â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚        â”‚                                   â”‚        â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚ prob=0 â”‚  prob = (rms - 0.005) / 0.020    â”‚ prob=1 â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚    â”‚        â”‚                                   â”‚        â”‚        â”‚  â”‚ â”‚
â”‚  â”‚  â”‚            threshold                    5x threshold              â”‚  â”‚ â”‚
â”‚  â”‚  â”‚            (0.005)                        (0.025)                 â”‚  â”‚ â”‚
â”‚  â”‚  â”‚                                                                   â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â–¼                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  STEP 3: Make Decision                                                  â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  if probability > 0.5:                                                  â”‚ â”‚
â”‚  â”‚      â†’ PROCESS with Whisper AI (expensive)                              â”‚ â”‚
â”‚  â”‚  else:                                                                  â”‚ â”‚
â”‚  â”‚      â†’ SKIP this chunk (save GPU cycles)                                â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  TYPICAL RECORDING:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Time:    0s    6s    12s   18s   24s   30s   36s   42s   48s   54s    â”‚ â”‚
â”‚  â”‚           â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚      â”‚ â”‚
â”‚  â”‚  Audio:   â–‘â–‘â–‘â–‘â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘â–‘â–‘â–‘ â–‘â–‘â–‘â–‘â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘â–‘â–‘â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘â–‘â–‘â–‘  â”‚ â”‚
â”‚  â”‚           â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚      â”‚ â”‚
â”‚  â”‚  VAD:     SKIP  PROC  PROC  SKIP  SKIP  PROC  SKIP  PROC  PROC  SKIP   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Result: Only 5 out of 10 chunks processed!                             â”‚ â”‚
â”‚  â”‚          50% GPU savings!                                               â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  â–‘â–‘â–‘â–‘â–‘ = Silence (background noise, pauses)                             â”‚ â”‚
â”‚  â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ = Speech (actual talking)                                        â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¡ Tauri Command API Reference

Every command exposed to the frontend, with types and examples.

---

### Recording Commands

#### `start_recording`

| Property | Value |
|----------|-------|
| **File** | `commands/recording.rs` |
| **Purpose** | Initialize microphone and begin recording |
| **Frontend Call** | `await invoke("start_recording")` |

**Signature:**
```rust
#[tauri::command]
pub fn start_recording(
    app_handle: AppHandle,  // Injected by Tauri
    state: State<AudioState>,  // Injected by Tauri
) -> Result<String, String>
```

**Returns:**
- `Ok("Recording started: /path/to/recording_1234567890.wav")`
- `Err("No input device")` - No microphone found
- `Err("Failed to create stream: ...")` - Audio system error

**Frontend Example:**
```typescript
import { invoke } from "@tauri-apps/api/core";

async function startRecording() {
    try {
        const result = await invoke<string>("start_recording");
        console.log(result);  // "Recording started: ..."
    } catch (error) {
        console.error("Failed to start:", error);
    }
}
```

---

#### `stop_recording`

| Property | Value |
|----------|-------|
| **File** | `commands/recording.rs` |
| **Purpose** | Stop recording and get final transcript |
| **Frontend Call** | `await invoke("stop_recording")` |

**Signature:**
```rust
#[tauri::command]
pub fn stop_recording(
    state: State<AudioState>,
) -> Result<String, String>
```

**Returns:**
- `Ok("Final transcript text here...")` - Success with transcript
- `Ok("[silence]")` - Recording contained no speech
- `Ok("Recording saved.")` - Saved but no transcript (error during processing)
- `Err("Not recording")` - Wasn't recording

**Frontend Example:**
```typescript
async function stopRecording() {
    try {
        const transcript = await invoke<string>("stop_recording");
        console.log("Transcript:", transcript);
    } catch (error) {
        console.error("Not recording:", error);
    }
}
```

---

### Model Commands

#### `list_models`

| Property | Value |
|----------|-------|
| **File** | `commands/models.rs` |
| **Purpose** | Get available Whisper models |
| **Frontend Call** | `await invoke("list_models")` |

**Signature:**
```rust
#[tauri::command]
pub fn list_models() -> Result<Vec<ModelInfo>, String>
```

**Returns:**
```typescript
// Success:
[
    {
        id: "tiny.en-q5_1",
        display_name: "Tiny English (Q5_1)",
        file_name: "ggml-tiny.en-q5_1.bin",
        size_mb: 42.3
    },
    {
        id: "base.en-q5_1",
        display_name: "Base English (Q5_1)",
        file_name: "ggml-base.en-q5_1.bin",
        size_mb: 78.5
    }
    // ...
]

// Error:
"Could not find models directory containing ggml models"
```

**Frontend Example:**
```typescript
interface ModelInfo {
    id: string;
    display_name: string;
    file_name: string;
    size_mb: number;
}

async function getModels() {
    const models = await invoke<ModelInfo[]>("list_models");
    models.forEach(m => console.log(`${m.display_name} (${m.size_mb}MB)`));
}
```

---

#### `switch_model`

| Property | Value |
|----------|-------|
| **File** | `commands/models.rs` |
| **Purpose** | Change the active Whisper model |
| **Frontend Call** | `await invoke("switch_model", { modelId: "..." })` |

**Signature:**
```rust
#[tauri::command]
pub fn switch_model(
    state: State<AudioState>,
    model_id: String,
) -> Result<String, String>
```

**Returns:**
- `Ok("Backend: CUDA")` - Model loaded with GPU
- `Ok("Backend: CPU")` - Model loaded with CPU fallback
- `Err("Cannot switch models while recording")` - Stop recording first
- `Err("Model file not found: ...")` - Model doesn't exist

**Frontend Example:**
```typescript
async function switchToLargeModel() {
    try {
        const backend = await invoke<string>("switch_model", {
            modelId: "large-v3-turbo-q5_1"
        });
        console.log("Loaded with:", backend);
    } catch (error) {
        console.error("Switch failed:", error);
    }
}
```

---

#### `list_parakeet_models`

| Property | Value |
|----------|-------|
| **File** | `commands/models.rs` |
| **Purpose** | Get available Parakeet/Nemotron models |
| **Frontend Call** | `await invoke("list_parakeet_models")` |

**Returns:**
```typescript
[
    {
        id: "nemotron:parakeet-tdt-0.6b-v2",
        display_name: "Parakeet TDT - parakeet-tdt-0.6b-v2",
        model_type: "TDT",
        size_mb: 245.7
    }
    // ...
]
```

---

#### `init_parakeet`

| Property | Value |
|----------|-------|
| **File** | `commands/models.rs` |
| **Purpose** | Initialize a Parakeet model |
| **Frontend Call** | `await invoke("init_parakeet", { modelId?: "..." })` |

**Signature:**
```rust
#[tauri::command]
pub fn init_parakeet(
    state: State<AudioState>,
    model_id: Option<String>,  // Optional - defaults to first available
) -> Result<String, String>
```

**Returns:**
- `Ok("Loaded Parakeet TDT - ... (CUDA)")` - Success
- `Err("No Parakeet/Nemotron models found.")` - No models installed

---

#### `get_parakeet_status`

| Property | Value |
|----------|-------|
| **File** | `commands/models.rs` |
| **Purpose** | Check Parakeet engine status |
| **Frontend Call** | `await invoke("get_parakeet_status")` |

**Returns:**
```typescript
{
    loaded: true,
    model_id: "tdt:parakeet-tdt-0.6b-v2",
    model_type: "TDT",
    backend: "CUDA"
}
```

---

### Settings Commands

#### `get_backend_info`

| Property | Value |
|----------|-------|
| **File** | `commands/settings.rs` |
| **Purpose** | Get current Whisper GPU backend |
| **Frontend Call** | `await invoke("get_backend_info")` |

**Returns:** `"CUDA"`, `"Vulkan"`, or `"CPU"`

---

#### `set_active_engine`

| Property | Value |
|----------|-------|
| **File** | `commands/settings.rs` |
| **Purpose** | Switch between Whisper and Parakeet |
| **Frontend Call** | `await invoke("set_active_engine", { engine: "whisper" })` |

**Parameters:**
- `engine: "whisper"` - Use Whisper AI
- `engine: "parakeet"` - Use Parakeet ASR

**Returns:**
- `Ok("Engine switched to Whisper")`
- `Ok("Engine switched to Parakeet")`
- `Err("Unknown engine: xyz")`

---

#### `get_active_engine`

| Property | Value |
|----------|-------|
| **File** | `commands/settings.rs` |
| **Purpose** | Get currently active ASR engine |
| **Frontend Call** | `await invoke("get_active_engine")` |

**Returns:** `"Whisper"` or `"Parakeet"`

---

#### `set_tray_state`

| Property | Value |
|----------|-------|
| **File** | `commands/settings.rs` |
| **Purpose** | Update system tray icon |
| **Frontend Call** | `await invoke("set_tray_state", { newState: "recording" })` |

**Parameters:**
- `newState: "ready"` - Green icon
- `newState: "recording"` - Red icon
- `newState: "processing"` - Yellow icon

---

### LLM Commands

#### `init_llm`

| Property | Value |
|----------|-------|
| **File** | `commands/llm.rs` |
| **Purpose** | Load Gemma grammar correction model |
| **Frontend Call** | `await invoke("init_llm")` |

**Returns:**
- `Ok("Gemma LLM initialized successfully")`
- `Ok("LLM already initialized")`
- `Err("Failed to load LLM: ...")` - Model file not found or GPU error

---

#### `correct_text`

| Property | Value |
|----------|-------|
| **File** | `commands/llm.rs` |
| **Purpose** | Fix grammar in transcribed text |
| **Frontend Call** | `await invoke("correct_text", { text: "..." })` |

**Signature:**
```rust
#[tauri::command]
pub async fn correct_text(
    state: State<'_, AudioState>,
    text: String,
) -> Result<String, String>
```

**Example:**
```typescript
const corrected = await invoke<string>("correct_text", {
    text: "i went too the store and buyed some milk"
});
// Returns: "I went to the store and bought some milk."
```

---

#### `check_llm_status`

| Property | Value |
|----------|-------|
| **File** | `commands/llm.rs` |
| **Purpose** | Check if LLM is loaded |
| **Frontend Call** | `await invoke("check_llm_status")` |

**Returns:** `true` or `false`

---

### Transcription Commands

#### `list_sample_files`

| Property | Value |
|----------|-------|
| **File** | `commands/transcription.rs` |
| **Purpose** | Get available test audio files |
| **Frontend Call** | `await invoke("list_sample_files")` |

**Returns:**
```typescript
[
    { name: "test_audio_1.wav", path: "/full/path/to/test_audio_1.wav" },
    { name: "test_audio_2.wav", path: "/full/path/to/test_audio_2.wav" }
]
```

---

#### `benchmark_test`

| Property | Value |
|----------|-------|
| **File** | `commands/transcription.rs` |
| **Purpose** | Compare Whisper vs Parakeet performance |
| **Frontend Call** | `await invoke("benchmark_test", { filePath: "..." })` |

**Returns:** Formatted benchmark report string

---

### Events (Backend â†’ Frontend)

#### `transcription-chunk`

| Property | Value |
|----------|-------|
| **Emitted By** | Recording thread |
| **Purpose** | Send real-time transcription to UI |

**Payload:**
```typescript
interface TranscriptionChunk {
    text: string;           // The transcribed text
    processing_time_ms: number;  // How long it took
    method: string;         // "Whisper" or "Parakeet"
}
```

**Frontend Listener:**
```typescript
import { listen } from "@tauri-apps/api/event";

await listen<TranscriptionChunk>("transcription-chunk", (event) => {
    console.log("New text:", event.payload.text);
    console.log("Took:", event.payload.processing_time_ms, "ms");
});
```

---

#### `hotkey-start-recording` / `hotkey-stop-recording`

| Property | Value |
|----------|-------|
| **Emitted By** | Hotkey listener thread |
| **Purpose** | Notify frontend of global hotkey press |

**Frontend Listener:**
```typescript
await listen("hotkey-start-recording", () => {
    console.log("User pressed Ctrl+Win, starting...");
    invoke("start_recording");
});

await listen("hotkey-stop-recording", () => {
    console.log("User released Ctrl+Win, stopping...");
    invoke("stop_recording");
});
```

---

## ğŸŒ‰ Frontend-Backend Bridge

How Tauri connects React (frontend) to Rust (backend).

---

### The Big Picture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAURI ARCHITECTURE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                         FRONTEND                                     â”‚   â”‚
â”‚   â”‚                   (React + TypeScript)                               â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚   â”‚
â”‚   â”‚   â”‚   App.tsx   â”‚    â”‚ Components  â”‚    â”‚   Hooks     â”‚             â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜             â”‚   â”‚
â”‚   â”‚          â”‚                  â”‚                  â”‚                     â”‚   â”‚
â”‚   â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚   â”‚
â”‚   â”‚                             â”‚                                        â”‚   â”‚
â”‚   â”‚                             â–¼                                        â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚   â”‚              @tauri-apps/api                                â”‚   â”‚   â”‚
â”‚   â”‚   â”‚                                                             â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   invoke()     listen()     emit()     window.*             â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                                â”‚                                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                         â”‚
â”‚                                    â”‚  IPC (Inter-Process Communication)      â”‚
â”‚                                    â”‚  JSON serialization                     â”‚
â”‚                                    â”‚                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                â–¼                                     â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚   â”‚              TAURI RUNTIME                                  â”‚   â”‚   â”‚
â”‚   â”‚   â”‚                                                             â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   Command Router    Event System    State Manager           â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                                â”‚                                     â”‚   â”‚
â”‚   â”‚                                â”‚                                     â”‚   â”‚
â”‚   â”‚                                â–¼                                     â”‚   â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚   â”‚              YOUR RUST CODE                                 â”‚   â”‚   â”‚
â”‚   â”‚   â”‚                                                             â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   #[tauri::command]     State<T>     AppHandle              â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   fn start_recording()  .lock()      .emit()                â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                                                                      â”‚   â”‚
â”‚   â”‚                         BACKEND                                      â”‚   â”‚
â”‚   â”‚                        (Rust)                                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### How `invoke()` Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INVOKE() DEEP DIVE                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  FRONTEND (TypeScript):                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  const result = await invoke("switch_model", { modelId: "tiny.en" });   â”‚ â”‚
â”‚  â”‚                        â–²              â–²                                 â”‚ â”‚
â”‚  â”‚                        â”‚              â”‚                                 â”‚ â”‚
â”‚  â”‚                   Command name    Arguments object                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 1: SERIALIZE TO JSON                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  {                                                                      â”‚ â”‚
â”‚  â”‚    "cmd": "switch_model",                                               â”‚ â”‚
â”‚  â”‚    "args": {                                                            â”‚ â”‚
â”‚  â”‚      "modelId": "tiny.en"                                               â”‚ â”‚
â”‚  â”‚    }                                                                    â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  Send via IPC                              â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 2: TAURI ROUTES TO HANDLER                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // In lib.rs:                                                          â”‚ â”‚
â”‚  â”‚  .invoke_handler(tauri::generate_handler![                              â”‚ â”‚
â”‚  â”‚      commands::recording::start_recording,                              â”‚ â”‚
â”‚  â”‚      commands::recording::stop_recording,                               â”‚ â”‚
â”‚  â”‚      commands::models::switch_model,  // â† Matches "switch_model"       â”‚ â”‚
â”‚  â”‚      // ...                                                             â”‚ â”‚
â”‚  â”‚  ])                                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 3: DESERIALIZE ARGUMENTS                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  #[tauri::command]                                                      â”‚ â”‚
â”‚  â”‚  pub fn switch_model(                                                   â”‚ â”‚
â”‚  â”‚      state: State<AudioState>,  // Injected by Tauri                    â”‚ â”‚
â”‚  â”‚      model_id: String,          // â† Deserialized from "modelId"        â”‚ â”‚
â”‚  â”‚  ) -> Result<String, String>                                            â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Note: camelCase in JS â†’ snake_case in Rust (automatic!)                â”‚ â”‚
â”‚  â”‚        "modelId" â†’ model_id                                             â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 4: EXECUTE RUST CODE                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Your actual logic runs here                                         â”‚ â”‚
â”‚  â”‚  let mut whisper = state.whisper.lock().unwrap();                       â”‚ â”‚
â”‚  â”‚  whisper.initialize(Some(&model_id))?;                                  â”‚ â”‚
â”‚  â”‚  Ok(format!("Backend: {}", whisper.get_backend()))                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 5: SERIALIZE RESULT                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Ok("Backend: CUDA")  â†’  { "Ok": "Backend: CUDA" }                      â”‚ â”‚
â”‚  â”‚  Err("Not found")     â†’  { "Err": "Not found" }                         â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  Send via IPC                              â”‚
â”‚                                 â–¼                                            â”‚
â”‚  STEP 6: PROMISE RESOLVES/REJECTS                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Back in TypeScript:                                                 â”‚ â”‚
â”‚  â”‚  const result = await invoke("switch_model", { modelId: "tiny.en" });   â”‚ â”‚
â”‚  â”‚  // result = "Backend: CUDA"                                            â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // If Err was returned:                                                â”‚ â”‚
â”‚  â”‚  // Promise rejects, caught by try/catch                                â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### How Events Work (Backend â†’ Frontend)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EVENT SYSTEM                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  BACKEND EMITS EVENT:                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // In recording.rs:                                                    â”‚ â”‚
â”‚  â”‚  app_handle.emit(                                                       â”‚ â”‚
â”‚  â”‚      "transcription-chunk",     // Event name                           â”‚ â”‚
â”‚  â”‚      TranscriptionChunk {       // Payload (must be Serialize)          â”‚ â”‚
â”‚  â”‚          text: "Hello world".to_string(),                               â”‚ â”‚
â”‚  â”‚          processing_time_ms: 150,                                       â”‚ â”‚
â”‚  â”‚          method: "Whisper".to_string(),                                 â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  );                                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  Serialized to JSON                        â”‚
â”‚                                 â”‚  Sent via IPC                              â”‚
â”‚                                 â–¼                                            â”‚
â”‚  FRONTEND RECEIVES EVENT:                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  import { listen } from "@tauri-apps/api/event";                        â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Set up listener (usually in useEffect):                             â”‚ â”‚
â”‚  â”‚  const unlisten = await listen<TranscriptionChunk>(                     â”‚ â”‚
â”‚  â”‚      "transcription-chunk",                                             â”‚ â”‚
â”‚  â”‚      (event) => {                                                       â”‚ â”‚
â”‚  â”‚          console.log("Received:", event.payload);                       â”‚ â”‚
â”‚  â”‚          // event.payload = {                                           â”‚ â”‚
â”‚  â”‚          //     text: "Hello world",                                    â”‚ â”‚
â”‚  â”‚          //     processing_time_ms: 150,                                â”‚ â”‚
â”‚  â”‚          //     method: "Whisper"                                       â”‚ â”‚
â”‚  â”‚          // }                                                           â”‚ â”‚
â”‚  â”‚          setTranscript(prev => prev + " " + event.payload.text);        â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  );                                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Clean up when component unmounts:                                   â”‚ â”‚
â”‚  â”‚  return () => { unlisten(); };                                          â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  INVOKE vs EMIT:                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  INVOKE (Request/Response):                                             â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚ â”‚
â”‚  â”‚  â”‚   Frontend   â”‚ â”€â”€â”€â”€â”€â”€â–º â”‚   Backend    â”‚                              â”‚ â”‚
â”‚  â”‚  â”‚              â”‚ â—„â”€â”€â”€â”€â”€â”€ â”‚              â”‚                              â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚ â”‚
â”‚  â”‚   "I need data"           "Here's the data"                             â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  EMIT (Push/Subscribe):                                                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚ â”‚
â”‚  â”‚  â”‚   Frontend   â”‚ â—„â”€â”€â”€â”€â”€â”€ â”‚   Backend    â”‚                              â”‚ â”‚
â”‚  â”‚  â”‚  (listener)  â”‚         â”‚  (emitter)   â”‚                              â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚ â”‚
â”‚  â”‚   "Tell me when          "Something happened!"                          â”‚ â”‚
â”‚  â”‚    something happens"                                                   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Use INVOKE for: User actions, fetching data, one-time operations       â”‚ â”‚
â”‚  â”‚  Use EMIT for: Real-time updates, progress, streaming data              â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### State Management

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TAURI STATE MANAGEMENT                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  SETUP (in lib.rs):                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Create the shared state                                             â”‚ â”‚
â”‚  â”‚  let audio_state = AudioState::new();                                   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  tauri::Builder::default()                                              â”‚ â”‚
â”‚  â”‚      .manage(audio_state)  // â† Register state with Tauri               â”‚ â”‚
â”‚  â”‚      .invoke_handler(...)                                               â”‚ â”‚
â”‚  â”‚      .run(...)                                                          â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  ACCESS IN COMMANDS:                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  #[tauri::command]                                                      â”‚ â”‚
â”‚  â”‚  pub fn start_recording(                                                â”‚ â”‚
â”‚  â”‚      state: State<AudioState>,  // Tauri injects this automatically!    â”‚ â”‚
â”‚  â”‚  ) -> Result<String, String> {                                          â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      // Access inner fields (need to lock the Mutex):                   â”‚ â”‚
â”‚  â”‚      let mut whisper = state.whisper.lock().unwrap();                   â”‚ â”‚
â”‚  â”‚      whisper.clear_context();                                           â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      // Or just read:                                                   â”‚ â”‚
â”‚  â”‚      let engine = *state.active_engine.lock().unwrap();                 â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      Ok("Started".to_string())                                          â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  WHY THIS PATTERN?                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Problem: Multiple commands need access to the same data                â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  âŒ Global variables:                                                   â”‚ â”‚
â”‚  â”‚     static mut WHISPER: WhisperManager = ...;  // Unsafe!               â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  âŒ Pass through invoke:                                                â”‚ â”‚
â”‚  â”‚     Can't send WhisperManager from frontend!                            â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  âœ… Tauri State:                                                        â”‚ â”‚
â”‚  â”‚     - Lives for lifetime of app                                         â”‚ â”‚
â”‚  â”‚     - Automatically injected into commands                              â”‚ â”‚
â”‚  â”‚     - Thread-safe via Arc<Mutex<T>>                                     â”‚ â”‚
â”‚  â”‚     - Type-safe access                                                  â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  STATE STRUCTURE:                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  AudioState {                                                           â”‚ â”‚
â”‚  â”‚      whisper: Arc<Mutex<WhisperManager>>                                â”‚ â”‚
â”‚  â”‚               â”œâ”€â”€ context: Option<WhisperContext>                       â”‚ â”‚
â”‚  â”‚               â”œâ”€â”€ last_transcript: String                               â”‚ â”‚
â”‚  â”‚               â””â”€â”€ ...                                                   â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      parakeet: Arc<Mutex<ParakeetManager>>                              â”‚ â”‚
â”‚  â”‚               â””â”€â”€ model: Option<LoadedModel>                            â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      vad: Arc<Mutex<VADManager>>                                        â”‚ â”‚
â”‚  â”‚               â””â”€â”€ threshold: f32                                        â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      recording_handle: Arc<Mutex<Option<RecordingHandle>>>              â”‚ â”‚
â”‚  â”‚               â””â”€â”€ None when not recording, Some(...) when recording     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      active_engine: Arc<Mutex<ASREngine>>                               â”‚ â”‚
â”‚  â”‚               â””â”€â”€ Whisper or Parakeet                                   â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Serialization Rules

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SERIALIZATION (Rust â†” JavaScript)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  RUST TYPE                    JSON                      TYPESCRIPT           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                              â”‚
â”‚  String                       "hello"                   string               â”‚
â”‚  &str                         "hello"                   string               â”‚
â”‚  i32, u32, i64, u64          123                       number               â”‚
â”‚  f32, f64                     3.14                      number               â”‚
â”‚  bool                         true/false                boolean              â”‚
â”‚  ()                           null                      null                 â”‚
â”‚  Option<T>::Some(v)          v                         T | null             â”‚
â”‚  Option<T>::None             null                      T | null             â”‚
â”‚  Vec<T>                       [...]                     T[]                  â”‚
â”‚  HashMap<K,V>                {...}                     Record<K, V>         â”‚
â”‚  Result<T,E>::Ok(v)          v                         T (success)          â”‚
â”‚  Result<T,E>::Err(e)         throws                    catch (e)            â”‚
â”‚                                                                              â”‚
â”‚  NAMING CONVERSION:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Rust (snake_case)         JavaScript (camelCase)                       â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚ â”‚
â”‚  â”‚  model_id                  modelId                                      â”‚ â”‚
â”‚  â”‚  processing_time_ms        processingTimeMs                             â”‚ â”‚
â”‚  â”‚  file_name                 fileName                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  This happens automatically with serde + Tauri!                         â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  STRUCT EXAMPLE:                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Rust:                                                               â”‚ â”‚
â”‚  â”‚  #[derive(serde::Serialize)]                                            â”‚ â”‚
â”‚  â”‚  pub struct TranscriptionChunk {                                        â”‚ â”‚
â”‚  â”‚      pub text: String,                                                  â”‚ â”‚
â”‚  â”‚      pub processing_time_ms: u32,                                       â”‚ â”‚
â”‚  â”‚      pub method: String,                                                â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // JSON:                                                               â”‚ â”‚
â”‚  â”‚  {                                                                      â”‚ â”‚
â”‚  â”‚      "text": "Hello world",                                             â”‚ â”‚
â”‚  â”‚      "processingTimeMs": 150,                                           â”‚ â”‚
â”‚  â”‚      "method": "Whisper"                                                â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // TypeScript:                                                         â”‚ â”‚
â”‚  â”‚  interface TranscriptionChunk {                                         â”‚ â”‚
â”‚  â”‚      text: string;                                                      â”‚ â”‚
â”‚  â”‚      processingTimeMs: number;                                          â”‚ â”‚
â”‚  â”‚      method: string;                                                    â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  ENUM EXAMPLE:                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Rust:                                                               â”‚ â”‚
â”‚  â”‚  #[derive(serde::Serialize)]                                            â”‚ â”‚
â”‚  â”‚  pub enum ASREngine {                                                   â”‚ â”‚
â”‚  â”‚      Whisper,                                                           â”‚ â”‚
â”‚  â”‚      Parakeet,                                                          â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // JSON:                                                               â”‚ â”‚
â”‚  â”‚  "Whisper"  or  "Parakeet"                                              â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // TypeScript:                                                         â”‚ â”‚
â”‚  â”‚  type ASREngine = "Whisper" | "Parakeet";                               â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“– Glossary

Technical terms used in this codebase, explained.

---

### A

**ADC (Analog-to-Digital Converter)**
Hardware that converts analog sound waves from a microphone into digital numbers (samples). Your sound card does this.

**Arc (Atomic Reference Counting)**
A Rust smart pointer that allows multiple owners of the same data across threads. The "Atomic" means it's thread-safe. See: `Arc<Mutex<WhisperManager>>`

**ASR (Automatic Speech Recognition)**
The technology of converting spoken audio into text. Whisper and Parakeet are both ASR systems.

---

### B

**Backend**
In this app: The Rust code that handles AI processing. In Whisper context: The hardware running inference (CUDA/Vulkan/CPU).

**Borrow**
Rust's way of temporarily using data without taking ownership. `&T` is an immutable borrow, `&mut T` is a mutable borrow.

---

### C

**Channel**
A communication pipe between threads. One end sends data (`tx`), the other receives (`rx`). Like a conveyor belt.

**Closure**
An anonymous function that can capture variables from its environment. Syntax: `|args| body`

**Context (Whisper)**
The "memory" of previous transcriptions. Helps Whisper understand ambiguous words by knowing what came before.

**cpal**
Cross-Platform Audio Library. The Rust crate that handles microphone input across Windows/Mac/Linux.

**CTC (Connectionist Temporal Classification)**
A type of neural network architecture for sequence-to-sequence tasks like speech recognition. Used by Parakeet CTC models.

**CUDA**
NVIDIA's GPU computing platform. Allows running AI models on NVIDIA graphics cards for massive speedup.

---

### D

**Derive**
Rust macro that auto-implements traits. `#[derive(Debug, Clone)]` gives your type `debug` formatting and `.clone()`.

**DirectML**
Microsoft's machine learning API for Windows. Allows running AI on AMD/Intel/Qualcomm GPUs on Windows.

---

### E

**Enum**
A type that can be one of several variants. Like `GpuBackend::Cuda | GpuBackend::Vulkan | GpuBackend::Cpu`.

---

### F

**f32 / f64**
32-bit and 64-bit floating point numbers. Audio samples are typically f32 (range -1.0 to 1.0).

**Frontend**
The user interface part of the app. In Taurscribe: React + TypeScript running in a webview.

---

### G

**GGML / GGUF**
File formats for quantized AI models created by Georgi Gerganov. GGUF is the newer format. Whisper models use these.

**GPU (Graphics Processing Unit)**
The graphics card. Can run AI models 10-50x faster than CPU because of parallel processing.

**Greedy Decoding**
A simple AI text generation strategy: always pick the most likely next word. Fast but not always optimal.

---

### H

**Hz (Hertz)**
Samples per second. Human speech needs at least 8000 Hz to be understandable. Whisper uses 16000 Hz.

**hound**
Rust crate for reading and writing WAV audio files.

---

### I

**Inference**
Running a trained AI model on new data. "Running inference" = using the model to transcribe audio.

**invoke()**
Tauri's function for calling Rust code from JavaScript. Returns a Promise.

**IPC (Inter-Process Communication)**
How the frontend (webview) and backend (Rust) talk to each other in Tauri.

---

### L

**Lifetime**
Rust's way of tracking how long references are valid. Written as `'a`. The compiler uses these to prevent dangling references.

**LLM (Large Language Model)**
AI models trained on text that can generate or modify text. Gemma is the LLM used for grammar correction.

---

### M

**Mono**
Single-channel audio. Speech recognition requires mono (not stereo).

**Mutex (Mutual Exclusion)**
A lock that ensures only one thread can access data at a time. Prevents data races.

---

### N

**Nemotron**
NVIDIA's streaming ASR model. Can transcribe in real-time as audio comes in, unlike batch models.

**Nyquist Theorem**
To capture a frequency, you need at least 2x the sample rate. Human speech is ~4000 Hz, so 8000+ Hz is needed. 16000 Hz gives headroom.

---

### O

**ONNX (Open Neural Network Exchange)**
A standard format for AI models. Parakeet uses ONNX models.

**Option<T>**
Rust's way of representing "maybe a value, maybe nothing". `Some(value)` or `None`.

**Ownership**
Rust's core concept: every value has exactly one owner. When the owner goes out of scope, the value is dropped.

---

### P

**Parakeet**
NVIDIA's ASR engine. Includes several model types: Nemotron (streaming), CTC (batch), TDT (batch).

---

### Q

**Quantization**
Compressing AI models by reducing number precision. Q5_1 means 5-bit quantization. Smaller but slightly less accurate.

---

### R

**Resampling**
Converting audio from one sample rate to another. 48000 Hz â†’ 16000 Hz. Uses interpolation to maintain quality.

**Result<T, E>**
Rust's way of representing "either success or failure". `Ok(value)` or `Err(error)`.

**RMS (Root Mean Square)**
A way to measure audio loudness. Square all samples, average them, take square root.

**rubato**
Rust crate for high-quality audio resampling using sinc interpolation.

---

### S

**Sample**
A single measurement of audio amplitude at a point in time. Audio is a stream of samples.

**Sample Rate**
How many samples per second. 48000 Hz means 48,000 samples every second.

**serde**
Rust crate for **ser**ializing and **de**serializing data. Converts Rust structs to/from JSON.

**Sinc Interpolation**
A high-quality resampling algorithm that uses the sinc function. Better than simple linear interpolation.

**Spawn**
Creating a new thread. `std::thread::spawn(|| { ... })`.

**State (Tauri)**
Shared data that persists across command calls. Registered with `.manage()` and accessed via `State<T>`.

**Stereo**
Two-channel audio (left and right). Must be converted to mono for speech recognition.

---

### T

**Tauri**
Framework for building desktop apps with web frontend (HTML/JS/CSS) and Rust backend.

**TDT (Token-and-Duration Transducer)**
A Parakeet model architecture that predicts both tokens and their durations.

**Thread**
An independent execution path in a program. Multiple threads can run code simultaneously.

**Trait**
Rust's version of interfaces. Defines behavior that types can implement. `Debug`, `Clone`, `Send` are traits.

**Transcript**
The text output of speech recognition.

**tx / rx**
Transmitter and Receiver ends of a channel. `tx.send()` puts data in, `rx.recv()` takes data out.

---

### U

**unsafe**
Rust keyword that disables some safety checks. Required for certain operations like FFI or raw pointers.

**unwrap()**
Extract the value from `Option` or `Result`. Panics if `None` or `Err`. Use carefully!

---

### V

**VAD (Voice Activity Detection)**
Detecting whether audio contains speech or silence. Used to skip processing silent chunks.

**Vec<T>**
Rust's growable array type. `Vec<f32>` is a vector of floating-point numbers.

**Vulkan**
Cross-platform GPU API. Works with AMD, Intel, and some NVIDIA GPUs. Used when CUDA isn't available.

---

### W

**WAV**
Uncompressed audio file format. Stores raw samples. Easy to read/write but large files.

**Whisper**
OpenAI's speech recognition model. Very accurate, supports many languages.

**whisper_rs**
Rust bindings for whisper.cpp, which runs Whisper models efficiently.

---

### Quick Reference Table

| Abbreviation | Full Name | What It Does |
|--------------|-----------|--------------|
| ASR | Automatic Speech Recognition | Speech â†’ Text |
| VAD | Voice Activity Detection | Detect speech vs silence |
| CUDA | Compute Unified Device Architecture | NVIDIA GPU computing |
| ONNX | Open Neural Network Exchange | AI model format |
| GGUF | GPT-Generated Unified Format | Quantized model format |
| RMS | Root Mean Square | Audio loudness measure |
| IPC | Inter-Process Communication | Frontend â†” Backend |
| LLM | Large Language Model | Text AI (Gemma) |
| CTC | Connectionist Temporal Classification | ASR architecture |
| TDT | Token-and-Duration Transducer | ASR architecture |
| Hz | Hertz | Samples per second |
| kHz | Kilohertz | Thousands of samples/sec |

---

## ğŸ¨ Frontend Documentation (React + TypeScript)

Complete documentation of how the frontend makes calls to the Rust backend.

---

### Frontend File Structure

```
src/
â”œâ”€â”€ main.tsx          # React entry point (10 lines)
â”œâ”€â”€ App.tsx           # Main application component (667 lines)
â”œâ”€â”€ App.css           # Styling (674 lines)
â”œâ”€â”€ vite-env.d.ts     # Vite type declarations
â””â”€â”€ assets/
    â””â”€â”€ react.svg     # React logo
```

---

### `main.tsx` - Entry Point

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

**What it does:**
1. Imports React and ReactDOM
2. Finds the `#root` element in `index.html`
3. Renders the `<App />` component inside it
4. `StrictMode` enables additional development checks

---

### `App.tsx` - Main Component

#### TypeScript Interfaces (Lines 8-40)

These interfaces match the Rust structs exactly:

```typescript
// Matches whisper::ModelInfo in Rust
interface ModelInfo {
  id: string;              // e.g., "tiny.en-q5_1"
  display_name: string;    // e.g., "Tiny English (Q5_1)"
  file_name: string;       // e.g., "ggml-tiny.en-q5_1.bin"
  size_mb: number;         // e.g., 42.3
}

// Matches types::SampleFile in Rust
interface SampleFile {
  name: string;            // e.g., "test_audio.wav"
  path: string;            // e.g., "/full/path/to/test_audio.wav"
}

// Matches parakeet::ParakeetModelInfo in Rust
interface ParakeetModelInfo {
  id: string;              // e.g., "tdt:parakeet-tdt-0.6b-v2"
  display_name: string;    // e.g., "Parakeet TDT - parakeet-tdt-0.6b-v2"
  model_type: string;      // e.g., "TDT", "CTC", "Nemotron"
  size_mb: number;
}

// Matches parakeet::ParakeetStatus in Rust
interface ParakeetStatus {
  loaded: boolean;
  model_id: string | null;
  model_type: string | null;
  backend: string;         // e.g., "CUDA", "DirectML", "CPU"
}

// Matches types::TranscriptionChunk in Rust
interface LiveTranscriptionPayload {
  text: string;
  processing_time_ms: number;
  method: string;          // "Whisper" or "Parakeet"
}

// Frontend-only type for engine selection
type ASREngine = "whisper" | "parakeet";
```

**Type Mapping (Rust â†’ TypeScript):**

| Rust Type | TypeScript Type |
|-----------|-----------------|
| `String` | `string` |
| `f32`, `f64` | `number` |
| `u32`, `i32` | `number` |
| `bool` | `boolean` |
| `Option<T>` | `T \| null` |
| `Vec<T>` | `T[]` |

---

#### State Variables (Lines 43-67)

```typescript
function App() {
  // Persistent store reference (for saving settings)
  const storeRef = useRef<Store | null>(null);
  
  // UI State
  const [greetMsg, setGreetMsg] = useState("");           // Benchmark results
  const [liveTranscript, setLiveTranscript] = useState(""); // Real-time text
  const [latestLatency, setLatestLatency] = useState<number | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const [loadingMessage, setLoadingMessage] = useState("");
  
  // Backend State (synced from Rust)
  const [backendInfo, setBackendInfo] = useState("Loading..."); // "CUDA"/"CPU"
  const [models, setModels] = useState<ModelInfo[]>([]);
  const [currentModel, setCurrentModel] = useState<string | null>(null);
  const [sampleFiles, setSampleFiles] = useState<SampleFile[]>([]);
  const [selectedSample, setSelectedSample] = useState<string>("");
  
  // Parakeet-specific state
  const [parakeetModels, setParakeetModels] = useState<ParakeetModelInfo[]>([]);
  const [currentParakeetModel, setCurrentParakeetModel] = useState<string | null>(null);
  const [, setParakeetStatus] = useState<ParakeetStatus | null>(null);
  
  // Engine selection
  const [activeEngine, setActiveEngine] = useState<ASREngine>("whisper");
  
  // LLM (Grammar correction) state
  const [isCorrecting, setIsCorrecting] = useState(false);
  const [llmStatus, setLlmStatus] = useState("Not Loaded");
  const [enableGrammarLM, setEnableGrammarLM] = useState(false);
  
  // Refs for hotkey state (avoid stale closures in async callbacks)
  const isRecordingRef = useRef(false);
  const startingRecordingRef = useRef(false);
  const pendingStopRef = useRef(false);
}
```

**Why `useRef` for hotkey state?**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    useState vs useRef FOR ASYNC CALLBACKS                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  PROBLEM: useState creates "stale closures" in event listeners               â”‚
â”‚                                                                              â”‚
â”‚  âŒ BAD: Using useState in event listener                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  const [isRecording, setIsRecording] = useState(false);                 â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  useEffect(() => {                                                      â”‚ â”‚
â”‚  â”‚    listen("hotkey-stop", () => {                                        â”‚ â”‚
â”‚  â”‚      if (isRecording) {  // âŒ STALE! Always sees initial value (false) â”‚ â”‚
â”‚  â”‚        stopRecording();                                                 â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚    });                                                                  â”‚ â”‚
â”‚  â”‚  }, []);  // Empty deps = listener created once with initial state      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  âœ… GOOD: Using useRef for mutable value                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  const isRecordingRef = useRef(false);                                  â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Update ref whenever state changes                                   â”‚ â”‚
â”‚  â”‚  const [isRecording, setIsRecording] = useState(false);                 â”‚ â”‚
â”‚  â”‚  isRecordingRef.current = isRecording;                                  â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  useEffect(() => {                                                      â”‚ â”‚
â”‚  â”‚    listen("hotkey-stop", () => {                                        â”‚ â”‚
â”‚  â”‚      if (isRecordingRef.current) {  // âœ… Always sees latest value!     â”‚ â”‚
â”‚  â”‚        stopRecording();                                                 â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚    });                                                                  â”‚ â”‚
â”‚  â”‚  }, []);                                                                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  WHY IT WORKS:                                                               â”‚
â”‚  - useState: Each render creates new value, closure captures ONE of them     â”‚
â”‚  - useRef: Same object across all renders, .current always up-to-date        â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### How invoke() Calls Work

#### Pattern 1: Simple Call (Get Data)

```typescript
// Get backend info (CUDA/Vulkan/CPU)
const backend = await invoke("get_backend_info");
setBackendInfo(backend as string);
```

**Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     invoke()      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Frontend     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚     Backend     â”‚
â”‚                 â”‚                   â”‚                 â”‚
â”‚ invoke(         â”‚                   â”‚ #[tauri::command]
â”‚  "get_backend_  â”‚                   â”‚ fn get_backend_ â”‚
â”‚   info"         â”‚                   â”‚   info()        â”‚
â”‚ )               â”‚                   â”‚   -> String     â”‚
â”‚                 â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                 â”‚
â”‚ "CUDA"          â”‚     "CUDA"        â”‚ Ok("CUDA")      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Pattern 2: Call with Parameters

```typescript
// Switch Whisper model
const result = await invoke("switch_model", { modelId: "large-v3-turbo-q5_1" });
//                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//                                          Object with named parameters
```

**Parameter Naming:**
```
TypeScript (camelCase)  â†’  Rust (snake_case)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{ modelId: "tiny.en" }  â†’  model_id: String
{ filePath: "/path" }   â†’  file_path: String
{ newState: "ready" }   â†’  new_state: String
```

**Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INVOKE WITH PARAMETERS                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  FRONTEND:                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  await invoke("switch_model", { modelId: "tiny.en-q5_1" });             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â”‚  Serialized to JSON:                   â”‚
â”‚                                     â”‚  {                                     â”‚
â”‚                                     â”‚    "cmd": "switch_model",              â”‚
â”‚                                     â”‚    "modelId": "tiny.en-q5_1"           â”‚
â”‚                                     â”‚  }                                     â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚  BACKEND:                                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  #[tauri::command]                                                      â”‚ â”‚
â”‚  â”‚  pub fn switch_model(                                                   â”‚ â”‚
â”‚  â”‚      state: State<AudioState>,  // Injected by Tauri                    â”‚ â”‚
â”‚  â”‚      model_id: String,          // â† Deserialized from "modelId"        â”‚ â”‚
â”‚  â”‚  ) -> Result<String, String>                                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â”‚  Returns: Ok("Backend: CUDA")          â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚  FRONTEND RECEIVES:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  const result = "Backend: CUDA";                                        â”‚ â”‚
â”‚  â”‚  toast.success(`âœ… ${result}`);                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Pattern 3: Call with Error Handling

```typescript
const handleModelChange = async (modelId: string) => {
  setIsLoading(true);
  setLoadingMessage(`Loading ${modelId}...`);
  
  try {
    await setTrayState("processing");                    // Update tray icon
    const result = await invoke("switch_model", { modelId });
    setCurrentModel(modelId);
    toast.success(`âœ… ${result}`);
    
    // Refresh related state
    const backend = await invoke("get_backend_info");
    setBackendInfo(backend as string);
  } catch (e) {
    toast.error(`âŒ Error switching model: ${e}`);       // e is the Err string
  } finally {
    setIsLoading(false);
    setLoadingMessage("");
    await setTrayState("ready");
  }
};
```

**Error Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ERROR HANDLING FLOW                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  SUCCESS PATH:                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Rust: Ok("Backend: CUDA")                                              â”‚ â”‚
â”‚  â”‚           â”‚                                                             â”‚ â”‚
â”‚  â”‚           â–¼                                                             â”‚ â”‚
â”‚  â”‚  TypeScript: Promise resolves                                           â”‚ â”‚
â”‚  â”‚           â”‚                                                             â”‚ â”‚
â”‚  â”‚           â–¼                                                             â”‚ â”‚
â”‚  â”‚  const result = await invoke(...);  // result = "Backend: CUDA"         â”‚ â”‚
â”‚  â”‚  toast.success(result);                                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  ERROR PATH:                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Rust: Err("Model file not found")                                      â”‚ â”‚
â”‚  â”‚           â”‚                                                             â”‚ â”‚
â”‚  â”‚           â–¼                                                             â”‚ â”‚
â”‚  â”‚  TypeScript: Promise REJECTS                                            â”‚ â”‚
â”‚  â”‚           â”‚                                                             â”‚ â”‚
â”‚  â”‚           â–¼                                                             â”‚ â”‚
â”‚  â”‚  catch (e) {                                                            â”‚ â”‚
â”‚  â”‚    // e = "Model file not found"                                        â”‚ â”‚
â”‚  â”‚    toast.error(`Error: ${e}`);                                          â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### How listen() Events Work

#### Setting Up Event Listeners

```typescript
useEffect(() => {
  let unlistenStart: (() => void) | undefined;
  let unlistenStop: (() => void) | undefined;
  let unlistenChunk: (() => void) | undefined;

  const setupListeners = async () => {
    // Listen for hotkey events from Rust
    unlistenStart = await listen("hotkey-start-recording", async () => {
      console.log("[HOTKEY] Ctrl+Win pressed - starting recording");
      await handleStartRecording();
    });

    unlistenStop = await listen("hotkey-stop-recording", async () => {
      console.log("[HOTKEY] Ctrl+Win released - stopping recording");
      await handleStopRecording();
    });

    // Listen for real-time transcription chunks
    unlistenChunk = await listen("transcription-chunk", (event) => {
      const payload = event.payload as LiveTranscriptionPayload;
      setLiveTranscript((prev) => prev + (prev ? " " : "") + payload.text);
      setLatestLatency(payload.processing_time_ms);
    });
  };

  setupListeners();

  // Cleanup: Remove listeners when component unmounts
  return () => {
    if (unlistenStart) unlistenStart();
    if (unlistenStop) unlistenStop();
    if (unlistenChunk) unlistenChunk();
  };
}, []);  // Empty deps = run once on mount
```

**Event Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EVENT SYSTEM FLOW                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  BACKEND EMITS EVENT:                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // In recording.rs (transcriber thread)                                â”‚ â”‚
â”‚  â”‚  app_handle.emit(                                                       â”‚ â”‚
â”‚  â”‚      "transcription-chunk",                                             â”‚ â”‚
â”‚  â”‚      TranscriptionChunk {                                               â”‚ â”‚
â”‚  â”‚          text: "Hello world".to_string(),                               â”‚ â”‚
â”‚  â”‚          processing_time_ms: 150,                                       â”‚ â”‚
â”‚  â”‚          method: "Whisper".to_string(),                                 â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  );                                                                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â”‚  Serialized JSON over IPC              â”‚
â”‚                                     â”‚                                        â”‚
â”‚                                     â–¼                                        â”‚
â”‚  FRONTEND RECEIVES:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  listen("transcription-chunk", (event) => {                             â”‚ â”‚
â”‚  â”‚      // event.payload = {                                               â”‚ â”‚
â”‚  â”‚      //     text: "Hello world",                                        â”‚ â”‚
â”‚  â”‚      //     processing_time_ms: 150,                                    â”‚ â”‚
â”‚  â”‚      //     method: "Whisper"                                           â”‚ â”‚
â”‚  â”‚      // }                                                               â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      const payload = event.payload as LiveTranscriptionPayload;         â”‚ â”‚
â”‚  â”‚      setLiveTranscript(prev => prev + " " + payload.text);              â”‚ â”‚
â”‚  â”‚      setLatestLatency(payload.processing_time_ms);                      â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  TIMELINE:                                                                   â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–º   â”‚
â”‚                                                                              â”‚
â”‚  t=0      t=6s       t=12s      t=18s      t=24s                             â”‚
â”‚  â”‚        â”‚          â”‚          â”‚          â”‚                                 â”‚
â”‚  â–¼        â–¼          â–¼          â–¼          â–¼                                 â”‚
â”‚  START    EMIT       EMIT       EMIT       STOP                              â”‚
â”‚  record   chunk1     chunk2     chunk3     record                            â”‚
â”‚           â”‚          â”‚          â”‚                                            â”‚
â”‚           â–¼          â–¼          â–¼                                            â”‚
â”‚        "Hello"   "world this" "is a test"                                    â”‚
â”‚           â”‚          â”‚          â”‚                                            â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚                      â”‚                                                       â”‚
â”‚                      â–¼                                                       â”‚
â”‚           UI shows: "Hello world this is a test"                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### All Frontend â†’ Backend Calls

| Location | invoke() Call | When Triggered |
|----------|---------------|----------------|
| **Initial Load (useEffect)** |
| Line 74 | `invoke("get_backend_info")` | Component mounts |
| Line 78 | `invoke("list_models")` | Component mounts |
| Line 82 | `invoke("get_current_model")` | Component mounts |
| Line 86 | `invoke("list_sample_files")` | Component mounts |
| Line 95 | `invoke("list_parakeet_models")` | Component mounts |
| Line 98 | `invoke("get_parakeet_status")` | Component mounts |
| **Engine Sync (useEffect)** |
| Line 143 | `invoke("set_active_engine", { engine })` | Engine changes |
| **Recording Controls** |
| Line 168 | `invoke("start_recording")` | Start button / hotkey |
| Line 189 | `invoke("stop_recording")` | Stop button / hotkey |
| Line 197 | `invoke("correct_text", { text })` | After stop (if LLM enabled) |
| **Model Switching** |
| Line 316 | `invoke("switch_model", { modelId })` | Whisper dropdown change |
| Line 328 | `invoke("get_backend_info")` | After model switch |
| Line 347 | `invoke("init_parakeet", { modelId })` | Parakeet dropdown change |
| Line 358 | `invoke("get_parakeet_status")` | After Parakeet init |
| **Tray Icon** |
| Line 404 | `invoke("set_tray_state", { newState })` | State changes |
| **LLM** |
| Line 434 | `invoke("init_llm")` | Toggle LLM on |
| Line 591 | `invoke("init_llm")` | Load LLM button |
| Line 642 | `invoke("correct_text", { text })` | Correct Grammar button |
| **Benchmark** |
| Line 569 | `invoke("benchmark_test", { filePath })` | Run Benchmark button |

---

### All Backend â†’ Frontend Events

| Event Name | Emitted From | Payload | Handler |
|------------|--------------|---------|---------|
| `hotkey-start-recording` | `hotkeys/listener.rs` | None | Calls `handleStartRecording()` |
| `hotkey-stop-recording` | `hotkeys/listener.rs` | None | Calls `handleStopRecording()` |
| `transcription-chunk` | `commands/recording.rs` | `LiveTranscriptionPayload` | Updates `liveTranscript` state |

---

### User Action Flow Diagrams

#### Flow 1: Click "Start Recording"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    START RECORDING FLOW                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  USER CLICKS:  âºï¸ Start Recording                                            â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  handleStartRecording()                                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚                         â”‚                             â”‚              â”‚
â”‚       â–¼                         â–¼                             â–¼              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ setTrayStateâ”‚         â”‚ setLive     â”‚              â”‚ invoke()    â”‚        â”‚
â”‚  â”‚ ("recording")â”‚        â”‚ Transcript  â”‚              â”‚ "start_     â”‚        â”‚
â”‚  â”‚             â”‚         â”‚ ("")        â”‚              â”‚  recording" â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚                                                      â”‚               â”‚
â”‚       â–¼                                                      â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Tray icon   â”‚                                     â”‚ Rust backendâ”‚         â”‚
â”‚  â”‚ turns ğŸ”´    â”‚                                     â”‚ starts      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚ microphone  â”‚         â”‚
â”‚                                                      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                             â”‚                â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ON SUCCESS:                                                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚ â”‚
â”‚  â”‚  â”‚ toast       â”‚  â”‚ setIs       â”‚  â”‚ isRecording â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚ .success()  â”‚  â”‚ Recording   â”‚  â”‚ Ref.current â”‚                      â”‚ â”‚
â”‚  â”‚  â”‚             â”‚  â”‚ (true)      â”‚  â”‚ = true      â”‚                      â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  THEN: Backend starts emitting "transcription-chunk" events                  â”‚
â”‚        Frontend listener updates liveTranscript in real-time                 â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Flow 2: Real-Time Transcription Update

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REAL-TIME TRANSCRIPTION FLOW                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  BACKEND (every 6 seconds):                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  // In recording.rs, transcriber thread                                 â”‚ â”‚
â”‚  â”‚  app_clone.emit("transcription-chunk", TranscriptionChunk {             â”‚ â”‚
â”‚  â”‚      text: "Hello how are you",                                         â”‚ â”‚
â”‚  â”‚      processing_time_ms: 150,                                           â”‚ â”‚
â”‚  â”‚      method: "Whisper",                                                 â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  IPC Event                                 â”‚
â”‚                                 â–¼                                            â”‚
â”‚  FRONTEND (listener):                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  listen("transcription-chunk", (event) => {                             â”‚ â”‚
â”‚  â”‚      const payload = event.payload as LiveTranscriptionPayload;         â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      // Append new text to existing transcript                          â”‚ â”‚
â”‚  â”‚      setLiveTranscript((prev) =>                                        â”‚ â”‚
â”‚  â”‚          prev + (prev ? " " : "") + payload.text                        â”‚ â”‚
â”‚  â”‚      );                                                                 â”‚ â”‚
â”‚  â”‚      //  ""        â†’  "Hello how are you"                               â”‚ â”‚
â”‚  â”‚      //  "Hello how are you"  â†’  "Hello how are you I am fine"          â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      // Update latency display                                          â”‚ â”‚
â”‚  â”‚      setLatestLatency(payload.processing_time_ms);                      â”‚ â”‚
â”‚  â”‚      // Shows: âš¡ 150ms                                                  â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  React re-renders                          â”‚
â”‚                                 â–¼                                            â”‚
â”‚  UI UPDATE:                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚
â”‚  â”‚  â”‚  ğŸ”´ LIVE                                          âš¡ 150ms       â”‚  â”‚ â”‚
â”‚  â”‚  â”‚                                                                   â”‚  â”‚ â”‚
â”‚  â”‚  â”‚  Hello how are you I am fine thanks for asking                    â”‚  â”‚ â”‚
â”‚  â”‚  â”‚                                                                   â”‚  â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Flow 3: Switch Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MODEL SWITCH FLOW                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  USER SELECTS:  [Large V3 Turbo (Q5_1) â–¼]                                    â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  onChange={(e) => handleModelChange(e.target.value)}                    â”‚ â”‚
â”‚  â”‚  handleModelChange("large-v3-turbo-q5_1")                               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚                         â”‚                             â”‚              â”‚
â”‚       â–¼                         â–¼                             â–¼              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ setIsLoadingâ”‚         â”‚ setLoading  â”‚              â”‚ setTrayStateâ”‚        â”‚
â”‚  â”‚ (true)      â”‚         â”‚ Message     â”‚              â”‚("processing")â”‚       â”‚
â”‚  â”‚             â”‚         â”‚ ("Loading   â”‚              â”‚             â”‚        â”‚
â”‚  â”‚ Shows       â”‚         â”‚  Large...")â”‚              â”‚ Tray turns  â”‚        â”‚
â”‚  â”‚ spinner     â”‚         â”‚             â”‚              â”‚ ğŸŸ¡          â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  await invoke("switch_model", { modelId: "large-v3-turbo-q5_1" });      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // Backend: Unloads old model, loads new model from disk               â”‚ â”‚
â”‚  â”‚  // Takes 2-10 seconds depending on model size                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚       â”‚                                                       â”‚              â”‚
â”‚       â–¼                                                       â–¼              â”‚
â”‚  ON SUCCESS:                                            ON ERROR:            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ setCurrentModel(id)    â”‚                     â”‚ toast.error(e)          â”‚ â”‚
â”‚  â”‚ setActiveEngine        â”‚                     â”‚                         â”‚ â”‚
â”‚  â”‚   ("whisper")          â”‚                     â”‚ Model stays unchanged   â”‚ â”‚
â”‚  â”‚ store.set("whisper_   â”‚                     â”‚                         â”‚ â”‚
â”‚  â”‚   model", id)          â”‚                     â”‚                         â”‚ â”‚
â”‚  â”‚ toast.success("âœ… ...")â”‚                     â”‚                         â”‚ â”‚
â”‚  â”‚ invoke("get_backend_  â”‚                     â”‚                         â”‚ â”‚
â”‚  â”‚   info") â†’ update      â”‚                     â”‚                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  FINALLY:                                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  setIsLoading(false)   // Hide spinner                                  â”‚ â”‚
â”‚  â”‚  setLoadingMessage("") // Clear message                                 â”‚ â”‚
â”‚  â”‚  setTrayState("ready") // Tray turns ğŸŸ¢                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Flow 4: Hotkey (Ctrl+Win)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GLOBAL HOTKEY FLOW                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  USER PRESSES: Ctrl + Win (anywhere on system)                               â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  RUST: hotkeys/listener.rs                                              â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  rdev::listen(|event| {                                                 â”‚ â”‚
â”‚  â”‚      if ctrl_held && meta_held && !recording_active {                   â”‚ â”‚
â”‚  â”‚          recording_active = true;                                       â”‚ â”‚
â”‚  â”‚          app_handle.emit("hotkey-start-recording", ());                 â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â”‚  Event emitted                             â”‚
â”‚                                 â–¼                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  FRONTEND: App.tsx listener                                             â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  listen("hotkey-start-recording", async () => {                         â”‚ â”‚
â”‚  â”‚      // Debounce check                                                  â”‚ â”‚
â”‚  â”‚      if (Date.now() - lastStartTime < 500) return;                      â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚      // State check via ref (not stale state)                           â”‚ â”‚
â”‚  â”‚      if (!isRecordingRef.current && !startingRecordingRef.current) {    â”‚ â”‚
â”‚  â”‚          startingRecordingRef.current = true;                           â”‚ â”‚
â”‚  â”‚          await handleStartRecording();  // Same as button click!        â”‚ â”‚
â”‚  â”‚          startingRecordingRef.current = false;                          â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  USER RELEASES: Ctrl or Win                                                  â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  RUST: hotkeys/listener.rs                                              â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  if recording_active && (!ctrl_held || !meta_held) {                    â”‚ â”‚
â”‚  â”‚      recording_active = false;                                          â”‚ â”‚
â”‚  â”‚      app_handle.emit("hotkey-stop-recording", ());                      â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚                                            â”‚
â”‚                                 â–¼                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  FRONTEND: listener                                                     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  listen("hotkey-stop-recording", async () => {                          â”‚ â”‚
â”‚  â”‚      if (isRecordingRef.current) {                                      â”‚ â”‚
â”‚  â”‚          await handleStopRecording();  // Same as button click!         â”‚ â”‚
â”‚  â”‚      }                                                                  â”‚ â”‚
â”‚  â”‚  });                                                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  RESULT: Hold Ctrl+Win to record, release to stop.                           â”‚
â”‚          Works from ANY application on the system!                           â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Frontend State Machine

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    APP STATE MACHINE                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚                        â”‚   INITIAL   â”‚                                       â”‚
â”‚                        â”‚   LOADING   â”‚                                       â”‚
â”‚                        â”‚             â”‚                                       â”‚
â”‚                        â”‚ isInitial   â”‚                                       â”‚
â”‚                        â”‚ Loading=trueâ”‚                                       â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                       â”‚
â”‚                               â”‚                                              â”‚
â”‚                               â”‚ All invoke() calls complete                  â”‚
â”‚                               â–¼                                              â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                       â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    READY    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚            â”‚           â”‚             â”‚           â”‚                           â”‚
â”‚            â”‚           â”‚ isRecording â”‚           â”‚                           â”‚
â”‚            â”‚           â”‚ = false     â”‚           â”‚                           â”‚
â”‚            â”‚           â”‚ isLoading   â”‚           â”‚                           â”‚
â”‚            â”‚           â”‚ = false     â”‚           â”‚                           â”‚
â”‚            â”‚           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜           â”‚                           â”‚
â”‚            â”‚                  â”‚                  â”‚                           â”‚
â”‚            â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                           â”‚
â”‚            â”‚    â”‚             â”‚             â”‚    â”‚                           â”‚
â”‚            â”‚    â”‚ Start       â”‚ Switch      â”‚    â”‚                           â”‚
â”‚            â”‚    â”‚ Recording   â”‚ Model       â”‚    â”‚                           â”‚
â”‚            â”‚    â–¼             â–¼             â”‚    â”‚                           â”‚
â”‚            â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚RECORDINGâ”‚  â”‚ LOADING â”‚       â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚         â”‚  â”‚         â”‚       â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚isRecord â”‚  â”‚isLoadingâ”‚       â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚ing=true â”‚  â”‚= true   â”‚       â”‚    â”‚                           â”‚
â”‚            â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â”‚    â”‚                           â”‚
â”‚            â”‚      â”‚            â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚      â”‚ Stop       â”‚ Done       â”‚    â”‚                           â”‚
â”‚            â”‚      â”‚ Recording  â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚      â–¼            â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚PROCESSINGâ”‚      â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚         â”‚       â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚ (Final  â”‚       â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â”‚  pass)  â”‚       â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â”‚            â”‚    â”‚                           â”‚
â”‚            â”‚      â”‚            â”‚            â”‚    â”‚                           â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                           â”‚
â”‚                                                  â”‚                           â”‚
â”‚                         Error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                              â”‚
â”‚  TRAY ICON STATES:                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  â”‚   ğŸŸ¢ READY  â”‚  â”‚ ğŸ”´ RECORDING â”‚  â”‚ğŸŸ¡ PROCESSINGâ”‚                           â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚                           â”‚
â”‚  â”‚ Waiting for â”‚  â”‚ Mic active, â”‚  â”‚ Loading     â”‚                           â”‚
â”‚  â”‚ user input  â”‚  â”‚ transcribingâ”‚  â”‚ model or    â”‚                           â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚ final pass  â”‚                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### CSS Architecture

```
App.css Structure:
â”œâ”€â”€ :root (CSS Variables)
â”‚   â”œâ”€â”€ Color palette (--bg-primary, --accent-primary, etc.)
â”‚   â”œâ”€â”€ Typography settings
â”‚   â””â”€â”€ Common values (--border-color, --shadow-color)
â”‚
â”œâ”€â”€ Base styles (body, *, .container)
â”‚
â”œâ”€â”€ Component styles
â”‚   â”œâ”€â”€ .status-bar-container, .status-card (Engine cards)
â”‚   â”œâ”€â”€ .engine-badge (Whisper/Parakeet labels)
â”‚   â”œâ”€â”€ .model-section, .model-select (Dropdown)
â”‚   â”œâ”€â”€ .controls, .btn, .btn-start, .btn-stop (Buttons)
â”‚   â”œâ”€â”€ .output-area, .live-transcript (Results)
â”‚   â”œâ”€â”€ .loading-overlay, .loading-spinner (Loading state)
â”‚   â””â”€â”€ .switch, .slider (Toggle switch)
â”‚
â”œâ”€â”€ Animations (@keyframes)
â”‚   â”œâ”€â”€ spin (Loading spinner)
â”‚   â”œâ”€â”€ fadeIn (Component entrance)
â”‚   â””â”€â”€ pulse (Live indicator)
â”‚
â””â”€â”€ Responsive design (@media queries)
```

---

### Quick Reference: Frontend â†’ Backend

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND-BACKEND CHEAT SHEET                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  CALL BACKEND FUNCTION:                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  import { invoke } from "@tauri-apps/api/core";                         â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // No parameters                                                       â”‚ â”‚
â”‚  â”‚  const result = await invoke("command_name");                           â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // With parameters (camelCase â†’ snake_case automatic)                  â”‚ â”‚
â”‚  â”‚  const result = await invoke("command_name", { paramName: value });     â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  // With error handling                                                 â”‚ â”‚
â”‚  â”‚  try {                                                                  â”‚ â”‚
â”‚  â”‚    const result = await invoke("command_name");                         â”‚ â”‚
â”‚  â”‚  } catch (error) {                                                      â”‚ â”‚
â”‚  â”‚    console.error(error);  // error is the Err(...) string from Rust     â”‚ â”‚
â”‚  â”‚  }                                                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  LISTEN FOR BACKEND EVENTS:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  import { listen } from "@tauri-apps/api/event";                        â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  useEffect(() => {                                                      â”‚ â”‚
â”‚  â”‚    let unlisten: (() => void) | undefined;                              â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚    const setup = async () => {                                          â”‚ â”‚
â”‚  â”‚      unlisten = await listen("event-name", (event) => {                 â”‚ â”‚
â”‚  â”‚        const payload = event.payload as MyType;                         â”‚ â”‚
â”‚  â”‚        // Handle event...                                               â”‚ â”‚
â”‚  â”‚      });                                                                â”‚ â”‚
â”‚  â”‚    };                                                                   â”‚ â”‚
â”‚  â”‚    setup();                                                             â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚    return () => { if (unlisten) unlisten(); };  // Cleanup!             â”‚ â”‚
â”‚  â”‚  }, []);                                                                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  TYPE MAPPING:                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Rust                    TypeScript                                     â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚ â”‚
â”‚  â”‚  String                  string                                         â”‚ â”‚
â”‚  â”‚  i32, u32, f32, f64      number                                         â”‚ â”‚
â”‚  â”‚  bool                    boolean                                        â”‚ â”‚
â”‚  â”‚  Option<T>               T | null                                       â”‚ â”‚
â”‚  â”‚  Vec<T>                  T[]                                            â”‚ â”‚
â”‚  â”‚  Result<T, E>            T (or throws E)                                â”‚ â”‚
â”‚  â”‚  ()                      void / null                                    â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Field names: snake_case â†’ camelCase                                    â”‚ â”‚
â”‚  â”‚  processing_time_ms â†’ processingTimeMs                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Rust Crates & Dependencies Guide

Complete documentation of every crate used in this project, what it does, and how it's used.

---

### Cargo.toml Structure Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CARGO.TOML DEPENDENCY STRUCTURE                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  [build-dependencies]          # Used during compilation                     â”‚
â”‚  â””â”€â”€ tauri-build               # Compiles Tauri app resources                â”‚
â”‚                                                                              â”‚
â”‚  [dependencies]                # Used on ALL platforms                       â”‚
â”‚  â”œâ”€â”€ tauri                     # App framework (window, IPC, tray)           â”‚
â”‚  â”œâ”€â”€ serde/serde_json          # JSON serialization                          â”‚
â”‚  â”œâ”€â”€ cpal                      # Audio capture                               â”‚
â”‚  â”œâ”€â”€ crossbeam-channel         # Thread communication                        â”‚
â”‚  â”œâ”€â”€ hound                     # WAV file I/O                                â”‚
â”‚  â”œâ”€â”€ chrono                    # Date/time handling                          â”‚
â”‚  â”œâ”€â”€ rubato                    # Audio resampling                            â”‚
â”‚  â”œâ”€â”€ dirs                      # OS directories (AppData, etc.)              â”‚
â”‚  â”œâ”€â”€ rdev                      # Global hotkeys                              â”‚
â”‚  â”œâ”€â”€ regex                     # Text pattern matching                       â”‚
â”‚  â”œâ”€â”€ candle-*                  # ML framework (Gemma LLM)                    â”‚
â”‚  â”œâ”€â”€ tokenizers                # LLM tokenization                            â”‚
â”‚  â””â”€â”€ anyhow                    # Error handling                              â”‚
â”‚                                                                              â”‚
â”‚  [target.'cfg(...)'.dependencies]  # Platform-specific                       â”‚
â”‚  â”œâ”€â”€ whisper-rs                # Speech-to-text (Whisper)                    â”‚
â”‚  â”œâ”€â”€ parakeet-rs               # Speech-to-text (Parakeet)                   â”‚
â”‚  â””â”€â”€ ort                       # ONNX Runtime                                â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Core Framework Crates

#### 1. `tauri` - Application Framework

```toml
tauri = { version = "2", features = ["tray-icon", "image-png"] }
```

**What it is:** The core Tauri framework that creates desktop applications with a web frontend and Rust backend.

**Features enabled:**
- `tray-icon`: System tray support (the colored circles ğŸŸ¢ğŸ”´ğŸŸ¡)
- `image-png`: PNG image loading for tray icons

**How it's used:**

```rust
// In lib.rs - App builder
tauri::Builder::default()
    .plugin(tauri_plugin_opener::init())    // Plugin registration
    .plugin(tauri_plugin_store::Builder::default().build())
    .plugin(tauri_plugin_fs::init())
    .manage(audio_state)                    // State management
    .invoke_handler(tauri::generate_handler![...])  // Command registration
    .setup(|app| { ... })                   // App initialization
    .run(tauri::generate_context!())        // Run the app

// In commands - Accessing Tauri features
use tauri::{AppHandle, State, Emitter, Manager};

#[tauri::command]
pub fn my_command(
    app: AppHandle,           // Access to app methods
    state: State<AudioState>, // Managed state
) -> Result<String, String> {
    app.emit("event-name", payload)?;  // Emit to frontend
    Ok("Success".to_string())
}
```

**Analogy:** Tauri is like the **skeleton and nervous system** of your app - it provides the structure (windows, menus) and communication pathways (IPC between frontend and backend).

---

#### 2. `tauri-plugin-store` - Persistent Settings

```toml
tauri-plugin-store = "2.4.2"
```

**What it is:** A plugin for persisting user settings as JSON files.

**How it's used:**

```rust
// In lib.rs - Register plugin
.plugin(tauri_plugin_store::Builder::default().build())
```

```typescript
// In App.tsx - Frontend usage
import { Store } from "@tauri-apps/plugin-store";

const store = await Store.load("settings.json");
await store.set("active_engine", "whisper");
await store.save();

const engine = await store.get<string>("active_engine");
```

**Where data is stored:** `%APPDATA%/com.taurscribe.app/settings.json` (Windows)

---

#### 3. `tauri-plugin-fs` - File System Access

```toml
tauri-plugin-fs = "2"
```

**What it is:** Provides access to file system operations with security permissions.

**How it's used:** Allows the app to read/write files in allowed directories (AppData, etc.).

---

#### 4. `tauri-plugin-opener` - External Links

```toml
tauri-plugin-opener = "2"
```

**What it is:** Opens URLs in the default browser or files with their associated applications.

---

### Serialization Crates

#### 5. `serde` - Serialization Framework

```toml
serde = { version = "1", features = ["derive"] }
```

**What it is:** The de-facto Rust serialization framework. Converts Rust structs to/from other formats (JSON, TOML, etc.).

**The `derive` feature:** Auto-generates serialization code via `#[derive(Serialize, Deserialize)]`.

**How it's used:**

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct ModelInfo {
    pub id: String,
    pub display_name: String,
    pub size_mb: f64,
}
// Serde auto-generates the code to convert this to/from JSON:
// { "id": "tiny.en", "display_name": "Tiny English", "size_mb": 42.3 }
```

**Why it matters:** Every struct that crosses the frontend-backend boundary MUST be Serialize/Deserialize.

---

#### 6. `serde_json` - JSON Handling

```toml
serde_json = "1"
```

**What it is:** JSON-specific serialization using Serde.

**How it's used:**

```rust
use serde_json;

let json_string = serde_json::to_string(&my_struct)?;
let my_struct: MyStruct = serde_json::from_str(&json_string)?;
```

---

### Audio Processing Crates

#### 7. `cpal` - Cross-Platform Audio Library

```toml
cpal = "0.15"
```

**What it is:** Low-level cross-platform audio I/O. Interfaces with OS audio APIs (WASAPI on Windows, CoreAudio on macOS, ALSA on Linux).

**How it's used:**

```rust
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};

// Get the default audio host (WASAPI/CoreAudio/ALSA)
let host = cpal::default_host();

// Get the default input device (microphone)
let device = host.default_input_device()
    .ok_or("No input device found")?;

// Get supported audio format
let config = device.default_input_config()?;
// e.g., 48000 Hz, 2 channels, f32 samples

// Build audio stream with callback
let stream = device.build_input_stream(
    &config.into(),
    move |data: &[f32], _: &cpal::InputCallbackInfo| {
        // This runs every ~10ms with new audio samples
        sender.send(data.to_vec()).ok();
    },
    |err| eprintln!("Stream error: {}", err),
    None,
)?;

stream.play()?;  // Start capturing
```

**Diagram:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CPAL AUDIO FLOW                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   MICROPHONE                                                                 â”‚
â”‚       â”‚                                                                      â”‚
â”‚       â–¼                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                          â”‚
â”‚   â”‚   OS DRIVER   â”‚  â† WASAPI (Win) / CoreAudio (Mac) / ALSA (Linux)         â”‚
â”‚   â”‚               â”‚                                                          â”‚
â”‚   â”‚  Samples at   â”‚                                                          â”‚
â”‚   â”‚  48000 Hz     â”‚                                                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                          â”‚
â”‚           â”‚                                                                  â”‚
â”‚           â–¼                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                          â”‚
â”‚   â”‚     CPAL      â”‚  â† Abstracts OS differences                              â”‚
â”‚   â”‚               â”‚                                                          â”‚
â”‚   â”‚ Provides:     â”‚                                                          â”‚
â”‚   â”‚ - &[f32]      â”‚  Audio samples (-1.0 to +1.0)                            â”‚
â”‚   â”‚ - Sample rate â”‚  48000, 44100, etc.                                      â”‚
â”‚   â”‚ - Channels    â”‚  Mono=1, Stereo=2                                        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                          â”‚
â”‚           â”‚                                                                  â”‚
â”‚           â”‚  Callback every ~10ms                                            â”‚
â”‚           â–¼                                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                          â”‚
â”‚   â”‚  YOUR CODE    â”‚                                                          â”‚
â”‚   â”‚               â”‚                                                          â”‚
â”‚   â”‚ sender.send(  â”‚                                                          â”‚
â”‚   â”‚   data.to_vec â”‚                                                          â”‚
â”‚   â”‚ )             â”‚                                                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### 8. `crossbeam-channel` - Thread Communication

```toml
crossbeam-channel = "0.5"
```

**What it is:** High-performance multi-producer multi-consumer channels for thread communication. Faster and more feature-rich than `std::sync::mpsc`.

**How it's used:**

```rust
use crossbeam_channel::{unbounded, Sender, Receiver};

// Create channel pair
let (sender, receiver): (Sender<Vec<f32>>, Receiver<Vec<f32>>) = unbounded();

// Audio thread sends samples
std::thread::spawn(move || {
    let samples = vec![0.1, 0.2, 0.3];
    sender.send(samples).ok();
});

// Processing thread receives samples
std::thread::spawn(move || {
    while let Ok(samples) = receiver.recv() {
        // Process audio...
    }
});
```

**Why crossbeam over std::sync::mpsc?**

| Feature | std::sync::mpsc | crossbeam-channel |
|---------|-----------------|-------------------|
| Multi-producer | âœ… | âœ… |
| Multi-consumer | âŒ | âœ… |
| Select (wait on multiple) | âŒ | âœ… |
| Bounded channels | âŒ | âœ… |
| Performance | Good | Better |

---

#### 9. `hound` - WAV File I/O

```toml
hound = "3.5"
```

**What it is:** Read and write WAV audio files.

**How it's used:**

```rust
use hound::{WavSpec, WavWriter, SampleFormat};

// Create WAV file
let spec = WavSpec {
    channels: 1,           // Mono
    sample_rate: 16000,    // 16kHz (Whisper's expected rate)
    bits_per_sample: 32,   // 32-bit float
    sample_format: SampleFormat::Float,
};

let mut writer = WavWriter::create(path, spec)?;

// Write samples
for sample in audio_samples {
    writer.write_sample(sample)?;
}
writer.finalize()?;  // Important! Writes header with correct length
```

**Reading WAV:**

```rust
use hound::WavReader;

let mut reader = WavReader::open(path)?;
let samples: Vec<f32> = reader.samples::<f32>()
    .filter_map(Result::ok)
    .collect();
```

---

#### 10. `rubato` - Audio Resampling

```toml
rubato = "0.14"
```

**What it is:** High-quality audio sample rate conversion. Converts between sample rates (e.g., 48000Hz â†’ 16000Hz) while preserving audio quality.

**Why it's needed:** Whisper requires exactly 16000Hz audio. Microphones typically provide 44100Hz or 48000Hz.

**How it's used:**

```rust
use rubato::{FftFixedIn, Resampler};

// Create resampler: 48000Hz â†’ 16000Hz
let mut resampler = FftFixedIn::<f32>::new(
    48000,   // Input sample rate
    16000,   // Output sample rate (Whisper requires this)
    1024,    // Chunk size
    2,       // Sub-chunks (quality vs speed tradeoff)
    1,       // Number of channels
)?;

// Resample audio
let input_frames = vec![audio_samples];  // Vec<Vec<f32>>
let output_frames = resampler.process(&input_frames, None)?;
let resampled: Vec<f32> = output_frames.into_iter().flatten().collect();
```

**Diagram:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RESAMPLING VISUALIZATION                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  INPUT: 48000 Hz (3x more samples)                                           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•     â”‚
â”‚  â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚     â”‚
â”‚  â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜     â”‚
â”‚                              â”‚                                               â”‚
â”‚                              â”‚  rubato (FFT-based resampling)                â”‚
â”‚                              â–¼                                               â”‚
â”‚  OUTPUT: 16000 Hz (1/3 samples, same duration)                               â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                               â”‚
â”‚  â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚                               â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                           â”‚
â”‚                                                                              â”‚
â”‚  KEY: Same audio duration, different sample density                          â”‚
â”‚       Rubato uses FFT to preserve frequencies during conversion              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### AI/ML Crates

#### 11. `whisper-rs` - Speech-to-Text (Whisper)

```toml
# Base (CPU)
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }

# Windows/Linux x86_64 (GPU)
whisper-rs = { git = "...", features = ["cuda", "vulkan"] }
```

**What it is:** Rust bindings for OpenAI's Whisper speech recognition model via whisper.cpp (C++ implementation).

**Features:**
- `cuda`: NVIDIA GPU acceleration
- `vulkan`: Cross-vendor GPU acceleration (NVIDIA, AMD, Intel)

**How it's used:**

```rust
use whisper_rs::{
    FullParams, SamplingStrategy, WhisperContext, WhisperContextParameters,
};

// Load model (once at startup)
let ctx = WhisperContext::new_with_params(
    "/path/to/ggml-large-v3-turbo-q5_1.bin",
    WhisperContextParameters::default()
        .use_gpu(true),  // Enable GPU if available
)?;

// Create transcription parameters
let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
params.set_language(Some("en"));
params.set_print_progress(false);
params.set_single_segment(true);    // Real-time mode

// Create state and run inference
let mut state = ctx.create_state()?;
state.full(params, &audio_16khz)?;  // Must be 16kHz mono f32!

// Extract result
let text = state.full_get_segment_text(0)?;
```

---

#### 12. `parakeet-rs` - Speech-to-Text (Parakeet)

```toml
# Base
parakeet-rs = { version = "=0.3.0" }

# With GPU
parakeet-rs = { version = "=0.3.0", features = ["cuda", "directml"] }
```

**What it is:** Rust bindings for NVIDIA's Parakeet ASR models. Uses ONNX Runtime for inference.

**Model types:**
- `Nemotron`: NVIDIA's Nemotron architecture
- `ParakeetTDT`: Token-and-Duration Transducer (fastest, most accurate)
- `Parakeet` (CTC): Connectionist Temporal Classification
- `ParakeetEOU`: End-of-Utterance detection

**How it's used:**

```rust
use parakeet_rs::{ParakeetTDT, Transcriber, TimestampMode};

// Load model
let model = ParakeetTDT::from_files(
    "/path/to/encoder.onnx",
    "/path/to/decoder.onnx",
    "/path/to/joiner.onnx",
    "/path/to/tokenizer.model",
)?;

// Transcribe (expects 16kHz mono)
let text = model.transcribe(&audio_16khz, TimestampMode::None)?;
```

---

#### 13. `ort` - ONNX Runtime

```toml
ort = { version = "2.0.0-rc.11", features = [
    "download-binaries",  # Auto-download ONNX Runtime
    "cuda",               # NVIDIA GPU
    "directml",           # Windows GPU (AMD/Intel)
    "tensorrt",           # NVIDIA optimized inference
    "xnnpack",            # CPU optimization
] }
```

**What it is:** Rust bindings for Microsoft's ONNX Runtime - a high-performance inference engine for ONNX models.

**Why it's used:** Parakeet models are in ONNX format. ORT provides hardware acceleration across different GPUs.

**Feature breakdown:**

| Feature | What it does | Platform |
|---------|--------------|----------|
| `cuda` | NVIDIA GPU acceleration | Windows, Linux |
| `directml` | DirectX 12 GPU acceleration | Windows only |
| `tensorrt` | NVIDIA optimized inference | Windows, Linux |
| `xnnpack` | ARM/x86 CPU optimization | All |
| `coreml` | Apple Neural Engine | macOS only |

---

#### 14. `candle-*` - ML Framework (Gemma LLM)

```toml
candle-core = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
candle-nn = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
candle-transformers = { git = "https://github.com/huggingface/candle.git", version = "0.9.2" }
```

**What it is:** Hugging Face's pure-Rust ML framework. Like PyTorch, but in Rust.

**Crate breakdown:**
- `candle-core`: Tensor operations, device management, quantization
- `candle-nn`: Neural network layers
- `candle-transformers`: Pre-built transformer models (Gemma, Llama, etc.)

**How it's used (Gemma LLM for grammar correction):**

```rust
use candle_core::{Device, Tensor};
use candle_core::quantized::gguf_file;
use candle_transformers::models::quantized_gemma3 as model;
use candle_transformers::generation::LogitsProcessor;

// Load quantized GGUF model
let mut file = std::fs::File::open("/path/to/gemma-3-1b-it-q4_k_m.gguf")?;
let model_data = gguf_file::Content::read(&mut file)?;
let model = model::ModelWeights::from_gguf(model_data, &mut file, &Device::Cpu)?;

// Tokenize input
let tokens = tokenizer.encode(prompt, true)?;
let input_ids = Tensor::new(tokens.get_ids(), &Device::Cpu)?;

// Generate response
let logits = model.forward(&input_ids, 0)?;
let next_token = logits_processor.sample(&logits)?;
```

---

#### 15. `tokenizers` - LLM Tokenization

```toml
tokenizers = "0.21.0"
```

**What it is:** Hugging Face's tokenizer library. Converts text â†” token IDs for language models.

**How it's used:**

```rust
use tokenizers::Tokenizer;

// Load tokenizer from model config
let tokenizer = Tokenizer::from_file("/path/to/tokenizer.json")?;

// Encode text â†’ tokens
let encoding = tokenizer.encode("Hello world", true)?;
let token_ids: Vec<u32> = encoding.get_ids().to_vec();
// [1, 15043, 2088]  (example token IDs)

// Decode tokens â†’ text
let text = tokenizer.decode(&token_ids, true)?;
// "Hello world"
```

---

#### 16. `hf-hub` - Hugging Face Model Hub

```toml
hf-hub = "0.4"
```

**What it is:** Download models from Hugging Face Hub.

**How it's used:**

```rust
use hf_hub::api::sync::Api;

let api = Api::new()?;
let repo = api.model("google/gemma-3-1b-it-qat-q4_0-gguf".to_string());
let model_path = repo.get("gemma-3-1b-it-q4_0.gguf")?;
```

---

### Utility Crates

#### 17. `chrono` - Date/Time

```toml
chrono = "0.4"
```

**What it is:** Date and time library for Rust.

**How it's used:**

```rust
use chrono::Local;

// Generate timestamp for file names
let timestamp = Local::now().format("%Y%m%d_%H%M%S");
let filename = format!("recording_{}.wav", timestamp);
// "recording_20260201_143052.wav"
```

---

#### 18. `dirs` - OS Directories

```toml
dirs = "6.0.0"
```

**What it is:** Provides paths to standard OS directories.

**How it's used:**

```rust
use dirs;

// Get AppData directory (cross-platform)
let data_dir = dirs::data_dir();  
// Windows: C:\Users\<user>\AppData\Roaming
// macOS:   /Users/<user>/Library/Application Support
// Linux:   /home/<user>/.local/share

// Get home directory
let home = dirs::home_dir();
// Windows: C:\Users\<user>
// macOS/Linux: /home/<user>
```

---

#### 19. `rdev` - Global Hotkeys

```toml
rdev = "0.5"
```

**What it is:** Raw device events - captures keyboard/mouse events system-wide (even when app isn't focused).

**How it's used:**

```rust
use rdev::{listen, Event, EventType, Key};

// Listen for ALL keyboard events on the system
std::thread::spawn(|| {
    listen(|event| {
        match event.event_type {
            EventType::KeyPress(Key::ControlLeft) => {
                ctrl_held = true;
            }
            EventType::KeyPress(Key::MetaLeft) => {
                // Win key pressed
                if ctrl_held {
                    app_handle.emit("hotkey-start-recording", ());
                }
            }
            EventType::KeyRelease(Key::ControlLeft) => {
                ctrl_held = false;
                if was_recording {
                    app_handle.emit("hotkey-stop-recording", ());
                }
            }
            _ => {}
        }
    }).expect("Failed to listen for events");
});
```

**Security note:** Requires elevated permissions on some Linux systems.

---

#### 20. `regex` - Regular Expressions

```toml
regex = "1.12.2"
```

**What it is:** Regular expression library for pattern matching in text.

**How it's used:**

```rust
use regex::Regex;

// Clean transcript text
let re = Regex::new(r"\s+").unwrap();
let cleaned = re.replace_all(transcript, " ");

// Remove [BLANK_AUDIO] artifacts
let re = Regex::new(r"\[BLANK_AUDIO\]").unwrap();
let cleaned = re.replace_all(&cleaned, "");
```

---

#### 21. `anyhow` - Error Handling

```toml
anyhow = "1.0"
```

**What it is:** Easy error handling with automatic error context and conversion.

**How it's used:**

```rust
use anyhow::{Result, Context, bail};

fn load_model(path: &str) -> Result<Model> {
    let file = std::fs::File::open(path)
        .context("Failed to open model file")?;  // Adds context to error
    
    if file.metadata()?.len() == 0 {
        bail!("Model file is empty");  // Create error and return early
    }
    
    Ok(Model::from_file(file)?)
}
```

**Why use anyhow?**
- `?` works with any error type
- `.context()` adds human-readable messages
- `bail!()` macro for early returns
- Better error messages in logs

---

### Platform-Specific Dependencies

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PLATFORM-SPECIFIC DEPENDENCY MATRIX                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                 â”‚ Windows    â”‚ Windows    â”‚ macOS      â”‚ Linux      â”‚    â”‚
â”‚  â”‚                 â”‚ x86_64     â”‚ ARM64      â”‚ (All)      â”‚ x86_64     â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ whisper-rs      â”‚ cuda,      â”‚ (base)     â”‚ (base)     â”‚ cuda,      â”‚    â”‚
â”‚  â”‚                 â”‚ vulkan     â”‚            â”‚            â”‚ vulkan     â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ parakeet-rs     â”‚ cuda,      â”‚ directml   â”‚ (base)     â”‚ cuda       â”‚    â”‚
â”‚  â”‚                 â”‚ directml   â”‚            â”‚            â”‚            â”‚    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚  â”‚ ort features    â”‚ cuda,      â”‚ directml,  â”‚ xnnpack    â”‚ cuda,      â”‚    â”‚
â”‚  â”‚                 â”‚ directml,  â”‚ xnnpack    â”‚            â”‚ tensorrt,  â”‚    â”‚
â”‚  â”‚                 â”‚ tensorrt,  â”‚            â”‚            â”‚ xnnpack    â”‚    â”‚
â”‚  â”‚                 â”‚ xnnpack    â”‚            â”‚            â”‚            â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                              â”‚
â”‚  LEGEND:                                                                     â”‚
â”‚  cuda     = NVIDIA GPU (requires CUDA Toolkit)                               â”‚
â”‚  vulkan   = Cross-vendor GPU (requires Vulkan SDK)                           â”‚
â”‚  directml = Windows GPU via DirectX 12 (built into Windows)                  â”‚
â”‚  tensorrt = NVIDIA optimized inference (requires TensorRT)                   â”‚
â”‚  xnnpack  = CPU optimization (no extra requirements)                         â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ–¥ï¸ OS Dependencies & Requirements

### Windows Requirements

#### 1. Visual Studio Build Tools (Required)

```
Download: https://visualstudio.microsoft.com/visual-cpp-build-tools/

Required components:
â”œâ”€â”€ MSVC v143 (or later) - C++ Build Tools
â”œâ”€â”€ Windows 11 SDK (or Windows 10 SDK)
â””â”€â”€ C++ CMake tools for Windows
```

**Why needed:** whisper-rs and parakeet-rs compile C++ code during build.

---

#### 2. CUDA Toolkit (Optional - For NVIDIA GPU)

```
Download: https://developer.nvidia.com/cuda-toolkit

Required version: 12.x (tested with 12.9)

Sets environment variable:
CUDA_PATH = C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.9
```

**Why needed:** GPU acceleration for Whisper and Parakeet on NVIDIA cards.

**build.rs handles this:**
```rust
// Automatically finds CUDA libraries
if let Ok(cuda_path) = std::env::var("CUDA_PATH") {
    let lib_path = cuda_path.join("lib").join("x64");
    println!("cargo:rustc-link-search=native={}", lib_path.display());
}
```

---

#### 3. Vulkan SDK (Optional - For AMD/Intel GPU with Whisper)

```
Download: https://vulkan.lunarg.com/sdk/home

Sets environment variable:
VULKAN_SDK = C:\VulkanSDK\1.3.xxx
```

**Why needed:** Alternative GPU acceleration for Whisper (works with AMD, Intel, NVIDIA).

---

#### 4. LLVM/Clang (Required for ARM64 Windows only)

```
Download: https://releases.llvm.org/

Required for: Windows ARM64 (Snapdragon laptops)
```

**Why needed:** whisper.cpp doesn't support MSVC on ARM64.

**build.rs handles this:**
```rust
#[cfg(all(target_os = "windows", target_arch = "aarch64"))]
{
    std::env::set_var("CC", "clang-cl");
    std::env::set_var("CXX", "clang-cl");
}
```

---

### macOS Requirements

#### 1. Xcode Command Line Tools (Required)

```bash
xcode-select --install
```

**Why needed:** Provides C/C++ compiler (clang) and build tools.

---

#### 2. Minimum macOS Version

```
Required: macOS 13.4+ (Ventura or later)

Why: ONNX Runtime requires macOS 13.4+ on Apple Silicon
     whisper.cpp requires C++17 std::filesystem (macOS 10.15+)
```

**build.rs handles this:**
```rust
#[cfg(target_os = "macos")]
{
    println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=13.4");
    std::env::set_var("MACOSX_DEPLOYMENT_TARGET", "13.4");
}
```

---

### Linux Requirements

#### 1. Build Essentials (Required)

```bash
# Debian/Ubuntu
sudo apt install build-essential cmake pkg-config

# Fedora
sudo dnf install @development-tools cmake

# Arch
sudo pacman -S base-devel cmake
```

---

#### 2. ALSA Development Libraries (Required for audio)

```bash
# Debian/Ubuntu
sudo apt install libasound2-dev

# Fedora
sudo dnf install alsa-lib-devel

# Arch
sudo pacman -S alsa-lib
```

**Why needed:** cpal uses ALSA for audio capture on Linux.

---

#### 3. X11 Development Libraries (Required for rdev hotkeys)

```bash
# Debian/Ubuntu
sudo apt install libx11-dev libxtst-dev

# Fedora
sudo dnf install libX11-devel libXtst-devel

# Arch
sudo pacman -S libx11 libxtst
```

**Why needed:** rdev uses X11 for capturing keyboard events.

---

#### 4. CUDA Toolkit (Optional - For NVIDIA GPU)

```bash
# Follow NVIDIA's official guide:
# https://developer.nvidia.com/cuda-downloads

# Verify installation:
nvcc --version
nvidia-smi
```

---

### Dependency Installation Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INSTALLATION CHECKLIST                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  WINDOWS:                                                                    â”‚
â”‚  â˜ Visual Studio Build Tools (required)                                     â”‚
â”‚  â˜ CUDA Toolkit 12.x (optional, for NVIDIA GPU)                             â”‚
â”‚  â˜ Vulkan SDK (optional, for Whisper GPU on AMD/Intel)                      â”‚
â”‚  â˜ LLVM/Clang (only for ARM64 Windows)                                      â”‚
â”‚                                                                              â”‚
â”‚  MACOS:                                                                      â”‚
â”‚  â˜ Xcode Command Line Tools (required)                                      â”‚
â”‚  â˜ macOS 13.4+ (required)                                                   â”‚
â”‚                                                                              â”‚
â”‚  LINUX:                                                                      â”‚
â”‚  â˜ build-essential, cmake (required)                                        â”‚
â”‚  â˜ libasound2-dev (required for audio)                                      â”‚
â”‚  â˜ libx11-dev, libxtst-dev (required for hotkeys)                           â”‚
â”‚  â˜ CUDA Toolkit (optional, for NVIDIA GPU)                                  â”‚
â”‚                                                                              â”‚
â”‚  ALL PLATFORMS:                                                              â”‚
â”‚  â˜ Rust (via rustup): https://rustup.rs                                     â”‚
â”‚  â˜ Node.js 18+ (for frontend): https://nodejs.org                           â”‚
â”‚  â˜ Bun (faster npm alternative): https://bun.sh                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### How Crates Map to Features

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FEATURE â†’ CRATE MAPPING                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  FEATURE                          CRATES INVOLVED                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                                                              â”‚
â”‚  ğŸ™ï¸ Audio Capture                 cpal, crossbeam-channel                    â”‚
â”‚  ğŸ“ Save Recordings               hound, dirs, chrono                        â”‚
â”‚  ğŸ”Š Audio Preprocessing           rubato (resample to 16kHz)                 â”‚
â”‚  ğŸ—£ï¸ Speech Recognition           whisper-rs OR parakeet-rs + ort            â”‚
â”‚  âœ¨ Grammar Correction            candle-*, tokenizers, hf-hub               â”‚
â”‚  âŒ¨ï¸ Global Hotkeys                rdev                                       â”‚
â”‚  ğŸ’¾ Persistent Settings           tauri-plugin-store, serde                  â”‚
â”‚  ğŸ–¥ï¸ System Tray                   tauri (tray-icon feature)                  â”‚
â”‚  ğŸŒ Frontend â†” Backend            tauri, serde, serde_json                   â”‚
â”‚  ğŸ“ Text Processing               regex                                      â”‚
â”‚  âš ï¸ Error Handling                anyhow                                     â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Import Patterns in Source Files

```rust
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMMON IMPORT PATTERNS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Tauri imports (commands, state, events)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use tauri::{AppHandle, State, Emitter, Manager};
use tauri::tray::TrayIconBuilder;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Audio imports
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use crossbeam_channel::{unbounded, Sender, Receiver};
use hound::{WavSpec, WavWriter, WavReader, SampleFormat};
use rubato::{FftFixedIn, Resampler};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AI/ML imports (Whisper)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use whisper_rs::{
    FullParams, SamplingStrategy, WhisperContext, WhisperContextParameters,
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AI/ML imports (Parakeet)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use parakeet_rs::{Nemotron, Parakeet, ParakeetEOU, ParakeetTDT, TimestampMode, Transcriber};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AI/ML imports (Candle for Gemma LLM)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use candle_core::{Device, Tensor};
use candle_core::quantized::gguf_file;
use candle_transformers::generation::LogitsProcessor;
use candle_transformers::models::quantized_gemma3 as model;
use tokenizers::Tokenizer;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Utility imports
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use std::sync::{Arc, Mutex};
use std::path::PathBuf;
use serde::{Serialize, Deserialize};
use chrono::Local;
use dirs;
use regex::Regex;
use rdev::{listen, Event, EventType, Key};
use anyhow::{Result, Context};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Internal module imports
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
use crate::state::AudioState;
use crate::types::{ASREngine, AppState, TranscriptionChunk};
use crate::whisper::WhisperManager;
use crate::parakeet::ParakeetManager;
```

---

## âš™ï¸ Configuration Files Deep Dive

Complete breakdown of every configuration file and what each setting does for each platform.

---

### Configuration File Map

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROJECT CONFIGURATION FILES                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  ROOT/                                                                       â”‚
â”‚  â”œâ”€â”€ package.json           # Frontend dependencies & npm scripts            â”‚
â”‚  â”œâ”€â”€ tsconfig.json          # TypeScript compiler settings                   â”‚
â”‚  â”œâ”€â”€ vite.config.ts         # Vite dev server & bundler settings             â”‚
â”‚  â”‚                                                                           â”‚
â”‚  â””â”€â”€ src-tauri/                                                              â”‚
â”‚      â”œâ”€â”€ Cargo.toml         # Rust dependencies & platform configs           â”‚
â”‚      â”œâ”€â”€ tauri.conf.json    # Tauri app settings (window, bundle, build)     â”‚
â”‚      â”œâ”€â”€ build.rs           # Build-time Rust code (CUDA paths, etc.)        â”‚
â”‚      â””â”€â”€ capabilities/                                                       â”‚
â”‚          â””â”€â”€ default.json   # Security permissions for frontend              â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“„ tauri.conf.json - Tauri Application Configuration

```json
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "taurscribe",
  "version": "0.1.0",
  "identifier": "abdul",
  "build": { ... },
  "app": { ... },
  "bundle": { ... }
}
```

### Line-by-Line Breakdown

#### Schema & Metadata (Lines 2-5)

```json
"$schema": "https://schema.tauri.app/config/2",
```
**What it does:** Enables IDE autocompletion and validation for Tauri 2.x config format.

```json
"productName": "taurscribe",
```
**What it does:** 
- **Windows:** Creates `taurscribe.exe`, shown in Task Manager
- **macOS:** Creates `Taurscribe.app` bundle name
- **Linux:** Creates `taurscribe` binary name

```json
"version": "0.1.0",
```
**What it does:** Application version shown in:
- **Windows:** File Properties â†’ Details â†’ Product Version
- **macOS:** About dialog, App Store
- **Linux:** Package metadata

```json
"identifier": "abdul",
```
**What it does:** Unique app identifier (should be reverse domain like `com.yourname.taurscribe`).
- **Windows:** Used for registry keys, app data paths
- **macOS:** Bundle identifier (required for App Store)
- **Linux:** Desktop entry identifier

---

#### Build Configuration (Lines 6-11)

```json
"build": {
  "beforeDevCommand": "bun run dev",
  "devUrl": "http://localhost:1420",
  "beforeBuildCommand": "bun run build",
  "frontendDist": "../dist"
}
```

| Setting | What it does | When it runs |
|---------|--------------|--------------|
| `beforeDevCommand` | Runs `bun run dev` â†’ starts Vite dev server | `bun tauri dev` |
| `devUrl` | Tells Tauri to load frontend from this URL | Development only |
| `beforeBuildCommand` | Runs `bun run build` â†’ creates production bundle | `bun tauri build` |
| `frontendDist` | Where to find built frontend files | Production build |

**Development Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    bun tauri dev                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  1. beforeDevCommand: "bun run dev"                                          â”‚
â”‚     â””â”€â”€ Starts Vite at http://localhost:1420                                 â”‚
â”‚                                                                              â”‚
â”‚  2. Tauri compiles Rust backend                                              â”‚
â”‚     â””â”€â”€ cargo build --features ...                                           â”‚
â”‚                                                                              â”‚
â”‚  3. Opens window pointing to devUrl                                          â”‚
â”‚     â””â”€â”€ WebView loads http://localhost:1420                                  â”‚
â”‚                                                                              â”‚
â”‚  4. Hot Module Replacement (HMR) active                                      â”‚
â”‚     â””â”€â”€ Edit React â†’ instant update (no restart)                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Production Build Flow:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    bun tauri build                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  1. beforeBuildCommand: "bun run build"                                      â”‚
â”‚     â””â”€â”€ Vite creates optimized bundle in ../dist                             â”‚
â”‚                                                                              â”‚
â”‚  2. Tauri compiles Rust in release mode                                      â”‚
â”‚     â””â”€â”€ cargo build --release --features ...                                 â”‚
â”‚                                                                              â”‚
â”‚  3. Bundles frontend from frontendDist                                       â”‚
â”‚     â””â”€â”€ Embeds ../dist/* into the binary                                     â”‚
â”‚                                                                              â”‚
â”‚  4. Creates platform installers                                              â”‚
â”‚     â””â”€â”€ Windows: .msi, .exe                                                  â”‚
â”‚     â””â”€â”€ macOS:   .app, .dmg                                                  â”‚
â”‚     â””â”€â”€ Linux:   .deb, .AppImage                                             â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### App Configuration (Lines 12-23)

```json
"app": {
  "windows": [
    {
      "title": "Taurscribe",
      "width": 600,
      "height": 600
    }
  ],
  "security": {
    "csp": null
  }
}
```

| Setting | What it does |
|---------|--------------|
| `windows` | Array of window configurations |
| `title` | Window title bar text |
| `width` | Initial window width in pixels |
| `height` | Initial window height in pixels |
| `csp: null` | Disables Content Security Policy (allows all resources) |

**Additional Window Options (not used but available):**
```json
{
  "title": "Taurscribe",
  "width": 600,
  "height": 600,
  "resizable": true,        // Allow resize
  "fullscreen": false,      // Start fullscreen
  "center": true,           // Center on screen
  "decorations": true,      // Show title bar
  "transparent": false,     // Transparent background
  "alwaysOnTop": false,     // Stay on top
  "minWidth": 400,          // Minimum width
  "minHeight": 300          // Minimum height
}
```

**CSP (Content Security Policy):**
```json
"csp": null  // Current: Allow everything (development convenience)

// Production recommendation:
"csp": "default-src 'self'; script-src 'self'"
```
Setting `csp: null` is **unsafe for production** but convenient for development.

---

#### Bundle Configuration (Lines 24-34)

```json
"bundle": {
  "active": true,
  "targets": "all",
  "icon": [
    "icons/32x32.png",
    "icons/128x128.png",
    "icons/128x128@2x.png",
    "icons/icon.icns",
    "icons/icon.ico"
  ]
}
```

| Setting | What it does |
|---------|--------------|
| `active` | Enable bundling (create installers) |
| `targets` | Which installer formats to create |
| `icon` | App icons for different platforms/sizes |

**Icon Usage by Platform:**

| File | Used On | Purpose |
|------|---------|---------|
| `icon.ico` | Windows | Executable icon, taskbar |
| `icon.icns` | macOS | App bundle icon, Dock |
| `32x32.png` | Linux | Small icon (menus) |
| `128x128.png` | Linux | Application icon |
| `128x128@2x.png` | macOS | Retina display icon |

**Bundle Targets by Platform:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BUNDLE OUTPUTS (targets: "all")                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  WINDOWS:                                                                    â”‚
â”‚  â””â”€â”€ target/release/bundle/                                                  â”‚
â”‚      â”œâ”€â”€ msi/taurscribe_0.1.0_x64_en-US.msi    # MSI installer              â”‚
â”‚      â””â”€â”€ nsis/taurscribe_0.1.0_x64-setup.exe   # NSIS installer             â”‚
â”‚                                                                              â”‚
â”‚  MACOS:                                                                      â”‚
â”‚  â””â”€â”€ target/release/bundle/                                                  â”‚
â”‚      â”œâ”€â”€ macos/Taurscribe.app                  # App bundle                  â”‚
â”‚      â””â”€â”€ dmg/Taurscribe_0.1.0_x64.dmg          # Disk image                  â”‚
â”‚                                                                              â”‚
â”‚  LINUX:                                                                      â”‚
â”‚  â””â”€â”€ target/release/bundle/                                                  â”‚
â”‚      â”œâ”€â”€ deb/taurscribe_0.1.0_amd64.deb        # Debian package              â”‚
â”‚      â”œâ”€â”€ rpm/taurscribe-0.1.0.x86_64.rpm       # RPM package                 â”‚
â”‚      â””â”€â”€ appimage/taurscribe_0.1.0_amd64.AppImage  # Portable                â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Cargo.toml - Rust Dependencies & Platform Configuration

### File Structure Overview

```toml
[package]           # Package metadata
[lib]               # Library output settings
[build-dependencies]# Compile-time dependencies
[dependencies]      # Runtime dependencies (ALL platforms)
[target.'cfg(...)'.dependencies]  # Platform-specific deps
[profile.dev]       # Development build settings
```

---

### Package Section (Lines 1-6)

```toml
[package]
name = "taurscribe"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"
```

| Field | What it does |
|-------|--------------|
| `name` | Crate name (used in `use taurscribe::...`) |
| `version` | Crate version (for dependency resolution) |
| `description` | Shows in `cargo search`, crates.io |
| `authors` | Package authors |
| `edition` | Rust edition (2021 = latest stable features) |

**Rust Editions:**
- `2015`: Original Rust
- `2018`: Module system improvements, `async/await`
- `2021`: Disjoint closure captures, `IntoIterator` for arrays

---

### Library Section (Lines 10-15)

```toml
[lib]
name = "taurscribe_lib"
crate-type = ["staticlib", "cdylib", "rlib"]
```

| Setting | What it does |
|---------|--------------|
| `name` | Output library name (different from package to avoid Windows conflict) |
| `crate-type` | What kinds of libraries to produce |

**Crate Types Explained:**

| Type | Output | Used For |
|------|--------|----------|
| `rlib` | `libtaurscribe_lib.rlib` | Rust-to-Rust linking |
| `cdylib` | `taurscribe_lib.dll` (Win) / `.so` (Linux) / `.dylib` (Mac) | C/FFI dynamic linking |
| `staticlib` | `taurscribe_lib.lib` (Win) / `.a` (Unix) | C/FFI static linking |

**Why all three?** Tauri needs different link types for different build scenarios.

---

### Dependencies Section (Lines 20-46)

These dependencies are used on **ALL platforms**:

```toml
[dependencies]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FRAMEWORK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tauri = { version = "2", features = ["tray-icon", "image-png"] }
tauri-plugin-opener = "2"    # Open URLs/files with default app
tauri-plugin-fs = "2"        # File system access
tauri-plugin-store = "2.4.2" # Persistent JSON settings

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SERIALIZATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
serde = { version = "1", features = ["derive"] }  # Derive Serialize/Deserialize
serde_json = "1"                                   # JSON parsing

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AUDIO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
cpal = "0.15"              # Cross-platform audio capture
crossbeam-channel = "0.5"  # Thread communication
hound = "3.5"              # WAV file I/O
rubato = "0.14"            # Audio resampling

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITIES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
chrono = "0.4"             # Date/time
dirs = "6.0.0"             # OS directories
rdev = "0.5"               # Global hotkeys
regex = "1.12.2"           # Text patterns
anyhow = "1.0"             # Error handling

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LLM (GRAMMAR CORRECTION)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
candle-core = { git = "...", version = "0.9.2" }
candle-nn = { git = "...", version = "0.9.2" }
candle-transformers = { git = "...", version = "0.9.2" }
tokenizers = "0.21.0"
hf-hub = "0.4"
```

---

### Platform-Specific Dependencies

This is where Cargo.toml gets interesting - different platforms get different dependencies!

#### How `cfg()` Works

```toml
[target.'cfg(CONDITION)'.dependencies]
```

| Condition | Matches |
|-----------|---------|
| `target_os = "windows"` | Any Windows |
| `target_os = "macos"` | Any macOS |
| `target_os = "linux"` | Any Linux |
| `target_arch = "x86_64"` | 64-bit Intel/AMD |
| `target_arch = "aarch64"` | 64-bit ARM |
| `all(A, B)` | Both A AND B |
| `any(A, B)` | Either A OR B |

---

#### Base Dependencies (Lines 51-55) - Fallback for All Platforms

```toml
# 1. Base / CPU Fallback
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
parakeet-rs = { version = "=0.3.0" }
ort = { version = "2.0.0-rc.11", features = ["download-binaries"] }
```

**No GPU features** - pure CPU. Used when no platform-specific override matches.

---

#### macOS (Lines 66-68) - Apple Silicon & Intel

```toml
[target.'cfg(target_os = "macos")'.dependencies]
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
ort = { version = "2.0.0-rc.11", features = ["download-binaries", "xnnpack"] }
```

| Feature | What it does |
|---------|--------------|
| `xnnpack` | Optimized CPU inference (works on both Intel and Apple Silicon) |

**Note:** No `cuda` or `vulkan` - Macs don't have NVIDIA GPUs. Apple Silicon uses Metal via CoreML internally.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    macOS ACCELERATION STACK                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  APPLE SILICON (M1/M2/M3/M4):                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  App â†’ ONNX Runtime â†’ CoreML Provider â†’ Apple Neural Engine (ANE)       â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Whisper: CPU (whisper.cpp uses Accelerate framework)                   â”‚ â”‚
â”‚  â”‚  Parakeet: CoreML via ONNX Runtime                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  INTEL MAC:                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  App â†’ ONNX Runtime â†’ XNNPACK Provider â†’ CPU (optimized SIMD)           â”‚ â”‚
â”‚  â”‚                                                                         â”‚ â”‚
â”‚  â”‚  Whisper: CPU (whisper.cpp)                                             â”‚ â”‚
â”‚  â”‚  Parakeet: XNNPACK (CPU optimized)                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Windows x86_64 (Lines 77-91) - Full GPU Support

```toml
[target.'cfg(all(target_os = "windows", target_arch = "x86_64"))'.dependencies]

whisper-rs = { git = "...", features = ["cuda", "vulkan"] }
parakeet-rs = { version = "=0.3.0", features = ["cuda", "directml"] }
ort = { version = "2.0.0-rc.11", features = [
    "download-binaries",
    "cuda",
    "directml",
    "tensorrt",
    "xnnpack",
] }
```

| Feature | GPU Vendor | What it does |
|---------|------------|--------------|
| `cuda` | NVIDIA | Direct GPU compute via CUDA |
| `vulkan` | NVIDIA, AMD, Intel | Cross-vendor GPU via Vulkan API |
| `directml` | AMD, Intel, NVIDIA | DirectX 12 GPU acceleration |
| `tensorrt` | NVIDIA | Optimized inference engine |
| `xnnpack` | CPU | Fallback if no GPU |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WINDOWS x86_64 ACCELERATION STACK                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  NVIDIA GPU (RTX/GTX):                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ CUDA â†’ NVIDIA GPU                              â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ CUDA Provider â†’ NVIDIA GPU                    â”‚ â”‚
â”‚  â”‚            OR: ONNX Runtime â†’ TensorRT Provider â†’ NVIDIA GPU            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  AMD GPU (RX/Radeon):                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ Vulkan â†’ AMD GPU                               â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ DirectML Provider â†’ AMD GPU                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  INTEL GPU (Arc/Iris):                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ Vulkan â†’ Intel GPU                             â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ DirectML Provider â†’ Intel GPU                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  NO GPU / FALLBACK:                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ CPU                                            â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ XNNPACK Provider â†’ CPU                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Linux x86_64 (Lines 98-111) - NVIDIA Focus

```toml
[target.'cfg(all(target_os = "linux", target_arch = "x86_64"))'.dependencies]

whisper-rs = { git = "...", features = ["cuda", "vulkan"] }
parakeet-rs = { version = "=0.3.0", features = ["cuda"] }
ort = { version = "2.0.0-rc.11", features = [
    "download-binaries",
    "cuda",
    "tensorrt",
    "xnnpack",
] }
```

**Note:** No `directml` - that's Windows-only (DirectX).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LINUX x86_64 ACCELERATION STACK                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  NVIDIA GPU:                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ CUDA â†’ NVIDIA GPU                              â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ CUDA/TensorRT Provider â†’ NVIDIA GPU           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  AMD/INTEL GPU:                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ Vulkan â†’ AMD/Intel GPU                         â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ XNNPACK (CPU fallback, no DirectML on Linux)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Windows ARM64 (Lines 116-122) - Snapdragon/Qualcomm

```toml
[target.'cfg(all(target_os = "windows", target_arch = "aarch64"))'.dependencies]
ort = { version = "2.0.0-rc.11", features = [
    "download-binaries",
    "directml",
    "xnnpack",
] }
parakeet-rs = { version = "=0.3.0", features = ["directml"] }
```

**Note:** No `cuda` or `vulkan` - ARM Windows devices (Surface Pro X, Snapdragon laptops) don't have NVIDIA GPUs.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WINDOWS ARM64 ACCELERATION STACK                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  QUALCOMM SNAPDRAGON (Adreno GPU):                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ CPU (no ARM CUDA)                              â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ DirectML Provider â†’ Adreno GPU                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  DirectML automatically uses the integrated GPU on ARM Windows devices       â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Linux ARM64 (Lines 127-130) - Raspberry Pi, etc.

```toml
[target.'cfg(all(target_os = "linux", target_arch = "aarch64"))'.dependencies]
whisper-rs = { git = "https://codeberg.org/tazz4843/whisper-rs.git" }
parakeet-rs = { version = "=0.3.0" }
ort = { version = "2.0.0-rc.11", features = ["download-binaries", "xnnpack"] }
```

**CPU only** - no GPU acceleration. XNNPACK provides ARM-optimized CPU inference.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LINUX ARM64 ACCELERATION STACK                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  RASPBERRY PI / ARM SERVER:                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Whisper:  whisper.cpp â†’ CPU (NEON SIMD if available)                   â”‚ â”‚
â”‚  â”‚  Parakeet: ONNX Runtime â†’ XNNPACK Provider â†’ CPU (ARM optimized)        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Profile Section (Lines 133-141)

```toml
[profile.dev]
opt-level = 0            # Don't optimize YOUR code (fast compile)

[profile.dev.package."*"]
opt-level = 1            # Lightly optimize dependencies (faster runtime)
```

**What this does:**

| Profile | Your Code | Dependencies | Result |
|---------|-----------|--------------|--------|
| Default dev | opt-level = 0 | opt-level = 0 | Fast compile, slow runtime |
| **This config** | opt-level = 0 | opt-level = 1 | Fast compile, OK runtime |
| Release | opt-level = 3 | opt-level = 3 | Slow compile, fast runtime |

**Optimization Levels:**
- `0`: No optimization (fastest compile)
- `1`: Basic optimization (small speedup)
- `2`: Standard optimization
- `3`: Aggressive optimization (slowest compile)
- `"s"`: Optimize for size
- `"z"`: Optimize for size more aggressively

---

## ğŸ”¨ build.rs - Build-Time Configuration

This file runs **before** compilation and configures platform-specific settings.

```rust
fn main() {
    tauri_build::build();  // Standard Tauri build

    // Platform-specific configurations below...
}
```

### macOS Configuration

```rust
#[cfg(target_os = "macos")]
{
    println!("cargo:rustc-env=MACOSX_DEPLOYMENT_TARGET=13.4");
    std::env::set_var("MACOSX_DEPLOYMENT_TARGET", "13.4");
    std::env::set_var("CMAKE_OSX_DEPLOYMENT_TARGET", "13.4");
}
```

**What it does:**
- Sets minimum macOS version to 13.4 (Ventura)
- Required because ONNX Runtime needs macOS 13.4+ on Apple Silicon
- `CMAKE_OSX_DEPLOYMENT_TARGET` ensures CMake-based deps (whisper-rs) also target 13.4

---

### Windows ARM64 Configuration

```rust
#[cfg(all(target_os = "windows", target_arch = "aarch64"))]
{
    std::env::set_var("CC", "clang-cl");
    std::env::set_var("CXX", "clang-cl");
    std::env::set_var("CMAKE_GENERATOR_TOOLSET", "ClangCL");
}
```

**What it does:**
- Forces Clang compiler instead of MSVC
- Required because whisper.cpp doesn't compile with MSVC on ARM64
- User must install LLVM/Clang for Windows ARM64

---

### Windows CUDA Configuration

```rust
#[cfg(windows)]
{
    // Try CUDA_PATH environment variable
    if let Ok(cuda_path) = std::env::var("CUDA_PATH") {
        let lib_path = cuda_path.join("lib").join("x64");
        if lib_path.exists() {
            println!("cargo:rustc-link-search=native={}", lib_path.display());
        }
    }
    
    // Fallback: Check standard installation path
    let fallback = r"C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.9\lib\x64";
    // ...
}
```

**What it does:**
- Tells the Rust linker where to find CUDA libraries (cublas.lib, etc.)
- First checks `CUDA_PATH` environment variable (set by CUDA installer)
- Falls back to standard installation path if not found
- Without this, you get `LNK1181: cannot open input file 'cublas.lib'`

---

## ğŸ” capabilities/default.json - Security Permissions

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default",
    "store:default"
  ]
}
```

**What it does:** Defines what the frontend JavaScript can do.

| Permission | What it allows |
|------------|----------------|
| `core:default` | Basic Tauri operations (invoke commands, listen to events) |
| `opener:default` | Open URLs in browser, files with default app |
| `store:default` | Read/write to persistent store (settings.json) |

**Without these permissions:**
```typescript
// This would FAIL without core:default
await invoke("start_recording");

// This would FAIL without store:default
const store = await Store.load("settings.json");
```

---

## ğŸ“¦ package.json - Frontend Configuration

```json
{
  "name": "taurscribe",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": { ... },
  "dependencies": { ... },
  "devDependencies": { ... }
}
```

### Scripts Section

```json
"scripts": {
  "dev": "vite",
  "build": "tsc && vite build",
  "preview": "vite preview",
  "tauri": "tauri",
  "check": "cd src-tauri && cargo check"
}
```

| Script | Command | What it does |
|--------|---------|--------------|
| `dev` | `bun run dev` | Start Vite dev server (port 1420) |
| `build` | `bun run build` | Type-check then build production bundle |
| `preview` | `bun run preview` | Preview production build locally |
| `tauri` | `bun tauri ...` | Run Tauri CLI commands |
| `check` | `bun run check` | Type-check Rust code only |

### Dependencies Section

```json
"dependencies": {
  "@tauri-apps/api": "^2",           // Core Tauri API (invoke, listen)
  "@tauri-apps/plugin-opener": "^2", // Open URLs/files
  "@tauri-apps/plugin-store": "^2.4.2", // Persistent settings
  "react": "^19.1.0",                // React UI library
  "react-dom": "^19.1.0",            // React DOM renderer
  "sonner": "^2.0.7"                 // Toast notifications
}
```

### DevDependencies Section

```json
"devDependencies": {
  "@types/react": "^19.1.8",       // React TypeScript types
  "@types/react-dom": "^19.1.6",   // ReactDOM TypeScript types
  "@vitejs/plugin-react": "^4.6.0", // Vite React plugin (JSX, HMR)
  "typescript": "~5.8.3",          // TypeScript compiler
  "vite": "^7.0.4",                // Build tool & dev server
  "@tauri-apps/cli": "^2"          // Tauri command-line tools
}
```

---

## âš¡ vite.config.ts - Vite Configuration

```typescript
export default defineConfig(async () => ({
  plugins: [react()],        // Enable React JSX/TSX support
  clearScreen: false,        // Don't clear terminal (show Rust errors)
  server: {
    port: 1420,              // Fixed port (Tauri expects this)
    strictPort: true,        // Fail if port busy (don't auto-pick another)
    host: host || false,     // Bind to TAURI_DEV_HOST if set
    hmr: host ? {            // Hot Module Replacement config
      protocol: "ws",
      host,
      port: 1421,
    } : undefined,
    watch: {
      ignored: ["**/src-tauri/**"],  // Don't watch Rust files
    },
  },
}));
```

| Setting | Why it matters for Tauri |
|---------|--------------------------|
| `port: 1420` | Must match `devUrl` in tauri.conf.json |
| `strictPort: true` | Prevents Vite from using 1421 if 1420 is busy |
| `clearScreen: false` | Shows Rust compile errors in terminal |
| `ignored: src-tauri` | Prevents Vite restart when Rust files change |

---

## ğŸ“ tsconfig.json - TypeScript Configuration

```json
{
  "compilerOptions": {
    "target": "ES2020",              // Output JS version
    "lib": ["ES2020", "DOM"],        // Available APIs
    "module": "ESNext",              // Module system
    "moduleResolution": "bundler",   // How to find modules
    "jsx": "react-jsx",              // JSX transform (React 17+)
    "strict": true,                  // Enable all strict checks
    "noUnusedLocals": true,          // Error on unused variables
    "noEmit": true                   // Don't emit (Vite handles this)
  },
  "include": ["src"]                 // Only check src/ folder
}
```

---

## ğŸ—ºï¸ Platform Support Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PLATFORM SUPPORT MATRIX                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Platform      â”‚ Architecture â”‚ GPU Support  â”‚ Output Format            â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Windows       â”‚ x86_64       â”‚ CUDA         â”‚ .msi, .exe (NSIS)        â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ Vulkan       â”‚                          â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ DirectML     â”‚                          â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ TensorRT     â”‚                          â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Windows       â”‚ ARM64        â”‚ DirectML     â”‚ .msi, .exe (NSIS)        â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ XNNPACK      â”‚                          â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ macOS         â”‚ x86_64       â”‚ XNNPACK      â”‚ .app, .dmg               â”‚ â”‚
â”‚  â”‚               â”‚ (Intel)      â”‚              â”‚                          â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ macOS         â”‚ ARM64        â”‚ CoreML       â”‚ .app, .dmg               â”‚ â”‚
â”‚  â”‚               â”‚ (Apple Si)   â”‚ XNNPACK      â”‚                          â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Linux         â”‚ x86_64       â”‚ CUDA         â”‚ .deb, .rpm, .AppImage    â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ Vulkan       â”‚                          â”‚ â”‚
â”‚  â”‚               â”‚              â”‚ TensorRT     â”‚                          â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ Linux         â”‚ ARM64        â”‚ XNNPACK      â”‚ .deb, .rpm, .AppImage    â”‚ â”‚
â”‚  â”‚               â”‚ (RPi, etc.)  â”‚              â”‚                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚  GPU ACCELERATION PRIORITY (runtime selection):                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  1. CUDA (NVIDIA)                                                       â”‚ â”‚
â”‚  â”‚  2. TensorRT (NVIDIA optimized)                                         â”‚ â”‚
â”‚  â”‚  3. DirectML (Windows any GPU)                                          â”‚ â”‚
â”‚  â”‚  4. Vulkan (Cross-platform GPU)                                         â”‚ â”‚
â”‚  â”‚  5. CoreML (Apple Silicon)                                              â”‚ â”‚
â”‚  â”‚  6. XNNPACK (CPU optimized)                                             â”‚ â”‚
â”‚  â”‚  7. CPU (fallback)                                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

Happy coding! ğŸ¦€
